<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Moyuke&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Moyuke&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Moyuke&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="LesterYu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Moyuke's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Moyuke&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-认知神经科学导论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2023-06-04T16:00:00.000Z" itemprop="datePublished">2023-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/">认知神经科学导论笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Lec-1-绪论"><a href="#Lec-1-绪论" class="headerlink" title="Lec 1-绪论"></a>Lec 1-绪论</h2><ul>
<li>课程简介<ul>
<li>本课程注重计算机科学、 计算神经科学、脑科学和⼈⼯智能等多<br>学科的交叉和融合。</li>
<li>⾸先介绍脑启发⼈⼯智能的基本概念和进展，进⼀步讲解基于⼤<br>脑结构和信息处理机制的神经元、突触以及由神经元和突触构成<br>的⽹络， 并着重介绍相关的计算模型和算法。</li>
<li>课程将从⽣物神经元模型和信息处理机制、⼤脑的结构和功能、<br>感知原理及模型、学习机制及学习算法、脉冲神经⽹络等⽅⾯进<br>⾏展开。</li>
<li>通过这门课程的学习，学⽣可以掌握神经科学关于神经元、神经<br>系统的基本机制和模型，以及感知、学习、记忆等功能，启发同<br>学们对脑科学、神经科学、信息技术交叉领域的研究思路，培养<br>掌握新⼀代信息技术的专业⼈才。</li>
<li>掌握大脑神经信息处理和计算的基本机制；<br>掌握神经元的基本计算模型及算法；<br>掌握不同输入对神经活动的影响；<br>掌握主要神经可塑性模型；<br>掌握代表性学习算法；<br>理解基本的大脑感知和认知机制。</li>
</ul>
</li>
<li>认知神经科学三个层次：<ul>
<li>神经元（ Neurons）</li>
<li>神经环路（ Neuron Circuits）</li>
<li>脑的⾼级功能和⾏为（ Behavior）</li>
</ul>
</li>
</ul>
<h2 id="Lec2-神经生理学基础"><a href="#Lec2-神经生理学基础" class="headerlink" title="Lec2-神经生理学基础"></a>Lec2-神经生理学基础</h2><ul>
<li><p>神经计算系统的基本特征 (Characteristics of Neural Computation Systems)</p>
<ul>
<li>基本计算单元：Neurons</li>
<li>信号传递：Signaling is organized in the same way in all neurons</li>
<li>神经元的多样性：Neurons differ most at the molecular level</li>
<li>神经可塑性：<ul>
<li>Neuron carefully selects to connect each other;</li>
<li>Neural connections can be modified by experience</li>
</ul>
</li>
</ul>
</li>
<li><p>神经元形态 (Neural Morphology)</p>
<ul>
<li>形态分类： Morphology<ul>
<li>多极（multipolar） 神经元：有多个树突和一个轴突的神经元，如大多数的神经元。</li>
<li>双极（bipolar） 神经元：只有一个树突和一个轴突的神经元，如视网膜的感光神经元。</li>
<li>单极（unipolar） 神经元： 只有一个突起，从细胞体分离出来后会分为两个末端，一个连接到感觉器官，另一个连接到中枢神经系统，主要负责传递感觉信号。</li>
</ul>
</li>
<li>功能分类： Function<ul>
<li>感觉（sensory） 神经元：传递感觉信息。</li>
<li>运动（motor） 神经元：控制肌肉运动。</li>
<li>中间神经元（interneurons）：在感觉神经元和运动神经元之间传递信息。</li>
</ul>
</li>
<li>突触分类： Synapses<ul>
<li>兴奋性神经元（excitatory neurons）</li>
<li>抑制性神经元（inhibitory neurons）</li>
</ul>
</li>
</ul>
</li>
<li><p>神经元结构 (Neural Structure)</p>
<ul>
<li>Dendrites (树突) Input component</li>
<li>Soma (胞体) Generate an Action Potential</li>
<li>Axon (轴突) Conductive component propagates AP</li>
<li>Axon-end (轴突终端) Output component interact with other neurons</li>
</ul>
</li>
<li><p>信息传递：输入-&gt;整合-&gt;传导-&gt;输出</p>
<ul>
<li>方向性（Direction）：沿着轴突向下游传递， 不能反向传播。</li>
<li>全或无法则（all or nothing principle）： 神经元反应的强弱不随外界刺激的强弱而改变， 信息在传递途中不会变得越来越微弱。</li>
<li>一致性（Non-Degrading）：沿轴突传递的活动强度一致</li>
</ul>
</li>
<li><p>离子通道 (Ion channels)</p>
<ul>
<li>Rapid signaling in the neuron depends on ion channels </li>
<li>Currents through single ion channels can be recorded </li>
<li>神经元的细胞膜具有双层膜结构，由绝缘良好的磷脂构成，是水溶性分子的屏障。</li>
<li>离子通道按门控方式可以分为四类：<br>电压门控离子通道（Voltage-gated ion channels）<br>配合基门控离子通道（Ligand-gated ion channels）<br>磷酸化门控离子通道（Phosphorylation-gated ion channels）<br>机械门控离子通道（Mechanically-gated ion channels）<br>常见的电压门控离子通道有钠离子通道和钾离子通道。</li>
</ul>
</li>
<li><p>神经元的电学特性及膜电位 (Electrical properties and Membrane Potential)</p>
<ul>
<li>膜电位：$ V_m &#x3D; V_{in} - V_{out} $</li>
<li>静膜电位(Resting membrane potential)：$ V_r &#x3D; V_{in} $</li>
</ul>
</li>
<li><p>神经递质 （Neurotransmitter）</p>
</li>
</ul>
<h2 id="Lec3-神经信号与突触"><a href="#Lec3-神经信号与突触" class="headerlink" title="Lec3-神经信号与突触"></a>Lec3-神经信号与突触</h2><ul>
<li><p>AP动作电位（Action Potential）：离子快速跨膜时引起的细胞内和细胞外的电势差，是神经元信息处理能力的基础。 </p>
</li>
<li><p>静息电位——极化<br>当神经细胞处于静息状态时， K+通道开放（Na+通道关闭），这时K+会从浓度高的膜内向浓度低的膜外运动，使膜外带正电，膜内带负电。膜外正电的产生阻止了膜内K+离子的继续外流，使膜电位不再发生变化，此时膜电位称为静息电位。</p>
</li>
<li><p>动作电位（脉冲）——去极化</p>
<p>当神经细胞受到刺激后， Na+通道开放，这样， Na+在很短的时间内会大量涌入细胞内，从而使细胞处于膜内带正电，膜外相对带负电的兴奋状态。此时膜电位称为动作电位，是细胞兴奋的主要表现。</p>
</li>
<li><p>未受刺激的时候，电势外正内负，假设膜电位为-45，这叫“静息电位”，也<br>叫“极化”状态；受刺激后电压上升一段，这叫“去极化”；当突触后电位叠加<br>达到阈值电位时，突触后神经元产生动作电位（即发放脉冲），之后电压会<br>下降一段，这叫“复极化”；复极化超过静息电位的部分叫“超极化”，之后恢<br>复静息电位。</p>
</li>
</ul>
<img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230606103903660.png" alt="image-20230606103903660" style="zoom: 67%;" />

<ul>
<li>突触传递（ Synaptic Transmission）  <ul>
<li>突触前神经元的轴突，与突触后神经元的树突或胞体接触的部位被称为突触；</li>
<li>最普遍的突触类型是化学突触（ Chemical Synapse） ,通过一系列生化反应传递信号：突触前神经元发放神经递质，接触缝隙（ cleft）后端的突触后神经元的接收器与神经递质结合并打开离子通道（ Ion Channel），从而导致突触后神经元膜电位的变化，化学信号转变为电信号；突触后神经元对突触前AP的响应被定义为突触后电位（ postsynaptic potential），简称PSP(postsynaptic potential)。  </li>
<li>电突触（ Electrical Synapse） :神经元之间通过特定膜蛋白直接进行电连接，电突触可能和神经元间的的同步（ synchronization）相关。</li>
</ul>
</li>
</ul>
<h2 id="Lec4-神经元模型"><a href="#Lec4-神经元模型" class="headerlink" title="Lec4-神经元模型"></a>Lec4-神经元模型</h2><ul>
<li><p>脉冲（Spike）：同AP，神经元信息传递的基本单位</p>
</li>
<li><p>脉冲序列（ Spike Train） :一个神经元发放的一系列脉冲。</p>
</li>
<li><p>脉冲序列中的任意脉冲之间都有一定的时间间隔，两个脉冲之间的最短间隔定义了神经元的<strong>不应期（ Refractory Period）</strong>；不应期内接收到信号也很难或不能发放新的脉冲。  </p>
</li>
<li><p>LIF神经元模型：(Leaky Integrate-and-Fire Model)  </p>
<ul>
<li><p>一个神经元被一个很好的绝缘体—细胞膜包围。如果一个短的电流脉冲I(t)注入到神经元中，它将会给细胞膜充电，细胞膜因此像电容C。</p>
</li>
<li><p>因为这个绝缘体并不完美，随着时间的推移，电荷会慢慢通过细胞膜渗漏出来。因此，细胞膜可以被看做有限的泄露电阻R。  </p>
</li>
<li><p>利用电流守恒定律，将驱动电流<code>I(t)</code>分为两个部分：</p>
<ul>
<li><p>$ I(t) &#x3D; I_R + I_C $</p>
</li>
<li><p>其中：<br>$ I_R&#x3D;u_R &#x2F; R &#x3D; (u(t) - u_{rest}) &#x2F; R $<br>$ I_C &#x3D; dq &#x2F; dt &#x3D; Cdu &#x2F; dt $</p>
</li>
<li><p>Leaky Integrate and Fire (LIF) 膜电压变化满足:</p>
</li>
</ul>
<p>  $ \tau_m \frac{du(t)}{dt} &#x3D; -[u(t) - u_{rest}] + R_mI(t) $ : 膜电压动力学方程</p>
<ul>
<li><p>$ \tau_m $: Membrane time constant</p>
</li>
<li><p>$ u(t) $：Membrane potential</p>
</li>
<li><p>$ u_{rest} $： Resting potential</p>
</li>
<li><p>$ R_m $: Membrane resistance</p>
</li>
<li><p>$ I(t) $: Total input current </p>
</li>
<li><p>恒定电流时：$  \frac{du(t)}{dt} + \frac{1}{\tau_m}u(t) &#x3D;  \frac{1}{\tau_m}u_{rest} + \frac{1}{\tau_m}R_mI $ </p>
</li>
<li><p>假设$ u(0) &#x3D; u_{rest} &#x3D; 0 $，最终得到：$ u(t) &#x3D; RI(1 - e^{-\frac{t}{\tau_m}}) $</p>
</li>
<li><p>脉冲发放周期：$ T &#x3D; \tau_mln\frac{RI}{RI - V_{th}} $</p>
</li>
</ul>
</li>
<li><p>定义神经元𝑖的膜电压为𝑢(𝑡)，其静息态膜电压为$𝑢_{rest} $；</p>
</li>
<li><p>𝑡 &#x3D; 0,突触前神经元𝑗发放一个脉冲， 𝑡 &gt; 0 突触后电位(PSP)<br>$ 𝜀_{ij}(𝑡) &#x3D; 𝑢<em>i(𝑡) - 𝑢</em>{rest} $</p>
</li>
<li><p>如果PSP是正的，定义为兴奋型（ Excitatory PSP），简称EPSP；反之定义为抑制型（ Inhibitory PSP），简称IPSP。 </p>
</li>
<li><p>膜电压计算公式：$ 𝑢<em>i(𝑡) &#x3D; \sum</em>{j}\sum_{f}𝜀_{ij}(𝑡 - t_j^{(f)}) + 𝑢_{rest} $</p>
</li>
</ul>
</li>
</ul>
<h2 id="Lec5-神经信息编码"><a href="#Lec5-神经信息编码" class="headerlink" title="Lec5-神经信息编码"></a>Lec5-神经信息编码</h2><ul>
<li>Rate Coding<ul>
<li>It is the firing rate of neurons, not the precise firing time which carries information  </li>
<li>Set an encoding time window T and count the number of spikes within it.  </li>
<li>The temporal average of spike times is defined as the mean firing rate by the following equation:  $ r &#x3D; \frac{n_{sp}}{T} &#x3D; \frac1{T} \int_0^Ts(t)dt$</li>
<li>r：发放率，T：时间窗口长度，n(T)：时间窗口内脉冲数</li>
</ul>
</li>
<li>Temporal Coding<ul>
<li>The precise firing time of neurons carries information</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/" data-id="clj2mxxkt0000wgu2eqnf2rid" data-title="认知神经科学导论笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C++工程规范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/">C++ Project Norm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="File-design："><a href="#File-design：" class="headerlink" title="File design："></a>File design：</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── main.cpp</span><br><span class="line">├── database.h // declaration</span><br><span class="line">├── database.cpp // defination</span><br><span class="line">├── tuple.h // type</span><br><span class="line">├── tuple.cpp</span><br><span class="line">├── writer.h // superclass</span><br><span class="line">├── writer.cpp</span><br><span class="line">├── adiwriter.h // subclass</span><br><span class="line">├── adiwriter.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">├── test.bat // the batch file</span><br><span class="line">├── READNE.md</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Declaration-h"><a href="#Declaration-h" class="headerlink" title="Declaration (.h)"></a>Declaration (.h)</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DATABASE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DATABASE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuple.h&quot;</span> <span class="comment">// 只需调用声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adiwriter.h&quot;</span> <span class="comment">// 只需调用实际用到的子类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::set&lt;tuple&gt; records;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Database</span>();</span><br><span class="line">    <span class="built_in">Database</span>(std::string filename);</span><br><span class="line">    ~<span class="built_in">Database</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>ifndef：防止嵌套调用时出现反复调用的情况。</li>
</ul>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string primaryKey;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; keytypes;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; values;</span><br><span class="line">    <span class="built_in">tuple</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrimaryKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> tuple &amp;a, <span class="type">const</span> tuple &amp;b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>重载运算符：用于排序与比较。</li>
<li>类型定义后使用同struct（不如说就是一个东西）</li>
</ul>
<h2 id="继承类应用"><a href="#继承类应用" class="headerlink" title="继承类应用"></a>继承类应用</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Writer</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Writer</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">adiWriter</span> : <span class="keyword">public</span> Writer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="namespace使用"><a href="#namespace使用" class="headerlink" title="namespace使用"></a>namespace使用</h2><ul>
<li>namespace命名空间，包含多种关键字，std为常用的命名空间，cin，cout即为其中的关键字</li>
<li>若只想使用其中一个：<code>using std::sort;</code></li>
<li>在一个代码块内如果有和命名空间相同的变量名，那么使用<code>using namespace</code>是无效的。</li>
<li>自定义namespace：</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> NM1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NM1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; zero;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>跨文件使用：同class，不过用<code>using namespace</code>调用</li>
</ul>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><ul>
<li><code>argc</code> 和 <code>argv</code>：命令行参数<ul>
<li>第一个参数<code>argc</code>，用于参数计数，其值等于命令行中参数的个数；第二个参数<code>argv</code>，用于参数向量，是一个指向字符串数组的指针。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：./main.o 123 456</span><br><span class="line">&gt;argc = 3</span><br><span class="line">&gt;argv[0] = &quot;./main.o&quot;</span><br><span class="line">&gt;argv[1] = &quot;123&quot;</span><br><span class="line">&gt;argv[2] = &quot;456&quot;</span><br><span class="line">&gt;// 直接运行程序则argc = 1(运行程序而传入的命令)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​		下面的代码用于读入输入的命令（因为要用batch，所以这样读）</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    std::string command;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123; <span class="comment">// 单条完整命令</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(std::cin, command))</span><br><span class="line">            db.<span class="built_in">processCommand</span>(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 命令被空格分开</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">            command = command + argv[i] + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        db.<span class="built_in">processCommand</span>(command);</span><br><span class="line">    &#125;</span><br><span class="line">    db.<span class="built_in">exportDatabase</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>iostream</code>：标准读写流</p>
<ul>
<li><code>cin</code>，<code>cout</code>分别是<code>istream</code>，<code>ostream</code>的对象，我们可以自己创造其他<code>istream</code>，<code>ostream</code>的对象。</li>
<li><code>freopen(&quot;test.txt&quot;,&quot;w&quot;,stdout)</code>将标准输出重定向到<code>test.txt</code>。</li>
</ul>
</li>
<li><p><code>fstream</code>：文件读写流</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">fout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Makefile使用"><a href="#Makefile使用" class="headerlink" title="Makefile使用"></a>Makefile使用</h2><blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare compiler variable</span></span><br><span class="line">CXX=g++</span><br><span class="line"><span class="comment"># Declare compilation options</span></span><br><span class="line">CXXFLAGS=-Wall -g --std=c++11</span><br><span class="line"><span class="comment"># Declare linking options</span></span><br><span class="line">LDFLAGS=</span><br><span class="line"><span class="comment"># Declare source code files</span></span><br><span class="line">SRCS=main.cpp tuple.cpp writer.cpp adiwriter.cpp database.cpp</span><br><span class="line"><span class="comment"># Convert source code files to a list of object files</span></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"><span class="comment"># Declare executable name</span></span><br><span class="line">TARGET=adif</span><br><span class="line"><span class="comment"># Default target</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"><span class="comment"># Dependencies</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="comment"># Automatically generate dependencies</span></span><br><span class="line"><span class="section">.depend: <span class="variable">$(SRCS)</span></span></span><br><span class="line">	rm -f ./.depend</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -MM <span class="variable">$^</span> &gt; ./.depend</span><br><span class="line"><span class="comment"># Include dependencies</span></span><br><span class="line"><span class="keyword">-include</span> .depend</span><br><span class="line"><span class="comment"># Clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span> .depend</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="batch文件"><a href="#batch文件" class="headerlink" title="batch文件"></a>batch文件</h2><ul>
<li><p><code>make.bat</code></p>
<ul>
<li>窗口交互型</li>
<li>没有Makefile，用于编译与生成可执行文件Main</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.cpp -std=c++11 -o main.o</span><br><span class="line">g++ -c database.cpp -std=c++11 -o database.o</span><br><span class="line">...</span><br><span class="line">g++ -o Main main.o Maze.o Player.o</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>test.bat</code></p>
<ul>
<li>指令测试型</li>
<li>有Makefile，用于调用Makefile编译以及输入命令测试。</li>
<li>echo为回显在屏幕上的内容</li>
<li>没有echo的为输入的指令，<code>mingw32-make</code>调用Makefile</li>
<li>pause后，需按任意键才会输入下一条指令</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo The version of C++ is C++11</span><br><span class="line">mingw32-make</span><br><span class="line">echo Compile successfully.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">echo ./adif -i a.adi</span><br><span class="line">adif -i a.adi</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">echo ./adif -s BD8GK</span><br><span class="line">adif -s BD8GK</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">echo ./adif -o test.adi</span><br><span class="line">adif -o test.adi</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/" data-id="cli9awcwm0000l0u29dzj0mdf" data-title="C++ Project Norm" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OOP学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/OOP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/OOP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">OOP Note</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h2><p>（ ）不是面向对象程序设计的主要特征。</p>
<p>A.封装</p>
<p>B.继承</p>
<p>C.多态</p>
<p><strong>D.结构</strong></p>
<p>关于C++与C 语言关系的描述中，（ ）是错误的。</p>
<p>A.C 语言是C++语言的一个子集</p>
<p>B.C 语言与C++语言是兼容的</p>
<p>C.C++语言对C 语言进行了一些改进</p>
<p><strong>D.C++语言和C 语言都是面向对象的</strong></p>
<p>下列关于cin和cout的说法中，错误的是____。</p>
<p>A.cin用于读入用户输入的数据</p>
<p>B.cout用于输出数据</p>
<p><strong>C.cin比C语言中的scanf()函数更有优势，它可以读取空格</strong></p>
<p>D.cout通常与&lt;&lt;运算符结合</p>
<p>关于delete运算符的下列描述中，（）是错误的。</p>
<p>A.它必须用于new返回的指针；</p>
<p>B.使用它删除对象时要调用析构函数；</p>
<p><strong>C.对一个指针可以使用多次该运算符；</strong></p>
<p>D.指针名前只有一对方括号符号，不管所删除数组的维数。</p>
<p>以下程序中，new语句干了什么。</p>
<p>int** num;</p>
<p>num &#x3D; new int* [20];</p>
<p>A.分配了长度为20的整数数组空间，并将首元素的指针返回。</p>
<p>B.分配了一个整数变量的空间，并将其初始化为20。</p>
<p><strong>C.分配了长度为20的整数指针数组空间，并将num[0]的指针返回。</strong></p>
<p>D.存在错误，编译不能通过。</p>
<p>以下程序存在的问题是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> *num1, *num2;</span><br><span class="line"> num1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"> num2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"> num1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"> num2[<span class="number">0</span>] = <span class="number">300</span>;</span><br><span class="line"> num1 = num2;</span><br><span class="line"> <span class="keyword">delete</span> [] num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A.num2不能给num1赋值</p>
<p>B.num2最初指向的空间没有释放</p>
<p><strong>C.num1最初指向的空间没有释放</strong></p>
<p>D.程序没有问题</p>
<p>关于new 和 delete 关键字功能的叙述，不正确的是（ ）</p>
<p>A.C++程序的内存空间，可以分为代码区(text segment）、静态存储区(Data Segment)、栈区(Stack)、堆区(Heap)。new关键字用于从堆区中动态申请创建对象所需的内存空间。</p>
<p>B.new动态申请内存空间成功后，返回该内存区域的首地址；同时，也会自动调用相关类的构造函数。</p>
<p>C.delete用于删除new建立的对象，并释放指针所指向的内存空间，同时，也会自动调用对象的析构函数。</p>
<p><strong>D.B * ptr&#x3D;new B(5)；delete ptr; 假设上述语句中，new申请的内存空间首地址为Addr,存放ptr指针变量值的内存空间首地址为 PAddr，则执行delete ptr 语句后，Addr、PAddr指向的内存区域均会被系统收回。</strong></p>
<p>用new关键字动态申请一个三维数组，则下列语句正确的是（ ）</p>
<p>A.<code>float *fp; fp= new float[10][25][10];</code></p>
<p><strong>B.<code>float (* fp)[25][10]; fp=new float[10][25][10];</code></strong></p>
<p>C.<code>float (* fp)[10]; fp=new float[10][25][10];</code></p>
<p>D.<code>float *fp [25][10]; fp= new float[10][25][10];</code></p>
<p>下列语句中，不能连续输出3个值的是。</p>
<p>A.cout&lt;&lt;x&lt;&lt;y&lt;&lt;z;</p>
<p><strong>B.cout&lt;&lt;x,y,z;</strong></p>
<p>C.cout&lt;&lt;x; cout&lt;&lt;y; cout&lt;&lt;z;</p>
<p>D.cout&lt;&lt;(x,y,z)&lt;&lt;(x,y,z)&lt;&lt;(x,y,z);</p>
<p>在C++中，cin是（）。</p>
<p>A.预定义的类</p>
<p>B.预定义的函数</p>
<p>C.一个标准的语句</p>
<p><strong>D.预定义的对象</strong></p>
<hr>
<h2 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h2><p>假定AA为一个类，a()为该类公有的函数成员，x为该类的一个对象，则访问x对象中函数成员a()的格式为（）</p>
<p>A.x.a</p>
<p><strong>B.x.a()</strong></p>
<p>C.x-&gt;a()</p>
<p>D.(*x).a()</p>
<p>下列关于类定义的说法中，正确的是</p>
<p><strong>A.类定义中包括数据成员和函数成员的声明</strong></p>
<p>B.类成员的缺省访问权限是保护的</p>
<p>C.数据成员必须被声明为私有的</p>
<p>D.成员函数只能在类体外进行定义</p>
<p>下列关于类和对象的叙述中，错误的是</p>
<p><strong>A.一个类只能有一个对象</strong></p>
<p>B.对象是类的具体实例</p>
<p>C.类是对某一类对象的抽象</p>
<p>D.类和对象的关系是一种数据类型与变量的关系</p>
<p>Resolver <code>::</code> is used to:</p>
<p>A.Define a member function outside class declaration</p>
<p>B.Access a member of a namespace</p>
<p>C.Access a static member of a class</p>
<p><strong>D.All of the others</strong></p>
<p>类的实例化是指（ ）。</p>
<p>A.定义类</p>
<p><strong>B.定义对象</strong></p>
<p>C.调用类的成员函数</p>
<p>D.访问对象的数据成员</p>
<p>C＋＋函数的声明和定义可以分开。函数声明不需要( )。</p>
<p>A.返回类型</p>
<p>B.函数名</p>
<p>C.参数表</p>
<p><strong>D.函数体</strong></p>
<p>首先需要在问题域中识别出若干个（ ）</p>
<p>A.函数</p>
<p><strong>B.类</strong></p>
<p>C.文件</p>
<p>D.过程</p>
<hr>
<h2 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h2><hr>
<h2 id="W4"><a href="#W4" class="headerlink" title="W4"></a>W4</h2><p>若有下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>则执行后程序的输出结果是</p>
<p>A.1</p>
<p>B.2</p>
<p>C.3</p>
<p><strong>D.4</strong></p>
<p>设有定义 <code>vector&lt;string&gt; v(10);</code><br>执行下列哪条语句时会调用构造函数?</p>
<p>A.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[0] += &quot;abc&quot;;</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[0] = &quot;2018&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>C.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.push_back(&quot;ZUCC&quot;);</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (v[1] == &quot;def&quot;);</span><br></pre></td></tr></table></figure>



<p>设有如下代码段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;char *, int&gt; m;</span><br><span class="line">const int MAX_SIZE = 100;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char str[MAX_SIZE];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; str;</span><br><span class="line">        m[str] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; m.size() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读入10个字符串，则输出的 <code>m.size()</code> 为</p>
<p>A.0</p>
<p><strong>B.1</strong></p>
<p>C.10</p>
<p>下列关于STL的描述中，错误的是。</p>
<p>A.STL的内容从广义上讲分为容器、迭代器、算法三个主要部分</p>
<p>B.STL的一个基本理念就是将数据和操作分离</p>
<p>C.STL中的所有组件都由模板构成，其元素可以是任意类型</p>
<p><strong>D.STL的容器、迭代器、算法是三个完全独立的部分，彼此也无任何联系</strong></p>
<p>下列创建vector容器对象的方法中，错误的是。</p>
<p>A.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v(10);</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v(10, 1);</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v&#123;10, 1&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>D.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v = (10, 1);</span><br></pre></td></tr></table></figure>



<p>下列选项中，哪一项不是迭代器。</p>
<p>A.输入迭代器</p>
<p>B.前向迭代器</p>
<p>C.双向迭代器</p>
<p><strong>D.删除迭代器</strong></p>
<p>设void f1(int * m，long &amp; n)；int a；long b；则以下调用合法的是（）。</p>
<p>A.f1(a，b)；</p>
<p><strong>B.f1(&amp;a，b)；</strong></p>
<p>C.f1(a，&amp;b)；</p>
<p>D.f1(&amp;a，&amp;b)；</p>
<p>下面程序片段,哪一个是正确的?</p>
<p>A.int n&#x3D;4; int &amp;r&#x3D;n*3;</p>
<p>B.int m&#x3D;5; const int &amp;r&#x3D;m; r&#x3D;6;</p>
<p>C.int n&#x3D;8; const int &amp;p&#x3D;n; int &amp;q&#x3D;p ;</p>
<p><strong>D.int n&#x3D;8; int &amp;p&#x3D;n; const int q&#x3D;p ;</strong></p>
<p>下面程序段 int a&#x3D;1,b&#x3D;2; int &amp;r&#x3D;a; r&#x3D;b; r&#x3D;7; cout&lt;&lt;a&lt;&lt;endl; 的输出结果是?</p>
<p>A.1</p>
<p>B.2</p>
<p><strong>C.7</strong></p>
<p>D.无法确定</p>
<p>已知：float b &#x3D; 34.5； ，则下列表示引用的方法中，正确的是（ ）。</p>
<p><strong>A.float &amp;x &#x3D; b；</strong></p>
<p>B.float &amp;y &#x3D; 34.5；</p>
<p>C.float &amp;z；</p>
<p>D.int &amp;t &#x3D; &amp;b;</p>
<hr>
<h2 id="W5"><a href="#W5" class="headerlink" title="W5"></a>W5</h2><p>在C++语言中引入内联函数（inline function）的主要目的是降低空间复杂度，即缩短目标代码长度。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>主程序调用内联函数（inline）时，不发生控制转移，无需保存和恢复环境变量等，因此，节省了系统开销。内联函数的声明以及最终的生效，是由程序员决定的。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>int Sum (int a,int b&#x3D;5,int c); 这个函数原型的声明没有什么不合适的地方。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>两个以上的函数，具有相同的函数名，且形参的个数或形参的类型不同，或返回的数据类型不同，则称之为函数的重载。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>带有默认值的函数F的函数原型为F(int x&#x3D;5, int x&#x3D;9, int y, float m&#x3D;10.0)，则该函数在编译时会报错。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>如果默认参数的函数声明为“ void fun(int a,int b&#x3D;1,char c&#x3D;’a’,float d&#x3D;3.2);”，<br>则下面调用写法正确的是（ ）。</p>
<p>A.fun();</p>
<p><strong>B.fun(2,3);</strong></p>
<p>C.fun(2, ,’c’,3.14)</p>
<p>D.fun(int a&#x3D;1);</p>
<p>重载函数在调用时选择的依据中，错误的是（）。</p>
<p><strong>A.函数的参数</strong></p>
<p>B.参数的类型</p>
<p>C.函数的名字</p>
<p>D.函数的类型</p>
<p>在（ ）情况下适宜采用inline定义内联函数。</p>
<p>A.函数体含有循环语句</p>
<p>B.函数体含有递归语句</p>
<p><strong>C.函数代码少、频繁调用</strong></p>
<p>D.函数代码多、不常调用</p>
<p>在C++中，关于下列设置缺省参数值的描述中，（）是正确的。</p>
<p>A.不允许设置缺省参数值；</p>
<p><strong>B.在指定了缺省值的参数右边，不能出现没有指定缺省值的参数；</strong></p>
<p>C.只能在函数的定义性声明中指定参数的缺省值；</p>
<p>D.设置缺省参数值时，必须全部都设置；</p>
<p>下面说法正确的是（）。</p>
<p>A.内联函数在运行时是将该函数的目标代码插入每个调用该函数的地方</p>
<p><strong>B.内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方</strong></p>
<p>C.类的内联函数必须在类体内定义</p>
<p>D.类的内联函数必须在类体外通过加关键字inline定义</p>
<p>对定义重载函数的下列要求中，（ ）是错误的。</p>
<p>A.要求参数的个数不同</p>
<p>B.要求参数中至少有一个类型不同</p>
<p><strong>C.要求函数的返回值不同</strong></p>
<p>D.要求参数个数相同时，参数类型不同</p>
<p>当一个函数功能不太复杂，但要求被频繁调用时，选用____。</p>
<p>A.重载函数</p>
<p><strong>B.内联函数</strong></p>
<p>C.递归函数</p>
<p>D.嵌套函数</p>
<p>如有函数定义：void func(int x &#x3D; 0, int y &#x3D; 0){ …. }，则下列函数调用中会出现问题的是____。</p>
<p><strong>A.func(1,2, 3);</strong></p>
<p>B.func(1,2);</p>
<p>C.func(1);</p>
<p>D.func();</p>
<p>以下有关函数的叙述中正确的是（ ）。</p>
<p>A.函数必须返回一个值</p>
<p>B.函数体中必须有return语句</p>
<p><strong>C.两个同名函数，参数表相同而返回值不同不算重载</strong></p>
<p>D.函数执行中形参的改变会改变实参</p>
<p>以下选项中，是正确的函数默认形参设置的是。</p>
<p>A.int fun(int a,int b,int c);</p>
<p><strong>B.int fun(int a,int b,int c&#x3D;1);</strong></p>
<p>C.int fun(int a,int b&#x3D;1,int c);</p>
<p>D.int fun(int a&#x3D;1,int b,int c);</p>
<hr>
<h2 id="W6"><a href="#W6" class="headerlink" title="W6"></a>W6</h2><p>Order of initialization in the initial list is the order of their declaration in the list.</p>
<p>T</p>
<p><strong>F</strong></p>
<p>类的组合关系可以用“Has-A”描述；类间的继承与派生关系可以用“Is-A”描述。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>一个类的友元函数是这个类的成员。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>在C++语言中引入内联函数（inline function）的主要目的是降低空间复杂度，即缩短目标代码长度。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>主程序调用内联函数（inline）时，不发生控制转移，无需保存和恢复环境变量等，因此，节省了系统开销。内联函数的声明以及最终的生效，是由程序员决定的。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>一个函数功能不太复杂，但要求被频繁调用，可选用（ ）。</p>
<p><strong>A.内联函数</strong></p>
<p>B.重载函数</p>
<p>C.递归函数</p>
<p>D.嵌套函数</p>
<p>在（ ）情况下适宜采用inline定义内联函数。</p>
<p>A.函数体含有循环语句</p>
<p>B.函数体含有递归语句</p>
<p><strong>C.函数代码少、频繁调用</strong></p>
<p>D.函数代码多、不常调用</p>
<p>下面说法正确的是（）。</p>
<p>A.内联函数在运行时是将该函数的目标代码插入每个调用该函数的地方</p>
<p><strong>B.内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方</strong></p>
<p>C.类的内联函数必须在类体内定义</p>
<p>D.类的内联函数必须在类体外通过加关键字inline定义</p>
<p>如果默认参数的函数声明为“ void fun(int a,int b&#x3D;1,char c&#x3D;’a’,float d&#x3D;3.2);”，<br>则下面调用写法正确的是（ ）。</p>
<p>A.fun();</p>
<p><strong>B.fun(2,3);</strong></p>
<p>C.fun(2, ,’c’,3.14)</p>
<p>D.fun(int a&#x3D;1);</p>
<p>在C++中，关于下列设置缺省参数值的描述中，（）是正确的。</p>
<p>A.不允许设置缺省参数值；</p>
<p><strong>B.在指定了缺省值的参数右边，不能出现没有指定缺省值的参数；</strong></p>
<p>C.只能在函数的定义性声明中指定参数的缺省值；</p>
<p>D.设置缺省参数值时，必须全部都设置；</p>
<p>决定C++语言中函数的返回值类型的是（）</p>
<p>A.return语句中的表达式类型</p>
<p>B.调用该函数时系统随机产生的类型</p>
<p>C.调用该函数时的主调用函数类型</p>
<p><strong>D.在定义该函数时所指定的数据类型</strong></p>
<p>如有函数定义：void func(int x &#x3D; 0, int y &#x3D; 0){ …. }，则下列函数调用中会出现问题的是____。</p>
<p><strong>A.func(1,2, 3);</strong></p>
<p>B.func(1,2);</p>
<p>C.func(1);</p>
<p>D.func();</p>
<p>以下选项中，是正确的函数默认形参设置的是。</p>
<p>A.int fun(int a,int b,int c);</p>
<p><strong>B.int fun(int a,int b,int c&#x3D;1);</strong></p>
<p>C.int fun(int a,int b&#x3D;1,int c);</p>
<p>D.int fun(int a&#x3D;1,int b,int c);</p>
<p>对于以下关于友元的说法</p>
<p>A.如果函数fun被声明为类A的友元函数，则该函数成为A的成员函数</p>
<p>B.如果函数fun被声明为类A的友元函数，则该函数能访问A的保护成员，但不能访问私有成员</p>
<p>C.如果函数fun被声明为类A的友元函数，则fun的形参类型不能是A。</p>
<p><strong>D.以上答案都不对</strong></p>
<p>对于类之间的友元关系：</p>
<p>A.如果类A是类B的友元，则B的成员函数可以访问A的私有成员</p>
<p>B.如果类A是类B的友元，则B也是A的友元。</p>
<p>C.如果类A是类B的友元，并且类B是类C的友元，则类A也是类C的友元。</p>
<p><strong>D.以上答案都不对。</strong></p>
<p>友元的作用是</p>
<p><strong>A.提高程序的运用效率</strong></p>
<p>B.加强类的封装性</p>
<p>C.实现数据的隐藏性</p>
<p>D.增加成员函数的种类</p>
<p>下面关于友元的描述中，错误的是：</p>
<p>A.友元函数可以访问该类的私有数据成员</p>
<p>B.一个类的友元类中的成员函数都是这个类的友元函数</p>
<p>C.友元可以提高程序的运行效率</p>
<p><strong>D.类与类之间的友元关系可以继承</strong></p>
<p>已知类A是类B的友元，类B是类C的友元，则：</p>
<p>A.类A一定是类C的友元</p>
<p>B.类C一定是类A的友元</p>
<p>C.类C的成员函数可以访问类B的对象的任何成员</p>
<p><strong>D.类A的成员函数可以访问类B的对象的任何成员</strong></p>
<p>不属于类的成员函数的是（ ） 。</p>
<p>A.构造函数</p>
<p>B.析构函数</p>
<p><strong>C.友元函数</strong></p>
<p>D.复制构造函数</p>
<p>若类A被说明成类B的友元，则（ ） 。</p>
<p>A.类A的成员即类B的成员</p>
<p>B.类B的成员即类A的成员</p>
<p>C.类A的成员函数不能访问类B的成员</p>
<p><strong>D.类B不一定是类A的友元</strong></p>
<p>在下列关键字中,用以说明类中公有成员的是（ ）。</p>
<p><strong>A.public</strong></p>
<p>B.private</p>
<p>C.protected</p>
<p>D.friend</p>
<p>Suppose a class is defined without any keywords such as public, private and protected，all members default to</p>
<p>A.public</p>
<p>B.protected</p>
<p><strong>C.private</strong></p>
<p>D.static</p>
<p>Who can access a private member of a class?</p>
<p>A.Only member functions of that class.</p>
<p><strong>B.Only member functions of that class and friend functions or member functions of friend classes</strong></p>
<p>C.Only member functions of that class and derived classes</p>
<p>D.None of the others</p>
<p>静态成员函数没有：</p>
<p>A.返回值</p>
<p><strong>B.this指针</strong></p>
<p>C.指针参数</p>
<p>D.返回类型</p>
<p>For the code below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  static int i;</span><br><span class="line">  //...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Which statement is NOT true?</p>
<p><strong>A.All objects of class A reserve a space for i</strong></p>
<p>B.All objects of class A share the space of i</p>
<p>C.i is a member variable of class A</p>
<p>D.i is allocated in global data space</p>
<hr>
<h2 id="W7"><a href="#W7" class="headerlink" title="W7"></a>W7</h2><p>In C++, inheritance allows a derived class to directly access all of the functions and data of its base class.</p>
<p>T</p>
<p><strong>F</strong></p>
<p>One class can have more than one super classes.</p>
<p><strong>T</strong></p>
<p>F</p>
<p>write the output of the code below.</p>
<p>1.the output at &#x2F;&#x2F;1 is <code>1</code></p>
<p>2.the output at &#x2F;&#x2F;2 is <code>2</code></p>
<p>3.the output at &#x2F;&#x2F;3 is <code>7</code></p>
<p>4.the output at &#x2F;&#x2F;4 is <code>0</code></p>
<p>5.the output at &#x2F;&#x2F;5 is <code>0</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Testing</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string words; </span><br><span class="line">    <span class="type">int</span> number ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Testing</span>(<span class="type">const</span> string &amp; s = <span class="string">&quot;Testing&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        words = s ;</span><br><span class="line">        number = words.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">compare</span>(<span class="string">&quot;Testing&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (words.<span class="built_in">compare</span>(<span class="string">&quot;Heap1&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Testing</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Testing *pc1 , *pc2;</span><br><span class="line">    pc1 = <span class="keyword">new</span> Testing ;          <span class="comment">//1</span></span><br><span class="line">    pc2 = <span class="keyword">new</span> <span class="built_in">Testing</span>(<span class="string">&quot;Heap1&quot;</span>);  <span class="comment">//2</span></span><br><span class="line">    pc1-&gt;<span class="built_in">show</span>();   <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">delete</span> pc1 ;   <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">delete</span> pc2 ;   <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>For the code segment below, in the main(),</p>
<ol>
<li>the output at &#x2F;&#x2F;1 is <code>114</code></li>
<li>the output at &#x2F;&#x2F;2 is <code>303062</code></li>
<li>the output at &#x2F;&#x2F;3 is <code>115</code></li>
<li>the output at &#x2F;&#x2F;4 is <code>303062</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> ii=<span class="number">0</span>):<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        i = a.i;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="number">3</span> &lt;&lt; i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    A a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> ii = <span class="number">0</span>) : <span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b) &#123;</span><br><span class="line">        i = b.i;</span><br><span class="line">        cout &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        A::<span class="built_in">print</span>();</span><br><span class="line">        a.<span class="built_in">print</span>();</span><br><span class="line">        cout &lt;&lt; <span class="number">6</span> &lt;&lt; i;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;        <span class="comment">//1</span></span><br><span class="line">    b.<span class="built_in">print</span>();    <span class="comment">//2</span></span><br><span class="line">    <span class="function">B <span class="title">c</span><span class="params">(b)</span></span>;        <span class="comment">//3</span></span><br><span class="line">    c.<span class="built_in">print</span>();    <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="W8"><a href="#W8" class="headerlink" title="W8"></a>W8</h2><p>虚函数是用virtual 关键字说明的成员函数。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>将构造函数说明为纯虚函数是没有意义的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>抽象类是指一些没有说明对象的类。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>动态绑定是在运行时选定调用的成员函数的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>因为静态成员函数不能是虚函数，所以它们不能实现多态。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>类的组合关系可以用“Has-A”描述；类间的继承与派生关系可以用“Is-A”描述。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>虚函数具有继承性。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>静态成员函数可以声明为虚函数。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针），只能通过派生类继承实现。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>Which one is the characteristic of abstract class?</p>
<p>A.May have virtual functions</p>
<p>B.May have constructors overloaded</p>
<p>C.May have friend function</p>
<p><strong>D.Can not make instance of this class</strong></p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    A() &#123;&#125;;</span><br><span class="line">    virtual f() &#123;&#125;;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>which statement is NOT true:</p>
<p>A.i is private</p>
<p>B.f() is an inline function</p>
<p>C.i is a member of class A</p>
<p><strong>D.sizeof(A) &#x3D;&#x3D; sizeof(int)</strong></p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    virtual f() = 0;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>which statement below is <strong>NOT</strong> true:</p>
<p>A.i is private</p>
<p>B.Objects of class A can not be created</p>
<p>C.i is a member of class A</p>
<p><strong>D.sizeof(A) &#x3D;&#x3D; sizeof(int)</strong></p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line">    int i;</span><br><span class="line">    virtual void f() &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If sizeof(int *) &#x3D;&#x3D; sizeof(int) &#x3D;&#x3D; 4, then sizeof(X)&#x3D;&#x3D;?</p>
<p>A.4</p>
<p>B.6</p>
<p><strong>C.8</strong></p>
<p>D.Undetermined</p>
<p>如果一个类至少有一个纯虚函数，那么就称该类为（）。</p>
<p><strong>A.抽象类</strong></p>
<p>B.虚函数</p>
<p>C.派生类</p>
<p>D.具体类</p>
<p>假设A为抽象类，下列声明（）是正确的。</p>
<p>A.A fun(int);</p>
<p>*<em>B.A <em>p;</em></em></p>
<p>C.int fun(A);</p>
<p>D.A Obj;</p>
<p>在创建派生类对象时，构造函数的执行顺序是( )。</p>
<p>A.对象成员构造函数、基类构造函数、派生类本身的构造函数</p>
<p><strong>B.基类构造函数、对象成员构造函数、派生类本身的构造函数</strong></p>
<p>C.基类构造函数、派生类本身的构造函数、对象成员构造函数</p>
<p>D.派生类本身的构造函数、基类构造函数、对象成员构造函数</p>
<p>派生类中的私有成员</p>
<p>若采用私有继承方式，则派生类对象中的私有成员不可能为 ▁▁▁▁▁。</p>
<p><strong>A.基类中定义的私有成员</strong></p>
<p>B.基类中定义的保护成员</p>
<p>C.基类中定义的公有成员</p>
<p>D.派生类中新增的私有成员</p>
<p>以下说法正确的是？</p>
<p>A.在虚函数中不能使用this指针</p>
<p><strong>B.在构造函数中调用虚函数，不是动态联编</strong></p>
<p>C.抽象类的成员函数都是纯虚函数</p>
<p>D.构造函数和析构函数都不能是虚函数</p>
<hr>
<h2 id="W9"><a href="#W9" class="headerlink" title="W9"></a>W9</h2><p>当用一个对象去初始化同类的另一个对象时,要调用拷贝构造函数。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>对象间赋值将调用拷贝构造函数。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>下列各类函数中，不是类的成员函数的是</p>
<p>A.构造函数</p>
<p>B.析构函数</p>
<p><strong>C.友元函数</strong></p>
<p>D.拷贝构造函数</p>
<p>设类AA已定义，假设以下语句全部合法，哪些语句会触发调用拷贝构造函数（ ）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AA a, b; //1</span><br><span class="line">AA c(10, 20); //2</span><br><span class="line">AA d(c); //3</span><br><span class="line">AA e = d; //4</span><br></pre></td></tr></table></figure>

<p>A.2</p>
<p>B.3</p>
<p>C.4</p>
<p><strong>D.3 和 4</strong></p>
<p>假设MyClass是一个类，则该类的拷贝初始化构造函数的声明语句为（ ）</p>
<p>A.MyClass&amp;(MyClass x);</p>
<p>B.MyClass(MyClass x);</p>
<p><strong>C.MyClass(MyClass &amp;x);</strong></p>
<p>D.MyClass(MyClass *x);</p>
<p>下列关于异常类的说法中，错误的是。</p>
<p><strong>A.异常类由标准库提供，不可以自定义</strong></p>
<p>B.C++的异常处理机制具有为抛出异常前构造的所有局部对象自动调用析构函数的能力</p>
<p>C.若catch块采用异常类对象接收异常信息，则在抛出异常时将通过拷贝构造函数进行对象复制，异常处理完后才将两个异常对象进行析构，释放资源</p>
<p>D.异常类对象抛出后，catch块会用类对象引用接收它以便执行相应的处理动作</p>
<p>下列哪一个说法是错误的?</p>
<p>A.当用一个对象去初始化同类的另一个对象时,要调用拷贝构造函数</p>
<p>B.如果某函数有一个参数是类A的对象,那么该函数被调用时,类A的拷贝构造函数将被调用</p>
<p>C.如果函数的返回值是类A的对象时，则函数返回时，类A的拷贝构造函数将被调用</p>
<p><strong>D.拷贝构造函数必须自己编写</strong></p>
<p>假设A是一个类的名字,下面哪段程序不会用到A的拷贝构造函数？</p>
<p><strong>A.A a1,a2; a1&#x3D;a2;</strong></p>
<p>B.void func( A a) { cout&lt;&lt;”good”&lt;&lt; endl; }</p>
<p>C.A func() { A tmp; return tmp;}</p>
<p>D.A a1; A a2(a1);</p>
<p>如果某函数的返回值是个对象 ，则该函数被调用时，返回的对象？</p>
<p><strong>A.是通过拷贝构造函数初始化的</strong></p>
<p>B.是通过无参数的构造函数初始化的</p>
<p>C.用哪个构造函数初始化，取决于函数中return 语句是怎么写的</p>
<p>D.不需要初始化</p>
<hr>
<h2 id="W11"><a href="#W11" class="headerlink" title="W11"></a>W11</h2><p>多数运算符可以重载，个别运算符不能重载，运算符重载是通过函数定义实现的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>对每个可重载的运算符来讲，它既可以重载为友元函数，又可以重载为成员函数，还可以重载为非成员函数。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>对单目运算符重载为友元函数时，可以说明一个形参。而重载为成员函数时，不能显式说明形参。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>重载运算符可以保持原运算符的优先级和结合性不变。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>预定义的提取符和插入符是可以重载的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>重载operator+时，返回值的类型应当与形参类型一致。<br>比如以下程序中，operator+的返回值类型有错：</p>
<p>class A {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br></pre></td></tr></table></figure>

<p>public:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A(int t=0):x(t)&#123;     &#125;</span><br><span class="line"></span><br><span class="line">   int operator+(const A&amp; a1)&#123; return x+a1.x;  &#125;</span><br></pre></td></tr></table></figure>

<p>};</p>
<p>T</p>
<p><strong>F</strong></p>
<p>重载关系运算符一般都返回true或false值。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>The operator <code>::</code> can not be overloaded.</p>
<p><strong>T</strong></p>
<p>F</p>
<p>若重载为友元函数，函数定义格式如下：</p>
<p>&lt;类型&gt;operator&lt;运算符&gt;（&lt;参数列表&gt;）</p>
<p>{</p>
<p>&lt;函数体&gt;</p>
<p>}</p>
<p>T</p>
<p><strong>F</strong></p>
<p>下列运算符中，（ ）运算符不能重载。</p>
<p>A.＆＆</p>
<p>B.[ ]</p>
<p><strong>C.::</strong></p>
<p>D.&lt;&lt;</p>
<p>下列关于运算符重载的描述中，（ ）是正确的。</p>
<p>A.运算符重载可以改变操作数的个数</p>
<p>B.运算符重载可以改变优先级</p>
<p>C.运算符重载可以改变结合性</p>
<p><strong>D.运算符重载不可以改变语法结构</strong></p>
<p>为了能出现在赋值表达式的左右两边，重载的”[]”运算符应定义为：</p>
<p>A.A operator [ ] (int);</p>
<p><strong>B.A&amp; operator [ ] (int);</strong></p>
<p>C.const A operator [ ] (int);</p>
<p>D.以上答案都不对</p>
<p>在C++中不能重载的运算符是</p>
<p><strong>A.?:</strong></p>
<p>B.+</p>
<p>C.-</p>
<p>D.&lt;&#x3D;</p>
<p>下列关于运算符重载的表述中，正确的是（）。</p>
<p>A.C++已有的任何运算符都可以重载</p>
<p>B.运算符函数的返回类型不能声明为基本数据类型</p>
<p><strong>C.在类型转换符函数的定义中不需要声明返回类型</strong></p>
<p>D.可以通过运算符重载来创建C++中原来没有的运算符</p>
<p>能用友元函数重载的运算符是（）。</p>
<p><strong>A.+</strong></p>
<p>B.&#x3D;</p>
<p>C.[]</p>
<p>D.-&gt;</p>
<p>下列哪一项说法是不正确的?</p>
<p>A.运算符重载的实质是函数重载</p>
<p>B.运算符重载可以重载为普通函数,也成员可以重载为成员函数</p>
<p>C.运算符被多次重载时,根据实参的类型决定调用哪个运算符重载函数</p>
<p><strong>D.运算符被多次重载时,根据函数类型决定调用哪个重载函数</strong></p>
<p>如何区分自增运算符重载的前置形式和后置形式？</p>
<p>A.重载时，前置形式的函数名是++operator，后置形式的函数名是operator ++</p>
<p><strong>B.后置形式比前置形式多一个 int 类型的参数</strong></p>
<p>C.无法区分，使用时不管前置形式还是后置形式，都调用相同的重载函数</p>
<p>D.前置形式比后置形式多一个 int 类型的参数</p>
<p>下列关于运算符重载的描述正确的是（ ）。</p>
<p>A.运算符重载可以改变操作数的个数</p>
<p>B.可以创造新的运算符</p>
<p><strong>C.运算符可以重载为友元函数</strong></p>
<p>D.任意运算符都可以重载</p>
<p>在重载一个运算符时，如果其参数表中有一个参数，则说明该运算符是( )。</p>
<p>A.一元成员运算符</p>
<p>B.二元成员运算符</p>
<p>C.一元友元运算符</p>
<p><strong>D.二元成员运算符或一元友元运算符</strong></p>
<p>下列关于运算符重载的描述中，错误的是（）。</p>
<p>A.运算符重载不改变优先级</p>
<p><strong>B.运算符重载后，原来运算符操作不可再用</strong></p>
<p>C.运算符重载不改变结合性</p>
<p>D.运算符重载函数的参数个数与重载方式有关</p>
<p>若需要为xv类重载乘法运算符,运算结果为xv类型,在将其声明为类的成员函数时,下列原型声明正确的是_________。</p>
<p>A.xv*(xv);</p>
<p>B.operator*(xv);</p>
<p><em><em>C.xv operator</em>(xv);</em>*</p>
<p>D.xv operator*(xv,xv);</p>
<p>下列运算符中，不可以重载的是（ ）。</p>
<p>A.new</p>
<p>B.++</p>
<p><strong>C..</strong>*</p>
<p>D.[]</p>
<hr>
<h2 id="W13"><a href="#W13" class="headerlink" title="W13"></a>W13</h2><p>pair类模板的作用是将两个数据组成一个数据，用来表示一个二元组或一个元素对，两个数据可以是同一个类型也可以是不同的类型。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>现有声明：</p>
<p>template</p>
<p>class Test{…};</p>
<p>则以下哪一个声明不可能正确。</p>
<p>A.Test a;</p>
<p>B.Test &lt; int&gt; a;</p>
<p>C.Test &lt; float&gt; a;</p>
<p>D.Test&lt; Test &lt; int&gt; &gt; a;</p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class T &gt;</span><br><span class="line">void swap( T&amp; x, T&amp; y ) &#123;</span><br><span class="line">   T temp = x;</span><br><span class="line">   x = y;</span><br><span class="line">   y = temp;</span><br><span class="line">&#125;</span><br><span class="line">int i,j;</span><br><span class="line">float f,m;</span><br></pre></td></tr></table></figure>

<p>Which statement is incorrect?</p>
<p>A.swap(i,j);</p>
<p>B.swap(j,i);</p>
<p>C.swap(f,m)</p>
<p>D.swap(i,f);</p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void f(int i) &#123; cout &lt;&lt; &quot;Func1&quot; &lt;&lt; endl; &#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T t) &#123; cout &lt;&lt; &quot;Func2&quot; &lt;&lt; endl; &#125;</span><br><span class="line">main() &#123;</span><br><span class="line">    f(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The result is :</p>
<p>A.Func1</p>
<p>B.Func2</p>
<p>C.<code>*nothing*</code></p>
<p>D.undetermined</p>
<p>下列的模板说明中，正确的是。</p>
<p>A.template &lt; typename T1, T2 &gt;</p>
<p>B.template &lt; class T1, T2 &gt;</p>
<p>C.template &lt; typename T1, typename T2 &gt;</p>
<p>D.template ( typedef T1, typedef T2 )</p>
<p>关于类模板，描述错误的是。</p>
<p>A.一个普通基类不能派生类模板</p>
<p>B.类模板可以从普通类派生，也可以从类模板派生</p>
<p>C.根据建立对象时的实际数据类型，编译器把类模板实例化为模板类</p>
<p>D.函数的类模板参数需生成模板类并通过构造函数实例化</p>
<p>建立类模板对象的实例化过程为。</p>
<p>A.基类-派生类</p>
<p>B.构造函数-对象</p>
<p>C.模板类-对象</p>
<p>D.模板类-模板函数</p>
<p>下列有关模板的描述，错误的是____。</p>
<p>A.模板把数据类型作为一个设计参数，称为参数化程序设计</p>
<p>B.使用时，模板参数与函数参数相同，是按位置而不是名称对应的</p>
<p>C.模板参数表中可以有类型参数和非类型参数</p>
<p>D.类模板与模板类是同一个概念</p>
<p>模板函数的真正代码是在哪个时期产生的____。</p>
<p>A.源程序中声明函数时</p>
<p>B.源程序中定义函数时</p>
<p>C.源程序中调用函数时</p>
<p>D.运行执行函数时</p>
<p>类模板的使用实际上是将类模板实例化成一个____。</p>
<p>A.函数</p>
<p>B.对象</p>
<p>C.类</p>
<p>D.抽象类</p>
<p>声明模板的关键字为____。</p>
<p>A.static</p>
<p>B.template</p>
<p>C.typename</p>
<p>D.class</p>
<p>下列对模板的声明，正确的是____。</p>
<p>A.template<T></p>
<p>B.template&lt;class T1, T2&gt;</p>
<p>C.template&lt;class T1, class T2&gt;</p>
<p>D.template&lt;class T1, class T1&gt;</p>
<p>下列选项中，哪一项是类模板实例化的时期____。</p>
<p>A.在编绎时期进行</p>
<p>B.属于动态联编</p>
<p>C.在运行时进行</p>
<p>D.在连接时进行</p>
<p>下列选项中，哪一个函数可以定义为对许多数据类型完成同一任务____。</p>
<p>A.函数模板</p>
<p>B.递归函数</p>
<p>C.模板函数</p>
<p>D.重载函数</p>
<p>一个____允许用户为类定义一种模式，使得类中的某些数据成员及某些成员函数的返回值能取任意类型。</p>
<p>A.函数模板</p>
<p>B.模板函数</p>
<p>C.类模板</p>
<p>D.模板类</p>
<p>下列关于pair&lt;&gt;类模板的描述中，错误的是。</p>
<p>A.pair&lt;&gt;类模板定义头文件utility中</p>
<p>B.pair&lt;&gt;类模板作用是将两个数据组成一个数据，两个数据可以是同一个类型也可以是不同的类型</p>
<p>C.创建pair&lt;&gt;对象只能调用其构造函数</p>
<p>D.pair&lt;&gt;类模拟提供了两个成员函数first与second来访问这的两个数据</p>
<p>模板的使用是为了（）。</p>
<p>A.提高代码的可重用性</p>
<p>B.提高代码的运行效率</p>
<p>C.加强类的封装性</p>
<p>D.实现多态性</p>
<p>假设声明了一下的函数模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">T max(T x, T y)</span><br><span class="line">&#123;</span><br><span class="line">    return  (x&gt;y)?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并定义了int i; char c;<br>错误的调用语句是（）。</p>
<p>A.max(i,i);</p>
<p>B.max(c,c);</p>
<p>C.max((int)c,i);</p>
<p>D.max(i,c);</p>
<hr>
<h2 id="W14"><a href="#W14" class="headerlink" title="W14"></a>W14</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/OOP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cliah5jol00009su26k7w0yht" data-title="OOP Note" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB后篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/DB%E5%90%8E%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/DB%E5%90%8E%E7%AF%87/">DB后篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><ul>
<li><p>分类：</p>
<ul>
<li><p>易失存储 volatile storage </p>
</li>
<li><p>非易失存储 non-volatile storage </p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607021440123.png" alt="image-20230607021440123"></p>
</li>
<li><p>NVM（non-volatile memory）: 掉电不丢</p>
</li>
<li><p><strong>primary storage</strong>: Fastest media but volatile (cache, main memory).</p>
</li>
<li><p><strong>secondary storage</strong>: next level in hierarchy, non-volatile, moderately fast access time</p>
<p>also called <strong>on-line storage</strong> </p>
<p>E.g. flash memory, magnetic disks</p>
</li>
<li><p><strong>tertiary storage:</strong> lowest level in hierarchy, non-volatile, slow access time</p>
<p>also called <strong>off-line storage</strong> </p>
<p>E.g. magnetic tape, optical storage</p>
</li>
</ul>
</li>
<li><p>磁盘 magnetic disks</p>
<ul>
<li><p>tracks(磁道)  sectors(扇区)</p>
</li>
<li><p>Access Time 访问时间，毫秒级</p>
<ul>
<li>Seek Time 寻道时间：找到对应磁道</li>
<li>Rotational latency 旋转延迟：转到对应扇区</li>
</ul>
</li>
<li><p>Data-transfer rate 数据传输率</p>
</li>
<li><p><em>数据库传输以block为单位</em> </p>
</li>
<li><p>访问模式：</p>
<ul>
<li><p>Sequential access pattern(顺序访问模式)<br>Successive requests are for successive disk blocks<br>Disk seek required only for first block</p>
</li>
<li><p>Random access pattern（随机访问模式）<br>Each access requires a seek<br><em>Transfer rates are low since a lot of time is wasted in seeks</em> </p>
<p><em>尽量转化为顺序访问模式</em> </p>
</li>
<li><p>I&#x2F;O operations per second (IOPS ，每秒I&#x2F;O操作数)</p>
<ul>
<li>衡量磁盘访问速度</li>
<li>Number of random block reads that a disk can support per second<br>50 to 200 IOPS on current generation magnetic disks</li>
</ul>
</li>
</ul>
</li>
<li><p>Mean time to failure (MTTF，平均故障时间)</p>
<ul>
<li>衡量磁盘可靠性</li>
<li>the average time the disk is expected to run continuously without any failure</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘块访问的优化</p>
<ul>
<li><p>Buffering 缓存: in-memory buffer to cache disk blocks</p>
</li>
<li><p>Read-ahead(Prefetch): Read extra blocks from a track in anticipation that they will be requested soon</p>
</li>
<li><p><strong>Disk-arm-scheduling</strong> algorithms re-order block requests so that disk arm movement is minimized </p>
</li>
<li><p>File organization：将碎片化的文件重新整理<br>Allocate blocks of a file in as contiguous a manner as possible<br>Allocation in units of extents(盘区）</p>
</li>
<li><p>Nonvolatile write buffers （非易失性写缓存）</p>
<p>speed up disk writes by writing blocks to a non-volatile RAM buffer immediately</p>
</li>
<li><p>Log disk（日志磁盘）</p>
<p>a disk devoted to writing a sequential log of block updates<br>Used exactly like nonvolatile RAM</p>
</li>
</ul>
</li>
<li><p>Flash Storage</p>
<ul>
<li>NAND flash<ul>
<li>Page can only be written once<br>Must be erased to allow rewrite</li>
</ul>
</li>
<li>SSD(Solid State Disks) <ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607024602936.png" alt="image-20230607024602936"></li>
<li>SSD比磁盘快百倍，磁盘能耗高（机械运动）更新为即席写入</li>
</ul>
</li>
<li>Flash storage 中的地址映射漂移，已达成磨损均衡（wear leveling)</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607024919201.png" alt="image-20230607024919201"></li>
<li>对于大数据，热数据（常访问）放在SSD，冷数据放在磁盘里</li>
</ul>
</li>
<li><p>NVM，又称Storage Class Memory</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607025337181.png" alt="image-20230607025337181"></li>
<li>Persistence可以看出是否易失</li>
<li>NVM和SSD与硬盘不同，用字节寻址</li>
</ul>
</li>
<li><p>随堂测试：</p>
<ul>
<li><p>Which physical storage media is non-volatile?</p>
<p>多选题 (1 分) </p>
<p> A.cache</p>
<p> B.main memory</p>
<p> C.flash memory</p>
<p> D.magnetic disk</p>
<p> E.SSD(State Solid Disk)</p>
<p> F.magnetic tapes</p>
<p> G.optical disk</p>
<p>正确答案: C D E F G</p>
</li>
<li><p>Which physical storage medias belong to the secondary storage? </p>
<p>多选题 (1 分)</p>
<p> A.cache</p>
<p> B.main memory </p>
<p> C.flash memory</p>
<p> D.SSD(Solid State Disk)</p>
<p> E.magnetic disk</p>
<p> F.magnetic tapes</p>
<p> G.optical disk</p>
<p>正确答案: C D E</p>
</li>
<li><p>Which term represents the time that the disk controller takes to reposition the disk arm over the correct track.</p>
<p>单选题 (1 分)</p>
<p> A.access time</p>
<p> B.seek time</p>
<p> C.rotational latency</p>
<p> D.data-transfer rate </p>
<p>正确答案: B</p>
</li>
<li><p>What is the right approach to  optimizing  data access of disks?</p>
<p>多选题 (1 分)</p>
<p> A.Buffering</p>
<p> B.Read-ahead</p>
<p> C.defragment the file system</p>
<p> D.Non-volatile write buffers</p>
<p> E.Log disk</p>
<p>正确答案: A B C D E</p>
</li>
<li><p>MTTF means    1   (注意：每个单词首字母大写).</p>
<p>填空题 (1 分) (请按题目中的空缺顺序依次填写答案)</p>
<p>正确答案: Mean Time To Failure</p>
</li>
<li><p>IOPS  means     1   (注意：每个单词首字母大写).</p>
<p>填空题 (1 分) (请按题目中的空缺顺序依次填写答案)</p>
<p>正确答案: I&#x2F;O Operations Per Second</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h2><ul>
<li><p>数据库文件存在磁盘里，文件由记录(record)组成，record由各个字段(field)组成</p>
</li>
<li><p>定长记录(Fixed-Length Record)，可以计算每个block可以放多少记录</p>
<ul>
<li>存record i：若长n byte，从n*(i-1) byte开始</li>
<li>删除：不移动 record，记为空记录<ul>
<li>空记录设指针指下一个空的record</li>
<li>头部加上header指向第一条空记录</li>
</ul>
</li>
</ul>
</li>
<li><p>不定长记录(Variable-Length Record)</p>
<ul>
<li>原因：有不定长字符串，有空字段</li>
<li>方法：不定长的全放后面，用(offset,length)记录位置和长度</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607031402403.png" alt="image-20230607031402403"></li>
<li>Null bitmap：有几个属性就有几位，0表示非空，1表示空</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607032222398.png" alt="image-20230607032222398"></li>
<li>插入：指针+长度存记录位置，在free space从后往前插入</li>
<li>删除：相对地址，block_num + index</li>
</ul>
</li>
<li><p>Record组织规则：</p>
<ul>
<li>堆：<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607033306769.png" alt="image-20230607033306769"></li>
<li>维护空闲块的map，记录空闲程度：7即7&#x2F;8的空闲</li>
</ul>
</li>
<li>顺序 Sequential<ul>
<li>插入：插到中间会导致后面的记录全体后移，因此直接放在最后，通过指针串联<ul>
<li>每个一段时间按顺序重整（克服碎片化）</li>
</ul>
</li>
</ul>
</li>
<li>B+树</li>
<li>哈希</li>
</ul>
</li>
<li><p>存放方式：</p>
<ul>
<li>按行存放</li>
<li>按列存放：cache命中率高</li>
</ul>
</li>
<li><p>缓存管理 Buffer manager</p>
<ul>
<li>缓存替换：<ul>
<li>LRU策略（Least Recently Used）最近最少用到</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607035017615.png" alt="image-20230607035017615"></li>
<li>在for循环等场景，LRU可能是一种坏策略</li>
</ul>
</li>
<li>若访问的block不在缓存，读出到缓冲区</li>
<li>访问请求时，钉在(pin)缓冲区，请求为读时加共享锁，写时加exclusive lock</li>
</ul>
</li>
<li><p>随堂测试：</p>
<ul>
<li><p>What is contained in the header of slotted page? </p>
<p>多选题 (1 分)</p>
<p> A.number of record entries</p>
<p> B.end location of free space in the block</p>
<p> C.location of each record</p>
<p> D.size of each record</p>
<p> E.primary key of each record</p>
<p>正确答案: A B C D</p>
</li>
<li><p>What kind file organization is suitable for applications that require sequential processing of the entire file? </p>
<p>单选题 (1 分)</p>
<p> A.heap file organization</p>
<p> B.sequential file organization</p>
<p> C.multitable clustering file organization</p>
<p> D.hash file organization</p>
<p>正确答案: B</p>
</li>
<li><p>Which statement is incorrect?</p>
<p>多选题 (1 分)</p>
<p> A.For heap file organization, records can be placed anywhere in the file where there is free space.</p>
<p> B.Database system seeks to minimize the number of block transfers between the disk and memory. </p>
<p> C.If the needed block is not in the buffer, the buffer manager will replace some other block, if required, to make space for the new block.</p>
<p> D.LRU is the most suitable replacement strategy for buffer manager in any cases.</p>
<p>正确答案: D</p>
</li>
<li><p>For the buffer manager, there are following assumptions:</p>
<p>• There are 4 buffer pages.</p>
<p>• Initially the buffer is empty occupied.</p>
<p>• The data access sequence is 1,2,3,4,5,4,3,2,1,3,5</p>
<p>According to the LRU replacement strategy, there are    1    times replacements occurred,  and the data item    2    is the least recently used after completing the above data access sequence.</p>
<p>填空题 (1 分) (请按题目中的空缺顺序依次填写答案)</p>
<p>正确答案:</p>
<p>1：3</p>
<p>2：2</p>
</li>
</ul>
</li>
</ul>
<h2 id="索引Indexing"><a href="#索引Indexing" class="headerlink" title="索引Indexing"></a>索引Indexing</h2><ul>
<li><p>Form：search key - pointer</p>
</li>
<li><p>Query type</p>
<ul>
<li><p>Point query: records with a specified value in the attribute</p>
</li>
<li><p>Range query: records with an attribute value falling in a specified range of values.</p>
</li>
</ul>
</li>
<li><p>Primary index 主索引</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160436673.png" alt="image-20230610160436673"></li>
<li>candidate key唯一情况下用起来方便</li>
</ul>
</li>
<li><p>Secondary Indices</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160508100.png" alt="image-20230610160508100"></li>
<li>不唯一，中间的指针指向多个目标</li>
<li></li>
</ul>
</li>
<li><p>Dense index：Index record appears for every search-key value in the file. </p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160725335.png" alt="image-20230610160725335"></li>
</ul>
</li>
<li><p>Sparse index：contains index records for only some search-key values.</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160742907.png" alt="image-20230610160742907"></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160938171.png" alt="image-20230610160938171"></li>
</ul>
</li>
<li><p>Multilevel Index（多级索引）</p>
<ul>
<li>索引的索引</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610161015946.png" alt="image-20230610161015946"></li>
</ul>
</li>
<li><p>B+ Tree Index</p>
<ul>
<li>每个节点都和block大小一样</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610161325306.png" alt="image-20230610161325306"></li>
<li>叶子结点就是末级索引，之间用指针相连，使连续</li>
<li>高度：$ log_{n}(k)&lt;&#x3D; height &lt;&#x3D;log_{n&#x2F;2}(k&#x2F;2)+1 $，向上取整（根节点最小两叉）</li>
<li>大小：最大：半满，最小：全满</li>
<li>和ADS不同：每个节点容量相等，非叶子和叶子一样（ADS里非叶子最多阶数-1）<ul>
<li>也就是说中间结点的分叉数比叶子结点值数多1</li>
</ul>
</li>
<li>作用：叉数多，层数少，减少seek&amp;block transfer次数</li>
</ul>
</li>
<li><p>估计 height &amp; size</p>
<ul>
<li><p>person( pid char(18) primary key,  </p>
<p>​			name char(8), </p>
<p>​			age smallint,<br>​             address char(40)); </p>
<p>Block size : 4K<br>1000000 persons</p>
</li>
<li><p>Records per block &#x3D;  4096&#x2F;(18+8+2+40) &#x3D;60.235&#x3D;60</p>
<ul>
<li>record 大小根据各个属性类型算</li>
</ul>
</li>
<li><p>blocks for storing 1M persons&#x3D; 1000000&#x2F;60 &#x3D;16667</p>
<ul>
<li>计算block数</li>
</ul>
</li>
<li><p>B+ tree n(fan-out)  &#x3D; (4096-4)&#x2F;(18+4) +1 &#x3D; 187</p>
<ul>
<li><p>B+树一个节点就是一个block，存放M个值和M+1个指针</p>
<p>即使是叶子结点，也多出一个指向下一个叶子的指针</p>
<p>指针比值多一个，所以先-4，后+1</p>
</li>
<li><p>一个索引项&#x3D;索引值+指针(假设4byte)&#x3D;18+4</p>
</li>
<li><p>最大187叉，最少 n&#x2F;2 &#x3D; 94叉</p>
</li>
<li><p>能索引多少值</p>
<ul>
<li><p>2 levels:  min&#x3D;2<code>*</code>93 &#x3D; 186            max&#x3D; 187’<code>*</code>186 &#x3D; 34,782</p>
</li>
<li><p>3 levels:  min&#x3D;2<code>*</code>94<code>*</code>93 &#x3D; 17484        max&#x3D;187<code>*</code>187<code>*</code>186 &#x3D; 6,504,234</p>
</li>
<li><p>4 levels:  min&#x3D;2<code>*</code>94<code>*</code>94<code>*</code>93 &#x3D; 1,643,496</p>
<p>​			   max&#x3D;187<code>*</code>187<code>*</code>187<code>*</code>186 &#x3D; 1,216,291,758</p>
</li>
</ul>
</li>
<li><p>易得这个B+树为3层</p>
</li>
</ul>
</li>
<li><p>size：</p>
<ul>
<li>最小（全满）100000&#x2F;186+100000&#x2F;186&#x2F;187+1</li>
<li>最大（半满）100000&#x2F;93+100000&#x2F;93&#x2F;94+1</li>
</ul>
</li>
</ul>
</li>
<li><p>Bottom-up B+ Tree Build</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610171021418.png" alt="image-20230610171021418"></li>
<li>fanout &#x3D; 4，则阶数为3</li>
<li>先排序，按序分块，然后向上构建</li>
<li>构建上图B+树 cost：1 seek + 9 block transfer</li>
<li>插入大量值&#x2F;合并树可以直接把叶子merge并排序，然后重建</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610171558671.png" alt="image-20230610171558671"></li>
<li>原树的叶子读取：1 seek+6 block transfer</li>
</ul>
</li>
<li><p>Indexing in Main Memory</p>
<ul>
<li>Random access in memory <ul>
<li>Much cheaper than on disk&#x2F;flash, but still expensive compared to cache read</li>
<li>Binary search for a key value within a large B+-tree node results in many <strong>cache misses</strong></li>
<li>Data structures that make best use of cache preferable – <strong>cache conscious</strong></li>
</ul>
</li>
<li>Cache miss<ul>
<li>HD以block为单位读到buffer，buffer以64byte(例)为单位读到cache，大节点就会读不全，查找索引值过程中读取的cache只有小部分有用，没找到-&gt;产生miss</li>
<li>降低miss：<ul>
<li>小节点：B+ trees with small nodes that fit in cache line are preferable to reduce cache misses</li>
<li>指针和search key分开排</li>
<li>建立一个“路标”（一棵小树）</li>
</ul>
</li>
</ul>
</li>
<li>Key idea:  <ul>
<li>use large node size to optimize disk access, </li>
<li>but structure data within a node using a tree with small node size, instead of using an array, to optimize cache access.</li>
</ul>
</li>
</ul>
</li>
<li><p>LSM tree(Log Structured Merge) 写优化的树结构</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610175401820.png" alt="image-20230610175401820"></li>
<li>Benefits of LSM approach<br>Inserts are done using only sequential I&#x2F;O operations 随机写-&gt;顺序写<br>Leaves are full, avoiding space wastage<br>Reduced number of I&#x2F;O operations per record inserted as compared to normal B+-tree (up to some size)</li>
<li>Drawback of LSM approach<br>Queries have to search multiple trees<br>Entire content of each level copied multiple times</li>
</ul>
</li>
<li><p>LSM-Stepped Merge Index</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610175540871.png" alt="image-20230610175540871"></li>
<li>内存满了直接写到下一层来，disk中这一层满了再merge写到下一层</li>
<li>删除：插入删除标记</li>
<li>更新：删除+插入</li>
</ul>
</li>
<li><p>Buffer Tree</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230619143817724.png" alt="image-20230619143817724"></li>
</ul>
</li>
<li><p>随堂测试</p>
<ul>
<li><p>1.Indexing mechanisms are used to speed up access  to desired data.</p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>2.Range query returns records with an attribute value falling in a specified range of values.</p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>3.Secondary index is an index whose search key specifies an order same as the sequential order of the file. </p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.NO</p>
<p>正确答案: B</p>
</li>
<li><p>4.In an dense index, index record appears for every search-key value in the file. </p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>5.In a B+-tree , all paths from root to leaf are of the same length.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>6.If the root of a B+-tree is not a leaf, it has at least 2 children.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes </p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>7.In databases, a node of a B+-tree is generally the same size as a disk block.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>8.The leaf nodes of a B+-tree file organization store records, instead of pointers to records.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>9.Benefits of LSM approach:</p>
<p> 多选题 (1 分)</p>
<p> A.Inserts are done using only sequential I&#x2F;O operations</p>
<p> B.Leave nodes are full, avoiding space wastage</p>
<p> C.Reduced number of I&#x2F;O operations per record inserted as compared to normal B+-tree.</p>
<p> D.Queries have to search multiple trees</p>
<p> E.Entire content of each level copied multiple times</p>
<p>正确答案: A B C</p>
</li>
<li><p>10.Bitmap indices are useful for queries on multiple attributes,not particularly useful for single attribute queries.</p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B. No</p>
<p>正确答案: A</p>
</li>
</ul>
</li>
</ul>
<h2 id="Query-Processing"><a href="#Query-Processing" class="headerlink" title="Query Processing"></a>Query Processing</h2><ul>
<li><p>Basic Steps in Query Processing</p>
<ul>
<li>Parsing and translation<br>translate the query into its internal form.  This is then translated into relational algebra.<br>Parser checks syntax, verifies relations</li>
<li>Optimization<br>Amongst all equivalent evaluation plans choose the one with lowest cost. </li>
<li>Evaluation<br>The query-execution engine takes a query-evaluation plan, executes that plan, and returns the answers to the query.</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612001751736.png" alt="image-20230612001751736" style="zoom:33%;" /></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612003553870.png" alt="image-20230612003553870"></li>
<li>选择运算尽量先做（往下推）</li>
</ul>
</li>
<li><p>衡量Query</p>
<ul>
<li><p>$ t_s $：number of seek</p>
</li>
<li><p>$ t_t $：number of block transfer(read &amp; write)</p>
</li>
<li><p>Cost for b block transfers plus S seeks</p>
<p>b *  $ t_t $ + S * $ t_s $</p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612004605830.png" alt="image-20230612004605830"></p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612004618669.png" alt="image-20230612004618669"></p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612004920316.png" alt="image-20230612004920316"></p>
</li>
</ul>
</li>
<li><p>对select的条件进行排序：外部排序</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618161811420.png" alt="image-20230618161811420"></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618161824886.png" alt="image-20230618161824886"></li>
<li>性能：</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618161847075.png" alt="image-20230618161847075"></li>
<li>$ (b_r&#x2F;M) $ 为归并段数，$ log_{M-1}(b_r&#x2F;M) $ 为轮次，2br为每次的传输消耗，最后一次+br，如果要写回磁盘就+2br。</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618163335699.png" alt="image-20230618163335699"></li>
<li>外部排序（External Merge Sort） 中，给一个段run分配bb 块（而不是1块）作为缓冲，可以减少每轮合并（merge）的seek次数，但也可能增加merge的轮数。对于确定的关系大小br 和确定的内存块数M，理论上应该有一个最佳的bb取值，使得算法代价最小。</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618163544585.png" alt="image-20230618163544585"></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618164207925.png" alt="image-20230618164207925"></li>
</ul>
</li>
<li><p>Join Operation</p>
<ul>
<li><p>Nested-loop join</p>
<ul>
<li>两重循环</li>
<li>代价：<ul>
<li>nr * bs + br   block transfers</li>
<li>nr + br  seeks</li>
<li>nr是记录数，block中含有多个记录</li>
</ul>
</li>
</ul>
</li>
<li><p>Block nested-loop join</p>
<ul>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618164914151.png" alt="image-20230618164914151"></p>
</li>
<li><p>代价：</p>
<ul>
<li>Worst case estimate:  br * bs + br  block transfers + 2 * br  seeks<br>Each block in the inner relation s is read once for each block in the outer relation</li>
<li>Best case: br + bs block transfers + 2 seeks.（内存足够大，每个表只要进入内存一次）</li>
<li>小关系作为外关系更好</li>
</ul>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618165335108.png" alt="image-20230618165335108"></p>
</li>
<li><p>内存有M块的情况：留1块作为output的缓存，外关系给M-2块，内关系反正每次要seek，只给1块。</p>
</li>
</ul>
</li>
<li><p>Indexed nested-loop join</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618170934436.png" alt="image-20230618170934436"></li>
<li>多块就是br&#x2F;(M-2)</li>
<li>外关系小(nr小)的时候选这种方法</li>
</ul>
</li>
<li><p>Merge-join</p>
<ul>
<li>两个关系已经有序</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618205150053.png" alt="image-20230618205150053"></li>
</ul>
</li>
<li><p>Hash-join</p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230619142752872.png" alt="image-20230619142752872"></p>
</li>
</ul>
</li>
</ul>
<h1 id="Query-Optimization¶"><a href="#Query-Optimization¶" class="headerlink" title="Query Optimization¶"></a>Query Optimization<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#query-optimization">¶</a></h1><details class="abstract" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(0, 176, 255); border-image: initial; border-radius: 0.1rem; box-shadow: none; color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(0, 176, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Abstract</summary><ul style="box-sizing: border-box; margin-bottom: 0.6rem; margin-top: 1em; list-style-type: disc; padding: 0px; margin-left: 0.625em; display: flow-root; font-size: 0.75rem;"><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0px; margin-left: 1.25em;"></li></ul></details>

<h2 id="Introduction¶"><a href="#Introduction¶" class="headerlink" title="Introduction¶"></a>Introduction<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#introduction">¶</a></h2><ul>
<li>Steps in cost-based query optimization<ul>
<li>Generate logically equivalent expressions using equivalence rules</li>
<li>Annotate resultant expressions in alternative ways to get alternative query plans</li>
<li>Choose the cheapest plan based on estimated cost</li>
</ul>
</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202305241431386.png" alt="img"></p>
<p>Alternative ways of evaluating a given query</p>
<ul>
<li>Equivalent expressions<br>逻辑优化：关系代数表达式（尽量先做选择，投影）</li>
<li>Different algorithms for each operation<br>物理层面：每个算子选择不同的算法</li>
</ul>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305271116161.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305271119807.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin-bottom: 0.6rem;"></p></details>

<p>Estimation of plan cost based on:</p>
<ul>
<li><em>Statistical information about relations</em>. Examples: number of tuples, number of distinct values for an attribute</li>
<li><em>Statistics estimation for intermediate results</em>（Cardinality Estimation） to compute cost of complex expressions<br>估计中间结果的大小<br>现在有基于深度学习的估计方法</li>
<li><em>Cost formulae for algorithms</em>, computed using statistics</li>
</ul>
<p>关系数据库里可以用查看执行计划。</p>
<p><img src="http://cdn.hobbitqia.cc/202305271131380.png" alt="img"></p>
<h2 id="Generating-Equivalent-Expressions¶"><a href="#Generating-Equivalent-Expressions¶" class="headerlink" title="Generating Equivalent Expressions¶"></a>Generating Equivalent Expressions<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#generating-equivalent-expressions">¶</a></h2><p>Two relational algebra expressions are said to be <strong>equivalent</strong> if the two expressions generate the same set of tuples on every legal database instance<br>形式上不一样，但是结果（输出）是一样的，产生了相同的集合。</p>
<h3 id="Equivalence-Rules¶"><a href="#Equivalence-Rules¶" class="headerlink" title="Equivalence Rules¶"></a>Equivalence Rules<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#equivalence-rules">¶</a></h3><ul>
<li><p>selection</p>
<p><img src="http://cdn.hobbitqia.cc/202305271134503.png" alt="img"></p>
<ol>
<li>可以把算子拆分<br>如果某些属性有索引，那么可以先拆分，在索引 select 之后再执行其他算子，否则不如不拆分。</li>
<li>算子可交换<br>先执行有索引的算子。</li>
<li>投影的属性可以只保留最后一次的</li>
<li>选择算子可以和合并结合</li>
</ol>
</li>
<li><p>join</p>
<p><img src="http://cdn.hobbitqia.cc/202305271145166.png" alt="img"></p>
<p>自然连接是结合的（先连接中间结果小的）</p>
<p><img src="http://cdn.hobbitqia.cc/202305271200739.png" alt="img"></p>
<p>如果选择算子只和一个关系有关，那么我们可以先执行选择。（选择算子要早进行，推到叶子上）</p>
</li>
<li><p>projection</p>
<p><img src="http://cdn.hobbitqia.cc/202305271202229.png" alt="img"></p>
<p>同理投影也要早做。<br>如果连接要用到投影后不保留的属性，我们在第一次投影时要把连接用的属性也保留下来。</p>
</li>
<li><p>set operation</p>
<p><img src="http://cdn.hobbitqia.cc/202305271205746.png" alt="img"></p>
<p>这里的减法，减数关系就不用做选择了（减去多的总是没问题的）对交集也适用</p>
</li>
<li><p>other</p>
<p><img src="http://cdn.hobbitqia.cc/202305271209973.png" alt="img"></p>
</li>
</ul>
<h3 id="Enumeration-of-Equivalent-Expressions¶"><a href="#Enumeration-of-Equivalent-Expressions¶" class="headerlink" title="Enumeration of Equivalent Expressions¶"></a>Enumeration of Equivalent Expressions<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#enumeration-of-equivalent-expressions">¶</a></h3><ul>
<li>Repeat<ul>
<li>apply all applicable <em>equivalence rules</em> on every subexpression of every equivalent expression found so far</li>
<li>add newly generated expressions to the set of equivalent expressions</li>
</ul>
</li>
<li>Until no new equivalent expressions are generated above</li>
</ul>
<p>可以这样找到所有的等价表达式。</p>
<p>但是实际中我们基于一些经验规则进行启发式的优化</p>
<h2 id="Statistics-for-Cost-Estimation¶"><a href="#Statistics-for-Cost-Estimation¶" class="headerlink" title="Statistics for Cost Estimation¶"></a>Statistics for Cost Estimation<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#statistics-for-cost-estimation">¶</a></h2><p>代价估算需要统计信息</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618231747119.png" alt="image-20230618231747119"></li>
<li>Histograms</li>
</ul>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">attribute age of relation person</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305271221452.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin-bottom: 0.6rem;"></p></details>

<h3 id="Selection-Size-Estimation¶"><a href="#Selection-Size-Estimation¶" class="headerlink" title="Selection Size Estimation¶"></a>Selection Size Estimation<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#selection-size-estimation">¶</a></h3><p>中间结果</p>
<ul>
<li>��&#x3D;�(�)<em>σ**A</em>&#x3D;<em>v</em>(<em>r</em>)<br>��&#x2F;�(�,�)<em>n**r</em>​&#x2F;<em>V</em>(<em>A</em>,<em>r</em>) : number of records that will satisfy the selection.<br>这样的估算基于值是平均分布的<br>如果要找的是一个 key, 那么 size estimate&#x3D;1</li>
<li>��≤�(�)<em>σ**A</em>≤<em>v</em>(<em>r</em>)<ul>
<li>Let �<em>c</em> denote the estimated number of tuples satisfying the condition.</li>
<li>�&#x3D;0<em>c</em>&#x3D;0 if �&lt;min⁡(�,�)<em>v</em>&lt;min(<em>A</em>,<em>r</em>)<br>v 比属性 A 的最小值还要小</li>
<li>�&#x3D;��⋅�−min⁡(�,�)max⁡(�,�)−min⁡�(�,�)<em>c</em>&#x3D;<em>n**r</em>⋅max(<em>A</em>,<em>r</em>)−min<em>A</em>(<em>A</em>,<em>r</em>)<em>v</em>−min(<em>A</em>,<em>r</em>)</li>
<li>In absence of statistical information c is assumed to be ��&#x2F;2<em>n**r</em>&#x2F;2 (没有最大、最小统计信息时).</li>
</ul>
</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202305272301381.png" alt="img"></p>
<p>概率论。<br>注意这些公式的要求是条件是相互独立的。</p>
<h3 id="Joins¶"><a href="#Joins¶" class="headerlink" title="Joins¶"></a>Joins<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#joins">¶</a></h3><p>The Cartesian product �×�<em>r</em>×<em>s</em> contains ��⋅��<em>n**r</em>⋅<em>n**s</em> tuples; each tuple occupies ��+��<em>s**r</em>+<em>s**s</em> bytes.</p>
<ul>
<li><p>�∩�&#x3D;∅<em>R</em>∩<em>S</em>&#x3D;∅<br>没有公共属性，等价于 �×�<em>r</em>×<em>s</em></p>
</li>
<li><p>�∩�<em>R</em>∩<em>S</em> is a key for �<em>R</em>, then a tuple of �<em>s</em> will join with at most one tuple from �<em>r</em></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305272324702.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;"></p></details>
</li>
<li><p>If �∩�<em>R</em>∩<em>S</em> in S is a foreign key in S referencing R, then the number of tuples in �⋈�<em>r</em>⋈<em>s</em> &#x3D; the number of tuples in s.</p>
</li>
<li><p>If �∩�&#x3D;{�}<em>R</em>∩<em>S</em>&#x3D;{<em>A</em>} is not a key for R or S.<br>��∗���(�,�),��∗���(�,�)<em>n**r</em>​∗<em>V</em>(<em>A</em>,<em>s</em>)<em>n**s</em>​​,<em>n**s</em>​∗<em>V</em>(<em>A</em>,<em>r</em>)<em>n**r</em>​​.<br>以第二个为例子，站在 s 的角度，每一个 s 可以和这么多个元素连接。<br>通常我们取二者中的较小值。</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305272342760.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;"></p></details></li>
</ul>
<h3 id="Size-Estimation-for-Other-Operations¶"><a href="#Size-Estimation-for-Other-Operations¶" class="headerlink" title="Size Estimation for Other Operations¶"></a>Size Estimation for Other Operations<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#size-estimation-for-other-operations">¶</a></h3><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618231630105.png" alt="image-20230618231630105"></p>
<p><img src="http://cdn.hobbitqia.cc/202305272344670.png" alt="img"></p>
<p>外部连接 r, s 认为是 r s 自然连接的结果加上 r 的大小。</p>
<h3 id="Estimation-of-Number-of-Distinct-Values¶"><a href="#Estimation-of-Number-of-Distinct-Values¶" class="headerlink" title="Estimation of Number of Distinct Values¶"></a>Estimation of Number of Distinct Values<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#estimation-of-number-of-distinct-values">¶</a></h3><p>估算 V(A,r).</p>
<p>Selections ��(�)<em>σ**θ</em>(<em>r</em>), estimate �(�,��(�))<em>V</em>(<em>A</em>,<em>σ**θ</em>(<em>r</em>))</p>
<ul>
<li>If �<em>θ</em> forces A to take a specified value, �(�,��(�))&#x3D;1<em>V</em>(<em>A</em>,<em>σ**θ</em>(<em>r</em>))&#x3D;1<br>*<strong>e.g.*</strong>, A &#x3D; 3</li>
<li>If �<em>θ</em> forces A to take on one of a specified set of values: �(�,��(�))&#x3D;<em>V</em>(<em>A</em>,<em>σ**θ</em>(<em>r</em>))&#x3D; number of specified values<br>*<strong>e.g.*</strong>, (A &#x3D; 1 V A &#x3D; 3 V A &#x3D; 4)</li>
<li>If the selection condition �<em>θ</em> is of the form A op v, �(�,��(�))&#x3D;�(�,�)∗�<em>V</em>(<em>A</em>,<em>σ**θ</em>(<em>r</em>))&#x3D;<em>V</em>(<em>A</em>,<em>r</em>)∗<em>s</em><br>利用选择率 s 计算</li>
<li>In all the other cases, use approx1imate estimate:</li>
</ul>
<p>joins (r\bowtie s), estimate (V(A,r\bowtie s))</p>
<ul>
<li>If all attributes in A are from r, the estimated (V(A,r\bowtie s)&#x3D;\min(V(A,r), n_{r\bowtie s}))</li>
<li>If A contains attributes A1 from r and A2 from s, then estimated (V(A,r\bowtie s)&#x3D;\min(V(A1,r)*V(A2-A1,s), V(A1-A2,r)*V(A2,s), n_{r\bowtie s}))</li>
</ul>
<h2 id="Choice-of-Evaluation-Plans"><a href="#Choice-of-Evaluation-Plans" class="headerlink" title="Choice of Evaluation Plans"></a>Choice of Evaluation Plans</h2><p>Must consider the <em>interaction</em> of evaluation techniques when choosing evaluation plans</p>
<p>choosing the cheapest algorithm for each operation independently may not yield best overall algorithm<br>*<strong>e.g.*</strong> merge-join may be costlier than hash-join, but may provide a sorted output which reduces the cost for an outer level aggregation.<br>Mergejoin 代价高，但是有个好处是 join 后是有次序的，对上层操作有利。</p>
<p>如果要找最优的执行计划，可能需要很长时间。通常按照经验规则。<br>我们主要考虑连接操作的优化。</p>
<h3 id="Cost-Based-Join-Order-Selection¶"><a href="#Cost-Based-Join-Order-Selection¶" class="headerlink" title="Cost-Based Join-Order Selection¶"></a>Cost-Based Join-Order Selection<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#cost-based-join-order-selection">¶</a></h3><p>Consider finding the best join-order for (r_1\bowtie r_2\bowtie \ldots r_n).<br>There are ((2(n – 1))!&#x2F;(n – 1)!) different join orders for above expression.</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305281657110.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin-bottom: 0.6rem;"></p></details>

<p>Using dynamic programming, the least-cost join order for any subset of ({r_1, r_2, \ldots r_n}) is computed only once and stored for future use.</p>
<p>Join Order Optimization Algorithm</p>
<p><img src="http://cdn.hobbitqia.cc/202305281658817.png" alt="img"></p>
<p>先分解成两个小的集合 (S_1, S-S_1). 递归地细分。<br>递归到最底层就变为了对单个表的选择方法。</p>
<p><img src="http://cdn.hobbitqia.cc/202305281700752.png" alt="img"></p>
<h4 id="Left-Deep-Join-Trees"><a href="#Left-Deep-Join-Trees" class="headerlink" title="Left Deep Join Trees"></a>Left Deep Join Trees</h4><p>In left-deep join trees, the right-hand-side input for each join is a relation, not the result of an intermediate join.</p>
<p><img src="http://cdn.hobbitqia.cc/202305281703232.png" alt="img"></p>
<p>左边可以是中间结果，右边必须是一个关系。</p>
<h4 id="Cost-of-Optimization"><a href="#Cost-of-Optimization" class="headerlink" title="Cost of Optimization"></a>Cost of Optimization</h4><ul>
<li>With dynamic programming<ul>
<li>time complexity of optimization with bushy trees is (O(3^n)).</li>
<li>Space complexity is (O(2^n))</li>
</ul>
</li>
<li>left-deep join tree<ul>
<li>Time complexity of finding best join order is (O(n 2^n))</li>
<li>Space complexity remains at (O(2^n))</li>
</ul>
</li>
</ul>
<h3 id="Heuristic-Optimization"><a href="#Heuristic-Optimization" class="headerlink" title="Heuristic Optimization"></a>Heuristic Optimization</h3><p>Cost-based optimization is expensive.<br>可以用启发式优化</p>
<p>Heuristic optimization transforms the query-tree by using a set of rules that typically (but not in all cases) improve execution performance:</p>
<ul>
<li>Perform <em>selection</em> early (reduces the number of tuples)</li>
<li>Perform <em>projection</em> early (reduces the number of attributes)</li>
<li>Perform most restrictive selection and join operations (<strong>i.e</strong>. with smallest result size) before other similar operations.</li>
<li>Perform left-deep join order</li>
</ul>
<h2 id="Additional-Optimization-Techniques¶"><a href="#Additional-Optimization-Techniques¶" class="headerlink" title="Additional Optimization Techniques¶"></a>Additional Optimization Techniques<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#additional-optimization-techniques">¶</a></h2><h3 id="Nested-Subqueries¶"><a href="#Nested-Subqueries¶" class="headerlink" title="Nested Subqueries¶"></a>Nested Subqueries<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#nested-subqueries">¶</a></h3><p>Nested query example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select name from instructor </span><br><span class="line">where exists </span><br><span class="line">    (select * from teaches</span><br><span class="line">    where instructor.ID = teaches.ID and teaches.year = 2022)</span><br></pre></td></tr></table></figure>

<p>找出 2022 开课的老师的名字。</p>
<p>两重循环，但是低效。</p>
<p>Parameters are variables from outer level query that are used in the nested subquery; such variables are called <strong>correlation variables（相关变量）</strong><br>即来自外循环的变量。如果没有相关变量，我们可以先执行内部，然后再执行外部。</p>
<p>把刚刚那个例子改为一个 select 语句，那么一个老师如果开了很多门课就会出现很多个名字。但是加上 <code>distinct</code> 关键词后又无法区分同名情况。</p>
<p>半连接 (⋉)_\theta s$，检验 r 是否满足某个关系。<br>If a tuple (r_i) appears n times in r, it appears n times in the result of (r (⋉)_\theta s) , if there is at least one tuple (s_i) in s matching with (r_i).</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305281827907.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin-bottom: 0.6rem;"></p></details>

<p><img src="http://cdn.hobbitqia.cc/202305281827478.png" alt="img"></p>
<p>The process of replacing a nested query by a query with a join&#x2F;semijoin (possibly with a temporary relation) is called <strong>decorrelation(去除相关)</strong></p>
<p>Decorrelation of scalar aggregate subqueries can be done using groupby&#x2F;aggregation in some cases</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305281832208.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin-bottom: 0.6rem;"></p></details>

<h3 id="Materialized-Views¶"><a href="#Materialized-Views¶" class="headerlink" title="Materialized Views¶"></a>Materialized Views<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db12/#materialized-views">¶</a></h3><p>A <strong>materialized view</strong> is a view whose contents are computed and stored.</p>
<p>有些数据库里把 view 实例化了，真正存储在内部的临时表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view department_total_salary(dept_name, total_salary) </span><br><span class="line">as select dept_name, sum(salary) from instructor group by dept_name</span><br></pre></td></tr></table></figure>

<p>Saves the effort of finding multiple tuples and adding up their amounts.<br>但是需要时刻保持这个视图和原表一致。</p>
<p>use <strong>incremental view maintenance(增量视图维护)</strong><br>The changes (inserts and deletes) to a relation or expressions are referred to as its <strong>differential(差分)</strong></p>
<ul>
<li><p>join: (V^{new}&#x3D;V^{old}\cup (i_r\bowtie s), V^{new} &#x3D; V^{old}-(d_r\bowtie s))</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">join</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305281840366.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;"></p></details>
</li>
<li><p>select: (V^{new}&#x3D;V^{old}\cup \sigma_\theta(i_r), V^{new} &#x3D; V^{old}-\sigma_\theta(d_r))</p>
</li>
<li><p>projection:<br>For each tuple in a projection (\Pi_A(r)), we will keep a count of how many times it was derived.</p>
<ul>
<li>On <em>insert</em> of a tuple to r, if the resultant tuple is already in (\Pi_A(r)) we increment its count, else we add a new tuple with count &#x3D; 1</li>
<li>On <em>delete</em> of a tuple from r, we decrement the count of the corresponding tuple in (\Pi_A(r)) if the count becomes 0, we delete the tuple from (\Pi_A(r))</li>
</ul>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Projection</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305281847247.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;"></p></details>
</li>
<li><p>count (v&#x3D; <em>Ag</em>{count(B)})</p>
<ul>
<li>insert: For each tuple r in (i_r), if the corresponding group is already present in v, we increment its count, else we add a new tuple with count &#x3D; 1</li>
<li>delete: for each tuple t in (i_r).we look for the group t.A in v, and subtract 1 from the count for the group.<br>If the count becomes 0, we delete from v the tuple for the group t.A</li>
</ul>
</li>
<li><p>sum (v&#x3D; <em>Ag</em>{sum(B)})</p>
</li>
<li><p>min, max</p>
</li>
</ul>
<p>怎么利用这些 view?</p>
<ul>
<li><p>Rewriting queries to use materialized views:</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305281849252.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;"></p></details>
</li>
<li><p>Replacing a use of a materialized view by the view definition</p>
</li>
</ul>
<p>Materialized View Selection<br>有哪些查询？各种查询的比例？</p>
<h1 id="Transactions¶"><a href="#Transactions¶" class="headerlink" title="Transactions¶"></a>Transactions<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#transactions">¶</a></h1><details class="abstract" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(0, 176, 255); border-image: initial; border-radius: 0.1rem; box-shadow: none; color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(0, 176, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Abstract</summary><ul style="box-sizing: border-box; margin-bottom: 0.6rem; margin-top: 1em; list-style-type: disc; padding: 0px; margin-left: 0.625em; display: flow-root; font-size: 0.75rem;"><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0px; margin-left: 1.25em;"></li></ul></details>

<h2 id="Transaction-Concept¶"><a href="#Transaction-Concept¶" class="headerlink" title="Transaction Concept¶"></a>Transaction Concept<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#transaction-concept">¶</a></h2><p>A <strong>transaction</strong> is a unit of program execution that accesses and possibly updates various data items.<br>一段原子性的操作</p>
<p>*<strong>e.g.*</strong> transaction to transfer $50 from account A to account B</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update  account  set  balance=balance-50  where account_number=A;</span><br><span class="line">update  account  set  balance=balance+50  where account_number=B;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>



<h3 id="ACID-Properties¶"><a href="#ACID-Properties¶" class="headerlink" title="ACID Properties¶"></a>ACID Properties<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#acid-properties">¶</a></h3><ul>
<li><strong>Atomicity（原子性）</strong><br>全有或全无<br>由数据库恢复功能保证</li>
<li><strong>Consistency（一致性）</strong><br>保证数据库内的内容正确性，与实际业务相符。如转账是一个人余额减少一个人增加。<br>consistency 与开发人员有关系（事务设计是否合理）</li>
<li><strong>Isolation（隔离性）</strong><br>事务并发执行，但是相互隔离，好像是串行执行一样。<br>由数据库的并发执行来实现</li>
<li><strong>Durability（持久性）</strong><br>事务提交后被缓存，掉电不能失去 buffer 里的内容。</li>
</ul>
<h2 id="A-Simple-Transaction-Model¶"><a href="#A-Simple-Transaction-Model¶" class="headerlink" title="A Simple Transaction Model¶"></a>A Simple Transaction Model<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#a-simple-transaction-model">¶</a></h2><p>这个模型中，把事务对数据库的修改简化为读写两种操作。<br>Transactions access data using two operations:</p>
<ul>
<li><strong>read(X)</strong>, which transfers the data item X from the database to a variable, also called X， in a work area in main memory belonging to the transaction that executed the read operation.</li>
<li><strong>write(X)</strong>, which transfers the value in the variable X in the main memory work area of the transaction that executed the write operation to the datat item X in database.</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202305291009580.png" alt="img"></p>
<p>在这个简单的模型中，我们不考虑数据读到工作区域后发生了什么操作，只考虑读写。</p>
<p>Example of Fund Transfer</p>
<p><img src="http://cdn.hobbitqia.cc/202305291012763.png" alt="img"></p>
<ul>
<li>Atomicity requirement<br>如果执行结束之后出现了问题，数据库应该要撤销之前的操作</li>
<li>Durability requirement<br>如果事务结束了，我们就把更新同步</li>
<li>Consistency requirement<ul>
<li>Explicitly（显式） specified integrity constraints *<strong>e.g.*</strong> primary keys , foreign keys<br>数据库把这个定义放在内部，会自己维护</li>
<li>Implicit （隐式） integrity constraints *<strong>e.g.*</strong> sum of balances of all accounts minus sum of loan amounts must equal value of cash-in-hand</li>
</ul>
</li>
<li>Isolation requirement<br>在 step 3 6 之间，另一个事务可以访问这个被部分更新的数据库，A+B 会小于正确答案。这是因为破坏了隔离性。</li>
</ul>
<h3 id="Transaction-State¶"><a href="#Transaction-State¶" class="headerlink" title="Transaction State¶"></a>Transaction State<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#transaction-state">¶</a></h3><ul>
<li><p><strong>Active</strong> – the initial state; the transaction stays in this state while it is executing</p>
</li>
<li><p><strong>Partially committed</strong> – after the final statement has been executed.<br>语句执行完了，准备提交。能否提交取决于具体的执行。</p>
</li>
<li><p><strong>Failed</strong> – after the discovery that normal execution can no longer proceed.<br>不能正常提交。或者是执行过程中发现问题。</p>
</li>
<li><p>Aborted</p>
<p>– after the transaction has been rolled back and the database restored to its state prior to the start of the transaction. Two options after it has been aborted:</p>
<ul>
<li>restart the transaction</li>
<li>kill the transaction</li>
</ul>
</li>
<li><p><strong>Committed</strong> – after successful completion.</p>
</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202305291018652.png" alt="img"></p>
<h2 id="Concurrent-Executions¶"><a href="#Concurrent-Executions¶" class="headerlink" title="Concurrent Executions¶"></a>Concurrent Executions<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#concurrent-executions">¶</a></h2><ul>
<li>increased processor and disk utilization</li>
<li>reduced average response time</li>
</ul>
<p>事务是并发执行的，如果不加以控制可能会有以下问题<br>Anomalies in Concurrent Executions</p>
<ul>
<li><p><strong>Lost Update（丢失修改）</strong></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Lost Update Example</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305291021774.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;">一个人订票后，另一个人读到这里第一个人还没有修改的余量。导致丢失了一次修改。</p></details>
</li>
<li><p><strong>Dirty Read（读脏数据）</strong></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Dirty Read</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305291023857.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;">一个人订票后，另一个人读数据后，但是第一个人放弃了，但是第二个人仍然是用的脏数据。</p></details>
</li>
<li><p><strong>Unrepeatable Read （不可重复读）</strong></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Unrepeatable Read</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305291023857.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;">Isolation 要求我们读到的数据应该是一样的。</p></details>
</li>
<li><p><strong>Phantom Problem（幽灵问题）</strong></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: var(--md-admonition-fg-color); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Phantom Problem</summary><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305291026595.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin: 0.5em 0px;"></p><p style="box-sizing: border-box; margin: 0.5em 0px 0.6rem;">unrepeatable 是针对已经存在的数据，但是数据的值不同. Phantom 是指数据数量会变多/减少。</p></details></li>
</ul>
<h3 id="Schedules¶"><a href="#Schedules¶" class="headerlink" title="Schedules¶"></a>Schedules<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#schedules">¶</a></h3><p><strong>Schedule</strong> – a sequences of instructions that specify the chronological order in which instructions of concurrent transactions are executed.<br>事务的执顺序，可以是交叉执行。</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Schedule Example</summary><ul style="box-sizing: border-box; margin-bottom: 0.6rem; margin-top: 1em; list-style-type: disc; padding: 0px; margin-left: 0.625em; display: flow-root;"><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"><p style="box-sizing: inherit; margin: 0.5em 0px;">串行调度<br style="box-sizing: inherit;">串行调度一定是满足隔离性的</p><div align="center" style="box-sizing: inherit;"><img src="http://cdn.hobbitqia.cc/202305291040618.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: inherit; margin: 0.5em 0px;"></p></li><li style="box-sizing: inherit; margin-bottom: 0px; margin-left: 1.25em;"><p style="box-sizing: inherit; margin: 0.5em 0px;">非串行调度，但等价于上面的串行调度</p><div align="center" style="box-sizing: inherit;"><img src="http://cdn.hobbitqia.cc/202305291040457.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: inherit; margin: 0.5em 0px;"></p><p style="box-sizing: inherit; margin: 0.5em 0px;">这里 T2 的 readA 和 T1 的 readB 可以调换时间次序，就得到了刚刚的串行调度。<br style="box-sizing: inherit;">下面这样的调度就不等价，破坏了隔离性。</p><div align="center" style="box-sizing: inherit;"><img src="http://cdn.hobbitqia.cc/202305291051997.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: inherit; margin: 0.5em 0px;"></p></li></ul></details>

<h3 id="Serializability¶"><a href="#Serializability¶" class="headerlink" title="Serializability¶"></a>Serializability<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#serializability">¶</a></h3><p>A (possibly concurrent) schedule is <strong>serializable</strong> if it is equivalent to a serial schedule.</p>
<ul>
<li>conflict serializability(冲突可串行化)</li>
<li>view serializability(视图可串行化)</li>
</ul>
<p>串行调度一定是可串行化的，交错执行不一定。</p>
<h4 id="Conflict-Serializability¶"><a href="#Conflict-Serializability¶" class="headerlink" title="Conflict Serializability¶"></a>Conflict Serializability<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#conflict-serializability">¶</a></h4><p><img src="http://cdn.hobbitqia.cc/202305291058741.png" alt="img"></p>
<p>注意这里针对的是同一个数据项 Q.</p>
<p>a conflict between ��<em>l**i</em> and ��<em>l**j</em> forces a (logical) temporal order between them.</p>
<p>If a schedule S can be transformed into a schedule S´ by a series of swaps of non-conflicting instructions, we say that S and S´ are <strong>conflict equivalent</strong>.<br>交换不冲突的指令，得到的是冲突等价的调度。<br>We say that a schedule S is <strong>conflict serializable</strong> if it is conflict equivalent to a serial schedule.<br>冲突等价于一个串行调度，那么这个调度是可串行的。</p>
<h4 id="Testing-for-Serializability¶"><a href="#Testing-for-Serializability¶" class="headerlink" title="Testing for Serializability¶"></a>Testing for Serializability<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#testing-for-serializability">¶</a></h4><p>Consider some schedule of a set of transactions �1,�2,…,��<em>T</em>1,<em>T</em>2,…,<em>T**n</em><br><strong>Precedence graph（前驱图）</strong> — a directed graph where the vertices are the transactions (names).</p>
<p>如果 T1 要在 T2 前面（即找到一条 T1 的指令要求比 T2 中的一条指令先执行），那我们画一条从 T1-&gt;T2 的边。<br>如果找到环，说明是不可串行化的。否则可以利用拓扑排序。</p>
<p>Example</p>
<p><img src="http://cdn.hobbitqia.cc/202305291105161.png" alt="img"></p>
<p>T1 的 readY 和 T2 的 writeY 冲突，所以要画一条边，如此。<br>最后有 10 种调度方式。</p>
<p>只用于理论研究，数据库内不会这样实现。</p>
<h4 id="View-Serializability¶"><a href="#View-Serializability¶" class="headerlink" title="View Serializability¶"></a>View Serializability<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#view-serializability">¶</a></h4><p>Example</p>
<p><img src="http://cdn.hobbitqia.cc/202305291112088.png" alt="img"></p>
<p>初始值由同一个事务读到。中间结果是由同一个事务得到再由另一个事务读出。最终写回数据库也是由同一个事务写。</p>
<p><img src="http://cdn.hobbitqia.cc/202305291115680.png" alt="img"></p>
<p>A schedule S is <strong>view serializable</strong> if it is view equivalent to a serial schedule. <strong>Every conflict serializable schedule is also view serializable.</strong><br>Below is a schedule which is view-serializable but not conflict serializable.<br>冲突可串行化的都是视图可串行化的，反之不一定。</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202305291117308.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box;"></p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">等价于 T27-28-29. (都是 27 读初值，中间没有其他读，最后是 29 写)</p></details>

<h4 id="Other-Notions-of-Serializability¶"><a href="#Other-Notions-of-Serializability¶" class="headerlink" title="Other Notions of Serializability¶"></a>Other Notions of Serializability<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#other-notions-of-serializability">¶</a></h4><p>有的调度既不是冲突可串行化又不是视图可串行化，但它是可串行化的。</p>
<p>Example</p>
<p><img src="http://cdn.hobbitqia.cc/202305291122839.png" alt="img"></p>
<p>等价于 T1-T5.<br>加减操作是可结合的，这里需要了解事务里具体是什么操作。但我们的简单模型对此不加以区分。</p>
<h2 id="Recoverable-Schedules¶"><a href="#Recoverable-Schedules¶" class="headerlink" title="Recoverable Schedules¶"></a>Recoverable Schedules<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#recoverable-schedules">¶</a></h2><p><strong>Recoverable schedule(可恢复调度)</strong> — if a transaction ��<em>T**j</em> reads a data item previously written by a transaction ��<em>T**i</em> , then the commit operation of ��<em>T**i</em> appears before the commit operation of ��<em>T**j</em>.</p>
<p>Example</p>
<p>The following schedule (Schedule 11) is not recoverable if T9 commits immediately after the read.<br>可能会读脏数据</p>
<p><img src="http://cdn.hobbitqia.cc/202305291126165.png" alt="img"></p>
<p>如果 T8 后续回滚, 但 T9 已经基于脏数据做了后续操作，而且已经提交了，不可恢复。</p>
<p>如果一个事务读了另一个事务的脏数据，提交次序需要有约束，要在被读事务的后面提交。</p>
<h3 id="Cascading-Rollbacks¶"><a href="#Cascading-Rollbacks¶" class="headerlink" title="Cascading Rollbacks¶"></a>Cascading Rollbacks<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#cascading-rollbacks">¶</a></h3><p><strong>Cascading rollback</strong> – a single transaction failure leads to a series of transaction rollbacks. Consider the following schedule where none of the transactions has yet committed (so the schedule is recoverable)</p>
<p>Example</p>
<p>If T10 fails, T11 and T12 must also be rolled back.</p>
<p><img src="http://cdn.hobbitqia.cc/202305291130425.png" alt="img"></p>
<p>要有级联回滚的恢复。<br>Can lead to the undoing of a significant amount of work.<br>我们更希望用非级联的恢复，否则开销太大。</p>
<h2 id="Transaction-Isolation-Levels¶"><a href="#Transaction-Isolation-Levels¶" class="headerlink" title="Transaction Isolation Levels¶"></a>Transaction Isolation Levels<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#transaction-isolation-levels">¶</a></h2><p>A database must provide a mechanism that will ensure that all possible schedules are</p>
<ul>
<li>either <em>conflict or view serializable</em>, and<br>保证可串行的</li>
<li>are <em>recoverable</em> and preferably cascadeless<br>保证可恢复的（最好是非级联）</li>
</ul>
<p>数据库里提供一种协议，每个事务要遵从协议，遵从协议下产生的调度一定是可串行、可恢复的。<br>这是完全的隔离，代价比较高。</p>
<p>In SQL <code>set transaction isolation level serializable</code> 我们可以设置数据库的隔离级别。</p>
<ul>
<li><strong>Serializable</strong> — default<br>四种问题都要避免，代价最高。</li>
<li><strong>Repeatable read</strong> — only committed records to be read, repeated reads of same record must return same value. However, a transaction may not be serializable – it may find some records inserted by a transaction but not find others.<br>不管幽灵问题。</li>
<li><strong>Read committed</strong> — only committed records can be read, but successive reads of record may return different (but committed) values.<br>保证不读脏数据。</li>
<li><strong>Read uncommitted</strong> — even uncommitted records may be read.<br>最低的隔离级别，有些数据库只是做统计任务。</li>
</ul>
<p>Lower degrees of consistency useful for gathering approximate information about the database</p>
<h2 id="Concurrency-Control-Protocols¶"><a href="#Concurrency-Control-Protocols¶" class="headerlink" title="Concurrency Control Protocols¶"></a>Concurrency Control Protocols<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db13/#concurrency-control-protocols">¶</a></h2><ul>
<li>Lock-Based Protocols<ul>
<li>Lock on whole database vs lock on items<br>读之前要访问一个共享锁，写之前要访问一个排他锁，冲突了就要等待。通过锁就规定了一个执行的次序。</li>
<li>How long to hold lock?</li>
<li>Shared vs exclusive locks</li>
</ul>
</li>
<li>Timestamp-Based Protocols<ul>
<li>Transaction timestamp assigned <em><strong>e.g.</strong></em> when a transaction begins<br>事务执行时分配一个时间戳。执行次序按照时间戳排序。</li>
<li>Data items store two timestamps<ul>
<li>Read timestamp</li>
<li>Write timestamp</li>
</ul>
</li>
<li>Timestamps are used to detect out of order accesses</li>
</ul>
</li>
<li>Validation-Based Protocols<ul>
<li>Optimistic concurrency control</li>
<li>Low rate of conflicts among transactions</li>
<li>Each transaction must go through 3 phases:<br>Read phase -&gt; Validation phase -&gt; Write phase<br>事务提交的时候先去验证是否有冲突，如果没有冲突就提交，如果冲突就考虑放弃某个。</li>
</ul>
</li>
</ul>
<h1 id="Concurrency-Control¶"><a href="#Concurrency-Control¶" class="headerlink" title="Concurrency Control¶"></a>Concurrency Control<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#concurrency-control">¶</a></h1><details class="abstract" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(0, 176, 255); border-image: initial; border-radius: 0.1rem; box-shadow: none; color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(0, 176, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Abstract</summary><ul style="box-sizing: border-box; margin-bottom: 0.6rem; margin-top: 1em; list-style-type: disc; padding: 0px; margin-left: 0.625em; display: flow-root; font-size: 0.75rem;"><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;"></li><li style="box-sizing: inherit; margin-bottom: 0px; margin-left: 1.25em;"></li></ul></details>

<h2 id="Lock-Based-Protocols¶"><a href="#Lock-Based-Protocols¶" class="headerlink" title="Lock-Based Protocols¶"></a>Lock-Based Protocols<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#lock-based-protocols">¶</a></h2><p>A lock is a mechanism to control concurrent access to a data item</p>
<ul>
<li>*<strong>exclusive(X)*</strong><br>Data item can be both read as well as written. X-lock is requested using <strong>lock-X</strong> instruction.</li>
<li>*<strong>shared(X)*</strong><br>Data item can only be read. S-lock is requested using <strong>lock-S</strong> instruction.</li>
</ul>
<p>要写一个数据，先申请获得 X 锁；要读一个数据，先申请获得 S 锁。<br>访问结束后释放这个锁。</p>
<p>访问数据之前必须获得对应的锁，否则需要等待。</p>
<h3 id="The-Two-Phase-Locking-Protocol¶"><a href="#The-Two-Phase-Locking-Protocol¶" class="headerlink" title="The Two-Phase Locking Protocol¶"></a>The Two-Phase Locking Protocol<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#the-two-phase-locking-protocol">¶</a></h3><p>事务的加锁和减锁分为两个阶段。</p>
<ul>
<li>Phase 1: Growing Phase (增长阶段)<ul>
<li>transaction may obtain locks</li>
<li>transaction may not release locks</li>
</ul>
</li>
<li>Phase 2: Shrinking Phase(缩减阶段)<ul>
<li>transaction may release locks</li>
<li>transaction may not obtain locks<br>一个事务一旦开始释放锁，就不能再加锁了。</li>
</ul>
</li>
</ul>
<p>事务两个阶段的分界线(lock point), 即获得了最后一个锁（完成获得这个动作）的时间点。<br>这样每个事务都有一个 lock point, 按照这个时间排序即可得到串行化的执行顺序。</p>
<p><img src="http://cdn.hobbitqia.cc/202306022302642.png" alt="img"></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306022304628.png" width="35%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin-bottom: 0.6rem;"></p></details>

<p><strong>Two-Phase Locking Protocol assures serializability.</strong></p>
<p>It can be proved that the transactions can be serialized in the order of their lock points.<br>可以按 lock points 串行化，但不是只能按照这么串行化。</p>
<p>上面基本的两阶段封锁协议无法保证事务的可恢复性。</p>
<p>Extensions to basic two-phase locking（基本两阶段封锁） needed to ensure recoverability of freedom from cascading roll-back</p>
<ul>
<li><strong>Strict two-phase locking（严格两阶段封锁）</strong>: a transaction must hold all its exclusive locks till it commits&#x2F;aborts.<br>Ensures recoverability and avoids cascading roll-backs.<br>S 锁可以用完就放，但 X 锁必须到提交的时候才能释放（这样别人就不能访问了，无法读脏数据）。代价是降低并发度。</li>
<li><strong>Rigorous two-phase locking（强两阶段封锁）</strong>: a transaction must hold all locks till commit&#x2F;abort.<br>Transactions can be serialized in the order in which they commit.</li>
</ul>
<p><strong>Two-phase locking is not a necessary condition for serializability.</strong></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306051019848.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306051024853.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box;"></p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">这里放锁了之后还获得锁了，违背了两阶段封锁协议。<br style="box-sizing: inherit;">所以不遵从两阶段封锁协议，也可以获得冲突可串行的调度。</p></details>

<h3 id="2PL-Proof¶"><a href="#2PL-Proof¶" class="headerlink" title="2PL - Proof¶"></a>2PL - Proof<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#2pl-proof">¶</a></h3><ul>
<li>Proof by Contradiction<br>如果有 Ti-&gt;Tj 的有向边，那 Ti 的 lockpoint 一定小于 Tj.<br>Ti-&gt;Tj 肯定有一个冲突的访问（对同一个数据）那 Tj 在获得锁的时候 Ti 已经放锁了，得证。</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202306051006510.png" alt="img"></p>
<ul>
<li>Proof by Induction<br>只需证明: Lock point 最小的事务，可以无障碍地交换到调度最前。<br>假如有事务拦住他了，证明这是不可能发生的。（与 lockpoint 最小矛盾）</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202306051009473.png" alt="img"></p>
<h3 id="Lock-Conversions¶"><a href="#Lock-Conversions¶" class="headerlink" title="Lock Conversions¶"></a>Lock Conversions<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#lock-conversions">¶</a></h3><p>通常是先读后修改。但我们不能先得 S 锁再释放后得 X 锁（违背了两阶段协议），也不能直接用 X 锁（降低并发度）。</p>
<p>Two-phase locking with lock conversions:</p>
<ul>
<li>First Phase:<ul>
<li>can acquire a lock-S or lock-X on a data item</li>
<li>can convert a lock-S to a lock-X (<em>lock-upgrade</em>)</li>
</ul>
</li>
<li>Second Phase:<ul>
<li>can release a lock-S or lock-X</li>
<li>can convert a lock-X to a lock-S (<em>lock-downgrade</em>)</li>
</ul>
</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202306051028924.png" alt="img"></p>
<p><strong>This protocol assures serializability.</strong></p>
<p>申请哪个锁是由数据库内部管理决定，不是由程序员显示调用。（自动加锁）</p>
<p><img src="http://cdn.hobbitqia.cc/202306051030757.png" alt="img"></p>
<p>如果已经有锁了，直接读；否则申请读锁。</p>
<h2 id="Implementation-of-Locking¶"><a href="#Implementation-of-Locking¶" class="headerlink" title="Implementation of Locking¶"></a>Implementation of Locking<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#implementation-of-locking">¶</a></h2><p>A <strong>lock manager</strong> can be implemented as a separate process to which transactions send lock and unlock requests.</p>
<h3 id="Lock-Table¶"><a href="#Lock-Table¶" class="headerlink" title="Lock Table¶"></a>Lock Table<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#lock-table">¶</a></h3><p>Lock table records granted locks and waiting requests.</p>
<p><img src="http://cdn.hobbitqia.cc/202306051035648.png" alt="img"></p>
<p>每个记录的 id 可以放进哈希表。<br>如这里记录 123, T1、T8 获得了 S 锁，但 T2 在等待获得 X 锁。</p>
<p>T1: lock-X(D) 通过 D 的 id 找到哈希表上的项，在对应项上增加。根据是否相容决定是获得锁还是等待。<br>unlock 类似，先找到对应的数据，拿掉对应的项。同时看后续的项是否可以获得锁。</p>
<p>如果一个事务 commit, 需要放掉所有的锁，我们需要去找。因此我们还需要一个事务的表，标明每个事务所用的锁。</p>
<h3 id="Deadlock-Handling¶"><a href="#Deadlock-Handling¶" class="headerlink" title="Deadlock Handling¶"></a>Deadlock Handling<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#deadlock-handling">¶</a></h3><p>System is <strong>deadlocked</strong> if there is a set of transactions such that every transaction in the set is waiting for another transaction in the set.</p>
<p><strong>Two-phase locking does not ensure freedom from deadlocks.</strong></p>
<p><img src="http://cdn.hobbitqia.cc/202306051043773.png" alt="img"></p>
<p>Deadlock prevention protocols ensure that the system will never enter into a deadlock state. Some prevention strategies:</p>
<ul>
<li><p>Require that each transaction locks all its data items before it begins execution (predeclaration).<br>执行前一次性获得所有锁。</p>
</li>
<li><p><strong>Impose partial ordering</strong> of all data items and require that a transaction can lock data items only in the order specified by the partial order (graph-based protocol).<br>对数据访问规定一种次序。比如规定必须先拿咖啡再拿咖啡伴侣。<br>*<strong>e.g.*</strong> T1: A-50, B+50. T2: B-10, A+10. 我们可以把第二个事务调换顺序，变为 A+10, B-10. 这样按照 partial order 能降低死锁概率。</p>
</li>
<li><p>Timeout-Based Schemes</p>
<p>:</p>
<ul>
<li><em>a transaction waits for a lock only for a specified amount of time</em>. After that, the wait times out and the transaction is rolled back.<br>等待一会，如果还是等不到就放弃。</li>
<li>thus deadlocks are not possible.</li>
<li>simple to implement; but starvation is possible. Also difficult to determine good value of the timeout interval.<br>时长不好规定。但可能有事务老是申请不到自己的锁。</li>
</ul>
</li>
</ul>
<h3 id="Deadlock-Detection¶"><a href="#Deadlock-Detection¶" class="headerlink" title="Deadlock Detection¶"></a>Deadlock Detection<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#deadlock-detection">¶</a></h3><p>定期检查数据库内是否有死锁，如果有就选择一个事务将其回滚。</p>
<p><strong>wait-for graph</strong></p>
<p><img src="http://cdn.hobbitqia.cc/202306051109304.png" alt="img"></p>
<p>这里的箭头表示在等待锁。如 T17-&gt;T18 表示 T17 在等待 T18 的锁。<br>如果形成了环，就说明出现了死锁。</p>
<p>通过刚刚的 Lock Table, 我们可以得到等待关系。（后面的 waited 等待前面的 granted）</p>
<p>When deadlock is detected :</p>
<ul>
<li>Some transaction will have to rolled back (made a <strong>victim</strong>) to break deadlock. Select that transaction as victim that will incur minimum cost.</li>
<li>Rollback – determine how far to roll back transaction<ul>
<li>Total rollback: Abort the transaction and then restart it.</li>
<li>More effective to roll back transaction only as far as necessary to break deadlock. Starvation happens if same transaction is always chosen as victim. Include the number of rollbacks in the cost factor to avoid starvation</li>
</ul>
</li>
</ul>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306051115479.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box;"></p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">T1 等 T2, T2 等 T6, T6 等 T1.(注意这里 T5 是等待 T6 而不是 T2)</p></details>

<h3 id="Graph-Based-Protocols¶"><a href="#Graph-Based-Protocols¶" class="headerlink" title="Graph-Based Protocols¶"></a>Graph-Based Protocols<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#graph-based-protocols">¶</a></h3><p>假设我们知道数据是按偏序访问的，可以有更高级的协议。<br>数据按照某种偏序关系访问。</p>
<p><img src="http://cdn.hobbitqia.cc/202306051121990.png" alt="img"></p>
<p>The *<strong>tree-protocol*</strong> is a simple kind of graph protocol.</p>
<ul>
<li><strong>Only exclusive locks</strong> are allowed.<br>只有这种锁。</li>
<li>The first lock by Ti may be on any data item. Subsequently, a data Q can be locked by Ti only if the parent of Q is currently locked by Ti.<br>第一个锁可以放任意地方，后面的锁只能在父节点锁住时才能往下锁。</li>
<li>Data items may be unlocked at any time.</li>
<li>A data item that has been locked and unlocked by Ti cannot subsequently be relocked by Ti<br>放了之后不能再加锁了。</li>
</ul>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306062011016.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box;"></p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">比如这里我们先锁 D, 随后锁 G, 放掉, 锁 H, 这时 D 已经没用了可以放掉。随后我们锁 J, H 也就没用了也可以放掉。最后放掉 J.</p></details>

<p><strong>The tree protocol ensures conflict serializability as well as freedom from deadlock.</strong></p>
<ul>
<li><p>Advantages</p>
<ul>
<li>Unlocking may occur earlier in the tree-locking protocol than in the two-phase locking protocol.<br>shorter waiting times, and increase in concurrency<br>锁可以更早释放，不用等待第二阶段。用完就可以放，提高了并发度。</li>
<li>protocol is <strong>deadlock-free</strong><br>no rollbacks are required</li>
</ul>
</li>
<li><p>Disadvantages</p>
<ul>
<li><p>Protocol does <em>not guarantee recoverability</em> or cascade freedom<br>Need to introduce commit dependencies to ensure recoverability<br>早放锁，意味着可能会读脏数据，不可恢复。这就对 commit 顺序有要求。</p>
</li>
<li><p>Transactions may have to</p>
<p>lock more data items</p>
<p>than needed.</p>
<ul>
<li>increased locking overhead, and additional waiting time<br>比如刚刚的图中，我们访问 G, J, 需要从 D 开始访问。会锁上更多数据。</li>
<li>potential decrease in concurrency</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Multiple-Granularity¶"><a href="#Multiple-Granularity¶" class="headerlink" title="Multiple Granularity¶"></a>Multiple Granularity<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#multiple-granularity">¶</a></h2><p>可以锁在记录上(如 <code>update table set ...;</code>)，也可以锁在整个表上(如 <code>select * from table;</code>)。</p>
<p>Granularity of locking (level in tree where locking is done):</p>
<ul>
<li><strong>fine granularity（细粒度）</strong> (lower in tree): high concurrency, high locking overhead</li>
<li><strong>coarse granularity（粗粒度）</strong> (higher in tree): low locking overhead, low concurrency</li>
</ul>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example of Granularity Hierarchy</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306051140017.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box;"></p><p style="box-sizing: border-box;">The levels, starting from the coarsest (top) level are</p><ul style="box-sizing: border-box; margin-bottom: 0.6rem; margin-top: 1em; list-style-type: disc; padding: 0px; margin-left: 0.625em; display: flow-root;"><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;">database</li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;">area</li><li style="box-sizing: inherit; margin-bottom: 0.5em; margin-left: 1.25em;">File(table)</li><li style="box-sizing: inherit; margin-bottom: 0px; margin-left: 1.25em;">record</li></ul></details>

<h3 id="Intention-Lock-Modes¶"><a href="#Intention-Lock-Modes¶" class="headerlink" title="Intention Lock Modes¶"></a>Intention Lock Modes<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#intention-lock-modes">¶</a></h3><p>记录和表上都可以加 S&#x2F;X 锁。但是当事务涉及到多个粒度，如何判断是否冲突，如一个表的 S 锁和一个记录的 X 锁是冲突的。<br>我们引入了其他锁，意向锁(IS, IX, SIX)</p>
<ul>
<li>如果一个事务要给一个记录加 S 锁，那也要在表上加 IS 锁。（意向共享锁）</li>
<li>如果一个事务要给一个记录加 X 锁，那也要在表上加 IX 锁。（意向排他锁）</li>
<li>SIX 锁是 S 和 IX 锁的结合。要读整个表，但可能对其中某些记录进行修改。（共享意向排他）</li>
</ul>
<p>这样当我们想向一个表上 S 锁时，发现表上有 IX 锁，这样我们很快就发现了冲突，需要等待。<br>IS 和 IX 是不冲突的。在表上是不冲突的，可能在记录上冲突（即对一个记录又读又写，冲突发生在记录层面而非表）。</p>
<p><img src="http://cdn.hobbitqia.cc/202306062026763.png" alt="img"></p>
<ul>
<li><strong>intention-shared (IS)</strong>: indicates explicit locking at a lower level of the tree but only with shared locks.<br>在下面会加 S 锁。</li>
<li><strong>intention-exclusive (IX)</strong>: indicates explicit locking at a lower level with exclusive or shared locks<br>在下面会加 X 锁。</li>
<li><strong>shared and intention-exclusive (SIX)</strong>: the subtree rooted by that node is locked explicitly in shared mode and explicit locking is being done at a lower level with exclusive-mode locks.</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202306062033999.png" alt="img"></p>
<p>要符合相容矩阵。从最粗的粒度开始访问。要加锁的时候注意，对父亲的锁有要求。</p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306062035862.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box;"></p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">加锁是从上往下，放锁是从下往上。<br style="box-sizing: inherit;">先对 DB 加 IX, 对 A1 加 IX, 对 Fa 加 SIX, 对某些记录加 X. 其他记录就不用再加 S 锁了(因为表是 SIX).</p></details>

<h2 id="Insert-and-Delete-Operations¶"><a href="#Insert-and-Delete-Operations¶" class="headerlink" title="Insert and Delete Operations¶"></a>Insert and Delete Operations<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#insert-and-delete-operations">¶</a></h2><p>数据库里除了 R&#x2F;W 还有插入、删除等操作。<br>需要定义 R&#x2F;W 和插入&#x2F;删除是否冲突。</p>
<p>If two-phase locking is used :</p>
<ul>
<li>A delete operation may be performed only if the transaction deleting the tuple has an exclusive lock on the tuple to be deleted.<br>删除前需要加 X 锁。</li>
<li>A transaction that inserts a new tuple into the database is given an X-mode lock on the tuple<br>插入之前是没有这个数据的，无法先加锁。应该插入之后马上加上 X 锁。</li>
</ul>
<p>Insertions and deletions can lead to the <em>phantom phenomenon</em>.<br>因此只是加锁不能保证串行化。</p>
<h3 id="Index-Locking-Protocol¶"><a href="#Index-Locking-Protocol¶" class="headerlink" title="Index Locking Protocol¶"></a>Index Locking Protocol<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#index-locking-protocol">¶</a></h3><p>其实插入&#x2F;删除操作隐含地修改了信息，只是没有被表示出来。我们可以这个信息显示化，加锁。<br>如果表上有索引，我们在扫描索引的时候会在叶子修改，我们在这里进行检测。</p>
<p><img src="http://cdn.hobbitqia.cc/202306062047538.png" alt="img"></p>
<details class="example" open="" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: var(--md-shadow-z1); color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-top-left-radius: 0.1rem; border-top-right-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Index Locking on a B+ -Tree</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306062051214.png" width="50%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box;"></p><p style="box-sizing: border-box; margin-bottom: 0.6rem;">先在叶子页加锁，再在记录上加锁。<br style="box-sizing: inherit;">如果我们要插入，比如 18. 这时插入到了 10 这页，发现这页被锁住了，无法插入，这样就确保了这个范围内无法被插入，不会有幽灵问题。</p></details>

<p>也可以使用谓词锁。把这个位置锁上（比如刚刚 11 到 50 这个区间），后续如果要插入 18 落入这个区间，我们就能检查出来。但这样实现是比较复杂的。</p>
<h3 id="Next-Key-Locking-To-Prevent-Phantoms¶"><a href="#Next-Key-Locking-To-Prevent-Phantoms¶" class="headerlink" title="Next-Key Locking To Prevent Phantoms¶"></a>Next-Key Locking To Prevent Phantoms<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db14/#next-key-locking-to-prevent-phantoms">¶</a></h3><p>刚刚的例子中, 10 不在范围内，但我们把这页都锁住了，仍然插不进去，影响了并发度。</p>
<p>Next-key locking protocol: provides higher concurrency</p>
<ul>
<li>Lock all values that satisfy index lookup (match lookup value, or fall in lookup range)</li>
<li>Also lock next key value in index<br>even for inserts&#x2F;deletes</li>
<li>Lock mode: S for lookups, X for insert&#x2F;delete&#x2F;update</li>
</ul>
<p>Next-Key Locking</p>
<p><img src="http://cdn.hobbitqia.cc/202306062100918.png" alt="img"></p>
<p>查询 7 到 16, 我们把索引项锁起来，把下一个索引值 18 也锁起来。插入的时候要申请这个锁和比插入值大的下一个值的锁，这里插入 15 时就要申请 15 和 18 的锁，冲突无法插入。插入 7 同理。</p>
<h1 id="Recovery-System¶"><a href="#Recovery-System¶" class="headerlink" title="Recovery System¶"></a>Recovery System<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#recovery-system">¶</a></h1><h2 id="Failure-Classification¶"><a href="#Failure-Classification¶" class="headerlink" title="Failure Classification¶"></a>Failure Classification<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#failure-classification">¶</a></h2><p><img src="http://cdn.hobbitqia.cc/202306121002428.png" alt="img"></p>
<ul>
<li>Database application<br>逻辑错误：比如不满足数据库约束条件（主键） 系统错误：死锁。 常用方法是撤销 undo, 把这个事件抹掉。（基于日志，在产生修改之前先记日志，故障后可以根据日志进行撤销）<br>记日志比较快（顺序访问）</li>
<li>DBMS<br>掉电、硬件故障、软件故障<br>system crash 是全局性的，所有运行的程序都会受到影响。分为两类：一类是事务已经提交（但是数据还在缓冲区），另一类是正在执行的事务（还没有提交）。<br>已经提交的事务要 redo(数据可能没写回去), 没有完成的事务要 undo. 先记日志，现在的数据库采用 repeating history 的方法。</li>
<li>Database<br>介质故障<br>要防止介质故障，需要做备份（拷贝或者远程）</li>
</ul>
<h2 id="Storage-Structure¶"><a href="#Storage-Structure¶" class="headerlink" title="Storage Structure¶"></a>Storage Structure<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#storage-structure">¶</a></h2><p>日志可能也会出故障？我们假设日志存储在 Stable storage 里。</p>
<ul>
<li>Volatile storage</li>
<li>Nonvolatile storage<br>survives system crashes</li>
<li>Stable storage:<ul>
<li>a mythical(虚拟的) form of storage that survives all failures</li>
<li>approximated by maintaining multiple copies on distinct nonvolatile media<br>可以近似实现</li>
</ul>
</li>
</ul>
<h3 id="Implementation¶"><a href="#Implementation¶" class="headerlink" title="Implementation¶"></a>Implementation<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#implementation">¶</a></h3><ul>
<li>Maintain multiple copies of each block on separate disks</li>
<li>Failure during data transfer can still result in inconsistent copies<br>修改过程中可能发生故障</li>
<li>Protecting storage media from failure during data transfer</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202306121013745.png" alt="img"></p>
<h3 id="Database-Recovery¶"><a href="#Database-Recovery¶" class="headerlink" title="Database Recovery¶"></a>Database Recovery<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#database-recovery">¶</a></h3><p><strong>Recovery algorithms</strong> are techniques to ensure database consistency and transaction <strong>atomicity</strong> and <strong>durability</strong> despite failures.</p>
<p>Recovery algorithms have two parts</p>
<ul>
<li>Actions taken during normal transaction processing to ensure enough information exists to recover from failures<br>先记日志</li>
<li>Actions taken after a failure to recover the database contents to a state that ensures atomicity, consistency and durability</li>
</ul>
<p>理想的算法：恢复得很快，对事务正常操作没有影响（记录信息的时候不能消耗太多性能），即兼顾上面两个部分。恢复的过程和并行控制是相关的。</p>
<p>We assume that strict two-phase locking ensures no dirty read.<br>使用严格两阶段封锁协议保证没有脏数据。</p>
<p><strong>Idempotent(幂等性)</strong>: An recovery algorithm is said to be idempotent if executing it several times gives the same result as executing it once.<br>算法恢复多次的效果是一样的。（恢复过程中可能也发生 crash）</p>
<h2 id="Log-Based-Recovery¶"><a href="#Log-Based-Recovery¶" class="headerlink" title="Log-Based Recovery¶"></a>Log-Based Recovery<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#log-based-recovery">¶</a></h2><h3 id="Log-Records¶"><a href="#Log-Records¶" class="headerlink" title="Log Records¶"></a>Log Records<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#log-records">¶</a></h3><p><img src="http://cdn.hobbitqia.cc/202306121021188.png" alt="img"></p>
<p>A <strong>log</strong> is kept on stable storage(稳定存储器).<br>The log is a sequence of <strong>log records</strong>, and maintains a record of update activities on the database.</p>
<ul>
<li>When transaction Ti starts, it registers itself by writing a <strong>“start”</strong> log record: &lt;�� �����&gt;&lt;*T**i* *s**t**a**r**t*&gt;<br>事务开始. Ti 表示事务的 id.</li>
<li>Before Ti executes write(X), writing <strong>“update</strong>” log record &lt;��,�,�1,�2&gt;&lt;*T**i*,*X*,*V*1,*V*2&gt;<br>事务把 X 数据项的值从 V1(old value) 改为 V2(new value).<br>这个就是恢复的基础. undo 就用 old value, redo 用 new value.<br>Insert 就是 old 为空, Delete 就是 new 为空。</li>
<li>When Ti finishes it last statement, writing <strong>“commit”</strong> log record: &lt;�� ������&gt;&lt;*T**i* *co**mmi**t*&gt;</li>
<li>When Ti complete rollback, writing <strong>“abort”</strong> log record: &lt;�� �����&gt;&lt;*T**i* *ab**or**t*&gt;</li>
</ul>
<p>Log Example</p>
<p><img src="http://cdn.hobbitqia.cc/202306121024663.png" alt="img"></p>
<p>这里当执行到 T2 回滚的时候我们会进行恢复（绿色的行表示补偿日志）比如 T2 把 C 恢复为 500, T3 把 B 恢复为 300, 最后 T2 abort. (undo 操作也会记录到日志中)<br>发生 crash 的时候 repeat history(undo 正常的操作也会重复), 随后得到并执行 undo list.(事务开始后先把事务放进去，如果提交或者回滚了就把事务移除) 只需要把 T4 undo.(假设故障前只执行到 15 行)</p>
<h3 id="Write-Ahead-Logging¶"><a href="#Write-Ahead-Logging¶" class="headerlink" title="Write-Ahead Logging¶"></a>Write-Ahead Logging<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#write-ahead-logging">¶</a></h3><p>Before a data in main memory is output to the database, the log records pertaining to data must have been output to stable storage.<br>先写日志原则。<br>数据修改之前，和数据有关的记录要先写入日志。</p>
<h3 id="Transaction-Commit¶"><a href="#Transaction-Commit¶" class="headerlink" title="Transaction Commit¶"></a>Transaction Commit<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#transaction-commit">¶</a></h3><p>A transaction is said to have committed when its <em>commit log record</em> is output to <em>stable storage</em><br>日志已经记录 commit, 说明事务已经提交。（因为后续可以根据这个恢复状态了）<br>但此时数据不一定已经写回到数据库里（不一定高校）<br>all previous log records of the transaction must have been output already</p>
<p>Writes performed by a transaction may still be in the buffer when the transaction commits, and may be output later.<br>不一定在磁盘。如果立刻将 block 写回磁盘可能引起大量 I&#x2F;O 操作</p>
<h3 id="Undo-撤销-and-Redo（重做）-Operations¶"><a href="#Undo-撤销-and-Redo（重做）-Operations¶" class="headerlink" title="Undo(撤销) and Redo（重做） Operations¶"></a>Undo(撤销) and Redo（重做） Operations<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#undo-and-redo-operations">¶</a></h3><h3 id="Checkpoints¶"><a href="#Checkpoints¶" class="headerlink" title="Checkpoints¶"></a>Checkpoints<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#checkpoints">¶</a></h3><p>Redoing&#x2F;undoing all transactions recorded in the log can be very slow.<br>Streamline recovery procedure by periodically performing checkpointing.<br>重演历史可能很长。checkpoint 是确认之前的操作都已经反映到数据库里去了，这样重演的时候就可以直接从 checkpoint 开始。</p>
<ul>
<li>Output all log records currently residing in main memory onto stable storage.<br>日志不是生成就往内存写，而是有一个日志缓冲区。<br>确保把日志项写到日志中去了。</li>
<li>Output all modified buffer blocks to the disk.<br>把 buffer 里所有数据都刷写一遍。</li>
<li>Write a log record &lt;�ℎ�������� �&gt;&lt;*c**h**ec**k**p**o**in**t* *L*&gt; onto stable storage where L is a list of all transactions active at the time of checkpoint.<br>写一个日志的标记（新的日志类型）. L 是当前正在工作的事务的表。（用来做 undo list 的初始化列表）</li>
<li>All updates are stopped while doing checkpointing!!! 做 checkpoint 的时候其他活跃事务都要停下来。</li>
</ul>
<p>Log File with Checkpoint : Example</p>
<p><img src="http://cdn.hobbitqia.cc/202306121846448.png" alt="img"></p>
<p>重演历史从最近的 checkpoint 重演. {T2 T4} 作为 undo list 的初始化值。</p>
<p>checkpoint 之间的间隔应该如何确定？<br>根据日志量。</p>
<details class="example" style="box-sizing: inherit; display: flow-root; overflow: visible; padding: 0px 0.6rem; background-color: var(--md-admonition-bg-color); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgb(124, 77, 255); border-image: initial; border-radius: 0.1rem; box-shadow: none; color: rgba(0, 0, 0, 0.87); font-size: 0.64rem; margin: 1.5625em 0px; break-inside: avoid; font-family: &quot;LXGW WenKai Screen&quot;, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="box-sizing: border-box; cursor: pointer; display: block; min-height: 1rem; background-color: rgba(124, 77, 255, 0.1); border-width: 0px 0px 0px 0.2rem; border-style: solid; border-color: rgba(0, 63, 136, 0); border-image: initial; font-weight: 700; margin: 0px -0.6rem 0px -0.8rem; padding: 0.4rem 0.6rem 0.4rem 2.2rem; position: relative; border-radius: 0.1rem; -webkit-tap-highlight-color: transparent; outline: none;">Example of Recovery</summary><p style="box-sizing: border-box;"></p><div align="center" style="box-sizing: border-box;"><img src="http://cdn.hobbitqia.cc/202306121858750.png" width="60%/" style="box-sizing: inherit; border-style: none; height: auto; max-width: 100%;"></div><p style="box-sizing: border-box; margin-bottom: 0.6rem;"></p></details>

<h3 id="Log-Record-Buffering¶"><a href="#Log-Record-Buffering¶" class="headerlink" title="Log Record Buffering¶"></a>Log Record Buffering<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#log-record-buffering">¶</a></h3><p><img src="http://cdn.hobbitqia.cc/202306121859013.png" alt="img"></p>
<p>我们在把数据 buffer 中的块写到数据库时，要先把块对应的日志先写到日志文件（直接把日志全部刷写一遍）。<br>事务提交之后有一个对日志的强制刷写。</p>
<p><strong>Group commit</strong>: several log records can be output using a single output operation, reducing the I&#x2F;O cost. commit 可能在日志里等待一段时间, 等到 buffer 里有足够多的日志记录再写出去。</p>
<ul>
<li>The recovery algorithm supports the <strong>no-force policy(非强制)</strong>: <strong>i.e.</strong>, updated blocks need not be written to disk when transaction commits.<br>好的恢复算法：我事务 commit 了但不强制日志刷写出去。</li>
<li>The recovery algorithm supports the <strong>steal policy(窃取策略)</strong>:<strong>i.e.</strong>, blocks containing updates of uncommitted transactions can be written to disk, even before the transaction commits. 事务提交之前脏数据能不能被写到磁盘里去？（同样地需要先把日志写出去）</li>
</ul>
<h3 id="Fuzzy-Checkpointing¶"><a href="#Fuzzy-Checkpointing¶" class="headerlink" title="Fuzzy Checkpointing¶"></a>Fuzzy Checkpointing<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#fuzzy-checkpointing">¶</a></h3><p>Fuzzy 模糊</p>
<p>做 checkpoint 的时候我们如果要求其他活跃事务都停下来，一次性把脏数据都刷写出去，吞吐率会忽高忽低，系统的可用性就比较差。<br>记录脏数据，在后面不 check 的时候慢慢写。</p>
<ul>
<li>Temporarily stop all updates by transactions</li>
<li>Write a &lt;�ℎ�������� �&gt;&lt;*c**h**ec**k**p**o**in**t* *L*&gt; log record and force log to stable storage</li>
<li>Note list M of modified buffer blocks</li>
<li>Now permit transactions to proceed with their actions</li>
<li>Output to disk all modified buffer blocks in list M</li>
</ul>
<p><img src="http://cdn.hobbitqia.cc/202306121916858.png" alt="img"></p>
<p>在把所有脏数据都写回磁盘后，我们会认定这个 checkpoint. 有一个指针指向最近一次成功的 checkpoint.<br>这样 checkpoint 的时候就只需要记录一下，不用一下子写脏数据了。</p>
<h3 id="Failure-with-Loss-of-Nonvolatile-Storage¶"><a href="#Failure-with-Loss-of-Nonvolatile-Storage¶" class="headerlink" title="Failure with Loss of Nonvolatile Storage¶"></a>Failure with Loss of Nonvolatile Storage<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#failure-with-loss-of-nonvolatile-storage">¶</a></h3><p><img src="http://cdn.hobbitqia.cc/202306121918751.png" alt="img"></p>
<p>Can be extended to allow transactions to be active during dump; known as fuzzy dump or online dump.<br>类似于 checkpoint, 不是完全备份，而是记录一下，随后慢慢备份。</p>
<h2 id="Recovery-with-Early-Lock-Release-and-Logical-Undo-Operations¶"><a href="#Recovery-with-Early-Lock-Release-and-Logical-Undo-Operations¶" class="headerlink" title="Recovery with Early Lock Release and Logical Undo Operations¶"></a>Recovery with Early Lock Release and Logical Undo Operations<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#recovery-with-early-lock-release-and-logical-undo-operations">¶</a></h2><h3 id="Logical-Undo-Logging¶"><a href="#Logical-Undo-Logging¶" class="headerlink" title="Logical Undo Logging¶"></a>Logical Undo Logging<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#logical-undo-logging">¶</a></h3><p>如果早放锁，后续恢复为 old value 可能没有意义。比如存款 100, 转入 100. 那么我们恢复为 100(物理撤销) 就没有意义。这个时候应该采用逻辑撤销，即如果 <code>a+=100</code>, 恢复时就应该 <code>a-=100</code>.</p>
<p><img src="http://cdn.hobbitqia.cc/202306121925529.png" alt="img"></p>
<p>如 B+ 树的插入和删除操作。<br>我们需要对逻辑操作记日志。</p>
<p>Transaction Rollback with Logical Undo</p>
<p><img src="http://cdn.hobbitqia.cc/202306121928688.png" alt="img"></p>
<p>需要把每个操作的日志项记录下来（开始和结束）. C 表示自加操作。这里在 end 时会记录 logical undo 的操作(减法撤销对应加法)<br>注意我们是在 end 的时候记录逻辑撤销的方法，如果这个操作还没有结束，那么我们只能物理撤销。<br>这里我们早放锁了，没有遵循严格两阶段放锁协议。在 T0 还没有提交的时候 T1 就对数据进行了修改.<br>恢复中做的是物理撤销(old+new), begin&#x2F;end 这些日志就不需要记录了。</p>
<p>Failure Recovery with Logical Undo</p>
<p><img src="http://cdn.hobbitqia.cc/202306121935921.png" alt="img"></p>
<p>这里还没有 T2 end, 因此物理撤销。</p>
<h2 id="ARIES-Recovery-Algorithm¶"><a href="#ARIES-Recovery-Algorithm¶" class="headerlink" title="ARIES Recovery Algorithm¶"></a>ARIES Recovery Algorithm<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#aries-recovery-algorithm">¶</a></h2><p>ARIES is a state of the art recovery method.</p>
<p>每个日志都有一个日志编号 <strong>log sequence number (LSN)</strong><br>每个数据块里都会记一个 LSN, 表示这个块反应了最近哪个日志的操作。</p>
<h3 id="ARIES-Data-Structures¶"><a href="#ARIES-Data-Structures¶" class="headerlink" title="ARIES Data Structures¶"></a>ARIES Data Structures<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#aries-data-structures">¶</a></h3><ul>
<li><p>Log sequence number (LSN)</p>
<p>identifies each log record</p>
<ul>
<li>Must be sequentially increasing</li>
</ul>
</li>
<li><p><strong>Page LSN</strong><br>每个页(块的 LSN)</p>
</li>
<li><p><strong>Log records of several different types</strong></p>
</li>
<li><p><strong>Dirty page table</strong><br>脏页表要记录在日志中。</p>
</li>
</ul>
<p>Log Record</p>
<p><img src="http://cdn.hobbitqia.cc/202306121951678.png" alt="img"></p>
<p>日志记录通过 UndoNextLSN 串起来，提高恢复效率。</p>
<p>DirtyPage Table</p>
<ul>
<li>PageLSN of the page</li>
<li>RecLSN is an LSN such that log records before this LSN have already been applied to the page version on disk 每一页都有 PageLSN 和 RecLSN, Rec 反应的是最近的被反映到数据库的日志。</li>
</ul>
<p>ARIES Data Structures</p>
<p><img src="http://cdn.hobbitqia.cc/202306121955805.png" alt="img"></p>
<p>这里 4894.1 表示这个块里的第一个数据。 RecLSN 表示 7564 开始数据就没有反映到数据库中去了。</p>
<ul>
<li>Checkpoint log record<ul>
<li>Contains:<ul>
<li>DirtyPageTable and list of active transactions</li>
<li>For each active transaction, LastLSN, the LSN of the last log record written by the transaction<br>要记最近的事务项（从哪里开始恢复）</li>
</ul>
</li>
<li>Fixed position on disk notes LSN of last completed checkpoint log record</li>
</ul>
</li>
<li>Dirty pages are not written out at checkpoint time<br>Instead, they are flushed out continuously, in the background<br>脏页不会在 check 的时候写出去。</li>
<li>Checkpoint is thus very low overhead can be done frequently</li>
</ul>
<h3 id="ARIES-Recovery-Algorithm¶-1"><a href="#ARIES-Recovery-Algorithm¶-1" class="headerlink" title="ARIES Recovery Algorithm¶"></a>ARIES Recovery Algorithm<a target="_blank" rel="noopener" href="https://note.hobbitqia.cc/DB/db15/#aries-recovery-algorithm_1">¶</a></h3><ul>
<li>Analysis pass<ul>
<li>Which transactions to undo (undo-list)</li>
<li>Which pages were dirty (disk version not up to date) at time of crash<br>得到 dirty page table.</li>
<li>RedoLSN: LSN from which redo should start<br>真正的 redo 要从哪里开始(RecLSN 的最小值就是 redo 的起点)</li>
</ul>
</li>
<li>Redo pass<br>从 RedoLSN 开始重演<br><strong>RecLSN</strong> and <strong>PageLSNs</strong> are used to avoid redoing actions already reflected on page.<br>用来优化，有些日志不用 redo(没有意义)</li>
<li>Undo pass<br>把 undolist 进行撤销操作。</li>
</ul>
<p>Example</p>
<p><img src="http://cdn.hobbitqia.cc/202306122017889.png" alt="img"></p>
<p><img src="http://cdn.hobbitqia.cc/202306122025645.png" alt="img"></p>
<p>crash 之后，得到上页的 Dirty Page Table 和 Active TXN Table 以及磁盘里的日志。</p>
<p>Example</p>
<p><img src="http://cdn.hobbitqia.cc/202306122028882.png" alt="img"></p>
<p>要把 2390 加到表里去。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/DB%E5%90%8E%E7%AF%87/" data-id="clj2mxxkw0001wgu2feom1phh" data-title="DB后篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OOP补充" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/OOP%E8%A1%A5%E5%85%85/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/OOP%E8%A1%A5%E5%85%85/">oop补充</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C-文件和流"><a href="#C-文件和流" class="headerlink" title="C++ 文件和流"></a>C++ 文件和流</h1><p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p>
<p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ofstream</td>
<td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void open(const char *filename, ios::openmode mode);</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>
<table>
<thead>
<tr>
<th align="left">模式标志</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ios::app</td>
<td align="left">追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::ate</td>
<td align="left">文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::in</td>
<td align="left">打开文件用于读取。</td>
</tr>
<tr>
<td align="left">ios::out</td>
<td align="left">打开文件用于写入。</td>
</tr>
<tr>
<td align="left">ios::trunc</td>
<td align="left">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody></table>
<p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream  afile;</span><br><span class="line">afile.open(&quot;file.dat&quot;, ios::out | ios::in );</span><br></pre></td></tr></table></figure>

<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void close();</span><br></pre></td></tr></table></figure>

<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>
<h2 id="读取-amp-写入实例"><a href="#读取-amp-写入实例" class="headerlink" title="读取 &amp; 写入实例"></a>读取 &amp; 写入实例</h2><p>下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 以写模式打开文件</span></span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>; </span><br><span class="line">   cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.<span class="built_in">ignore</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 再次向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   outfile.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 以读模式打开文件</span></span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>); </span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 在屏幕上写入数据</span></span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 再次从文件读取数据，并显示它</span></span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   infile.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列输入和输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Writing to the file</span><br><span class="line">Enter your name: Zara</span><br><span class="line">Enter your age: 9</span><br><span class="line">Reading from the file</span><br><span class="line">Zara</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>
<h2 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::cur );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::end );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定位到 fileObject 的末尾</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( <span class="number">0</span>, ios::end );</span><br></pre></td></tr></table></figure>

<h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<p>以下是尝试除以零时抛出异常的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Division by zero condition!</span><br></pre></td></tr></table></figure>

<h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/05/exceptions_in_cpp.png" alt="C++ 异常的层次结构"></p>
<p>下表是对上面层次结构中出现的每个异常的说明：</p>
<table>
<thead>
<tr>
<th align="left">异常</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>std::exception</strong></td>
<td align="left">该异常是所有标准 C++ 异常的父类。</td>
</tr>
<tr>
<td align="left">std::bad_alloc</td>
<td align="left">该异常可以通过 <strong>new</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_cast</td>
<td align="left">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_typeid</td>
<td align="left">该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_exception</td>
<td align="left">这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td align="left"><strong>std::logic_error</strong></td>
<td align="left">理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td align="left">std::domain_error</td>
<td align="left">当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::invalid_argument</td>
<td align="left">当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::length_error</td>
<td align="left">当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::out_of_range</td>
<td align="left">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td>
</tr>
<tr>
<td align="left"><strong>std::runtime_error</strong></td>
<td align="left">理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td align="left">std::overflow_error</td>
<td align="left">当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::range_error</td>
<td align="left">当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::underflow_error</td>
<td align="left">当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody></table>
<h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将产生以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyException caught</span><br><span class="line">C++ Exception</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>
<p>异常规范声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ERROR</span>&#123;UnderFlow,OverFlow&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h1><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<p>每个容器都有一个单一的定义，比如 <strong>向量</strong>，我们可以定义许多不同类型的向量，比如 <strong>vector <int></strong> 或 **vector <string>**。</p>
<p>您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板函数定义的一般形式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; ret-type func-<span class="built_in">name</span>(parameter list) </span><br><span class="line">&#123;   </span><br><span class="line">	<span class="comment">// 函数的主体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p>
<p>下面是函数模板的实例，返回两个数中的最大值：</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(i, j) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class type&gt; class class-name &#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p>
<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</p>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123; </span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    vector&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;       <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个元素的副本 </span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">hello</span><br><span class="line">Exception: Stack&lt;&gt;::pop(): empty stack</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/OOP%E8%A1%A5%E5%85%85/" data-id="clj2mxxkz0004wgu27cnl06pu" data-title="oop补充" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-makedown学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/29/makedown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-05-28T16:00:00.000Z" itemprop="datePublished">2023-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/29/makedown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Makedown Node</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h1><h2 id="Subtitle"><a href="#Subtitle" class="headerlink" title="Subtitle"></a>Subtitle</h2><ul>
<li><p>字体：</p>
<ul>
<li><p><em>斜体</em>，<strong>粗体</strong>，<em><strong>粗斜体</strong></em></p>
</li>
<li><p><code>高光</code>，<del>删除线</del>，<u>下划线</u></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>插入：</p>
<ul>
<li><p>代码：</p>
<ul>
<li><p>段落插入：<code>print()</code></p>
</li>
<li><p>代码块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>公式：</p>
<ul>
<li><p>段落插入：$\mathbf{F}<em>n &#x3D; \mathbf{F}</em>{n-1}^2$</p>
</li>
<li><p>公式块：<br>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 &#x3D;  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p>
</li>
</ul>
</li>
<li><p>图片：</p>
</li>
</ul>
<blockquote>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/tz9gnswb.png" alt="洛谷图床" style="zoom: 50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网络：</span><br><span class="line">![洛谷图床](https://cdn.luogu.com.cn/upload/image_hosting/tz9gnswb.png)</span><br><span class="line">本地：</span><br><span class="line">![一果流汗](C:\Users\86133\Desktop\SMILE\一果流汗.jpg)</span><br><span class="line">缩放：</span><br><span class="line">&lt;img src=&quot;C:\Users\86133\Desktop\SMILE\一果流汗.jpg&quot; alt=&quot;一果流汗&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>链接：<ul>
<li><a target="_blank" rel="noopener" href="https://www.baidu.com/">Baidu</a></li>
</ul>
</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/29/makedown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cli983vbq0000pgu2b98e0q9x" data-title="Makedown Node" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-LaTeX数学公式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/29/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-05-28T16:00:00.000Z" itemprop="datePublished">2023-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/29/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">LaTeX Formula</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol>
<li>上标符号，符号：<code>^</code>，如：<img src="https://math.jianshu.com/math?formula=x%5E4" alt="x^4"></li>
<li>下标符号，符号：<code>_</code>，如：<img src="https://math.jianshu.com/math?formula=x_1" alt="x_1"></li>
<li>组合符号，符号：<code>&#123;&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7B16%7D_%7B8%7DO%7B2+%7D_%7B2%7D" alt="{16}_{8}O{2+}_{2}"></li>
</ol>
<h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol>
<li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=V_%7B%5Cmbox%7B%E5%88%9D%E5%A7%8B%7D%7D" alt="V_{\mbox{初始}}"></li>
<li>字体控制，符号：<code>\displaystyle</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cfrac%7Bx+y%7D%7By+z%7D" alt="\displaystyle \frac{x+y}{y+z}"></li>
<li>下划线符号，符号：<code>\underline</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cunderline%7Bx+y%7D" alt="\underline{x+y}"></li>
<li>标签，符号<code>\tag&#123;数字&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Ctag%7B11%7D" alt="\tag{11}"></li>
<li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Coverbrace%7Ba+b+c+d%7D%5E%7B2.0%7D" alt="\overbrace{a+b+c+d}^{2.0}"></li>
<li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=a+%5Cunderbrace%7Bb+c%7D_%7B1.0%7D+d" alt="a+\underbrace{b+c}_{1.0}+d"></li>
<li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D%5Cstackrel%7B%5Cmathrm%7Bdef%7D%7D%7B=%7D%7Bx_1,%5Cdots,x_n%7D" alt="\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}"></li>
</ol>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol>
<li>两个quad空格，符号：<code>\qquad</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cqquad%20y" alt="x \qquad y"></li>
<li>quad空格，符号：<code>\quad</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cquad%20y" alt="x \quad y"></li>
<li>大空格，符号<code>\</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5C%20y" alt="x \ y"></li>
<li>中空格，符号<code>\:</code>，如：<img src="https://math.jianshu.com/math?formula=x%20:%20y" alt="x : y"></li>
<li>小空格，符号<code>\,</code>，如：<img src="https://math.jianshu.com/math?formula=x%20,%20y" alt="x , y"></li>
<li>没有空格，符号&#96;&#96;，如：<img src="https://math.jianshu.com/math?formula=xy" alt="xy"></li>
<li>紧贴，符号<code>\!</code>，如：<img src="https://math.jianshu.com/math?formula=x%20!%20y" alt="x ! y"></li>
</ol>
<h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol>
<li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：<img src="https://math.jianshu.com/math?formula=%EF%BC%88%EF%BC%89%5Cbig(%5Cbig)%20%5CBig(%5CBig)%20%5Cbigg(%5Cbigg)%20%5CBigg(%5CBigg)" alt="（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)"></li>
<li>中括号，符号：<code>[]</code>，如：<img src="https://math.jianshu.com/math?formula=%5Bx+y%5D" alt="[x+y]"></li>
<li>大括号，符号：<code>\&#123; \&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7Bx+y%7D" alt="{x+y}"></li>
<li>自适应括号，符号：<code>\left \right</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cleft(x%5Cright)" alt="\left(x\right)">，<img src="https://math.jianshu.com/math?formula=%5Cleft(x%7Byz%7D%5Cright)" alt="\left(x{yz}\right)"></li>
<li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7Bn+1%20%5Cchoose%20k%7D=%7Bn%20%5Cchoose%20k%7D+%7Bn%20%5Cchoose%20k-1%7D" alt="{n+1 \choose k}={n \choose k}+{n \choose k-1}"></li>
<li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csum_%7Bk_0,k_1,%5Cldots%3E0%20%5Catop%20k_0+k_1+%5Ccdots=n%7DA_%7Bk_0%7DA_%7Bk_1%7D%5Ccdots" alt="\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots"></li>
</ol>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol>
<li>加法运算，符号：<code>+</code>，如：<img src="https://math.jianshu.com/math?formula=x+y=z" alt="x+y=z"></li>
<li>减法运算，符号：<code>-</code>，如：<img src="https://math.jianshu.com/math?formula=x-y=z" alt="x-y=z"></li>
<li>加减运算，符号：<code>\pm</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cpm%20y=z" alt="x \pm y=z"></li>
<li>减甲运算，符号：<code>\mp</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cmp%20y=z" alt="x \mp y=z"></li>
<li>乘法运算，符号：<code>\times</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ctimes%20y=z" alt="x \times y=z"></li>
<li>点乘运算，符号：<code>\cdot</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ccdot%20y=z" alt="x \cdot y=z"></li>
<li>星乘运算，符号：<code>\ast</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cast%20y=z" alt="x \ast y=z"></li>
<li>除法运算，符号：<code>\div</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cdiv%20y=z" alt="x \div y=z"></li>
<li>斜法运算，符号：<code>/</code>，如：<img src="https://math.jianshu.com/math?formula=x/y=z" alt="x/y=z"></li>
<li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cfrac%7Bx+y%7D%7By+z%7D" alt="\frac{x+y}{y+z}"></li>
<li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7Bx+y%7D%20%5Cover%20%7By+z%7D" alt="{x+y} \over {y+z}"></li>
<li>绝对值表示，符号：<code>||</code>，如：<img src="https://math.jianshu.com/math?formula=%7Cx+y%7C" alt="|x+y|"></li>
</ol>
<h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol>
<li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Coverline%7Bxyz%7D" alt="\overline{xyz}"></li>
<li>开二次方运算，符号：<code>\sqrt</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csqrt%20x" alt="\sqrt x"></li>
<li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csqrt%5B3%5D%7Bx+y%7D" alt="\sqrt[3]{x+y}"></li>
<li>对数运算，符号：<code>\log</code>，如：<img src="https://math.jianshu.com/math?formula=%5Clog(x)" alt="\log(x)"></li>
<li>极限运算，符号：<code>\lim</code>，如：<img src="https://math.jianshu.com/math?formula=%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>极限运算，符号：<code>\displaystyle \lim</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>求和运算，符号：<code>\sum</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>求和运算，符号：<code>\displaystyle \sum</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>积分运算，符号：<code>\int</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D" alt="\int^{\infty}_{0}{xdx}"></li>
<li>积分运算，符号：<code>\displaystyle \int</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D" alt="\displaystyle \int^{\infty}_{0}{xdx}"></li>
<li>微分运算，符号：<code>\partial</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20y%7D" alt="\frac{\partial x}{\partial y}"></li>
<li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%201%20&2%20&%5Ccdots%20&4%5C5%20&6%20&%5Ccdots%20&8%5C%5Cvdots%20&%5Cvdots%20&%5Cddots%20&%5Cvdots%5C13%20&14%20&%5Ccdots%20&16%5Cend%7Bmatrix%7D%20%5Cright%5D" alt="\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]"></li>
</ol>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol>
<li>等于运算，符号：<code>=</code>，如：<img src="https://math.jianshu.com/math?formula=x+y=z" alt="x+y=z"></li>
<li>大于运算，符号：<code>&gt;</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%3Ez" alt="x+y&gt;z"></li>
<li>小于运算，符号：<code>&lt;</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%3Cz" alt="x+y&lt;z"></li>
<li>大于等于运算，符号：<code>\geq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cgeq%20z" alt="x+y \geq z"></li>
<li>小于等于运算，符号：<code>\leq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cleq%20z" alt="x+y \leq z"></li>
<li>不等于运算，符号：<code>\neq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cneq%20z" alt="x+y \neq z"></li>
<li>不大于等于运算，符号：<code>\ngeq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cngeq%20z" alt="x+y \ngeq z"></li>
<li>不大于等于运算，符号：<code>\not\geq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cgeq%20z" alt="x+y \not\geq z"></li>
<li>不小于等于运算，符号：<code>\nleq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cnleq%20z" alt="x+y \nleq z"></li>
<li>不小于等于运算，符号：<code>\not\leq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cleq%20z" alt="x+y \not\leq z"></li>
<li>约等于运算，符号：<code>\approx</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Capprox%20z" alt="x+y \approx z"></li>
<li>恒定等于运算，符号：<code>\equiv</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cequiv%20z" alt="x+y \equiv z"></li>
</ol>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol>
<li>属于运算，符号：<code>\in</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cin%20y" alt="x \in y"></li>
<li>不属于运算，符号：<code>\notin</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnotin%20y" alt="x \notin y"></li>
<li>不属于运算，符号：<code>\not\in</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnot%5Cin%20y" alt="x \not\in y"></li>
<li>子集运算，符号：<code>\subset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csubset%20y" alt="x \subset y"></li>
<li>子集运算，符号：<code>\supset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csupset%20y" alt="x \supset y"></li>
<li>真子集运算，符号：<code>\subseteq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csubseteq%20y" alt="x \subseteq y"></li>
<li>非真子集运算，符号：<code>\subsetneq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csubsetneq%20y" alt="x \subsetneq y"></li>
<li>真子集运算，符号：<code>\supseteq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csupseteq%20y" alt="x \supseteq y"></li>
<li>非真子集运算，符号：<code>\supsetneq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csupsetneq%20y" alt="x \supsetneq y"></li>
<li>非子集运算，符号：<code>\not\subset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnot%5Csubset%20y" alt="x \not\subset y"></li>
<li>非子集运算，符号：<code>\not\supset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnot%5Csupset%20y" alt="x \not\supset y"></li>
<li>并集运算，符号：<code>\cup</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ccup%20y" alt="x \cup y"></li>
<li>交集运算，符号：<code>\cap</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ccap%20y" alt="x \cap y"></li>
<li>差集运算，符号：<code>\setminus</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csetminus%20y" alt="x \setminus y"></li>
<li>同或运算，符号：<code>\bigodot</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cbigodot%20y" alt="x \bigodot y"></li>
<li>同与运算，符号：<code>\bigotimes</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cbigotimes%20y" alt="x \bigotimes y"></li>
<li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li>
<li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li>
<li>空集，符号：<code>\emptyset</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cemptyset" alt="\emptyset"></li>
</ol>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol>
<li>无穷，符号：<code>\infty</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cinfty" alt="\infty"></li>
<li>虚数，符号：<code>\imath</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cimath" alt="\imath"></li>
<li>虚数，符号：<code>\jmath</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cjmath" alt="\jmath"></li>
<li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Chat%7Ba%7D" alt="\hat{a}"></li>
<li>数学符号，符号<code>\check&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Ccheck%7Ba%7D" alt="\check{a}"></li>
<li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cbreve%7Ba%7D" alt="\breve{a}"></li>
<li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Ctilde%7Ba%7D" alt="\tilde{a}"></li>
<li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cbar%7Ba%7D" alt="\bar{a}"></li>
<li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D" alt="\vec{a}"></li>
<li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cacute%7Ba%7D" alt="\acute{a}"></li>
<li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cgrave%7Ba%7D" alt="\grave{a}"></li>
<li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cmathring%7Ba%7D" alt="\mathring{a}"></li>
<li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdot%7Ba%7D" alt="\dot{a}"></li>
<li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cddot%7Ba%7D" alt="\ddot{a}"></li>
<li>上箭头，符号：<code>\uparrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cuparrow" alt="\uparrow"></li>
<li>上箭头，符号：<code>\Uparrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CUparrow" alt="\Uparrow"></li>
<li>下箭头，符号：<code>\downarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdownarrow" alt="\downarrow"></li>
<li>下箭头，符号：<code>\Downarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CDownarrow" alt="\Downarrow"></li>
<li>左箭头，符号：<code>\leftarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cleftarrow" alt="\leftarrow"></li>
<li>左箭头，符号：<code>\Leftarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CLeftarrow" alt="\Leftarrow"></li>
<li>右箭头，符号：<code>\rightarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Crightarrow" alt="\rightarrow"></li>
<li>右箭头，符号：<code>\Rightarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CRightarrow" alt="\Rightarrow"></li>
<li>底端对齐的省略号，符号：<code>\ldots</code>，如：<img src="https://math.jianshu.com/math?formula=1,2,%5Cldots,n" alt="1,2,\ldots,n"></li>
<li>中线对齐的省略号，符号：<code>\cdots</code>，如：<img src="https://math.jianshu.com/math?formula=x_1%5E2%20+%20x_2%5E2%20+%20%5Ccdots%20+%20x_n%5E2" alt="x_1^2 + x_2^2 + \cdots + x_n^2"></li>
<li>竖直对齐的省略号，符号：<code>\vdots</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cvdots" alt="\vdots"></li>
<li>斜对齐的省略号，符号：<code>\ddots</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cddots" alt="\ddots"></li>
</ol>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td><code>A</code></td>
<td>α</td>
<td><code>\alhpa</code></td>
</tr>
<tr>
<td>B</td>
<td><code>B</code></td>
<td>β</td>
<td><code>\beta</code></td>
</tr>
<tr>
<td>Γ</td>
<td><code>\Gamma</code></td>
<td>γ</td>
<td><code>\gamma</code></td>
</tr>
<tr>
<td>Δ</td>
<td><code>\Delta</code></td>
<td>δ</td>
<td><code>\delta</code></td>
</tr>
<tr>
<td>E</td>
<td><code>E</code></td>
<td>ϵ</td>
<td><code>\epsilon</code></td>
</tr>
<tr>
<td>Z</td>
<td><code>Z</code></td>
<td>ζ</td>
<td><code>\zeta</code></td>
</tr>
<tr>
<td>H</td>
<td><code>H</code></td>
<td>η</td>
<td><code>\eta</code></td>
</tr>
<tr>
<td>Θ</td>
<td><code>\Theta</code></td>
<td>θ</td>
<td><code>\theta</code></td>
</tr>
<tr>
<td>I</td>
<td><code>I</code></td>
<td>ι</td>
<td><code>\iota</code></td>
</tr>
<tr>
<td>K</td>
<td><code>K</code></td>
<td>κ</td>
<td><code>\kappa</code></td>
</tr>
<tr>
<td>Λ</td>
<td><code>\Lambda</code></td>
<td>λ</td>
<td><code>\lambda</code></td>
</tr>
<tr>
<td>M</td>
<td><code>M</code></td>
<td>μ</td>
<td><code>\mu</code></td>
</tr>
<tr>
<td>N</td>
<td><code>N</code></td>
<td>ν</td>
<td><code>\nu</code></td>
</tr>
<tr>
<td>Ξ</td>
<td><code>\Xi</code></td>
<td>ξ</td>
<td><code>\xi</code></td>
</tr>
<tr>
<td>O</td>
<td><code>O</code></td>
<td>ο</td>
<td><code>\omicron</code></td>
</tr>
<tr>
<td>Π</td>
<td><code>\Pi</code></td>
<td>π</td>
<td><code>\pi</code></td>
</tr>
<tr>
<td>P</td>
<td><code>P</code></td>
<td>ρ</td>
<td><code>\rho</code></td>
</tr>
<tr>
<td>Σ</td>
<td><code>\Sigma</code></td>
<td>σ</td>
<td><code>\sigma</code></td>
</tr>
<tr>
<td>T</td>
<td><code>T</code></td>
<td>τ</td>
<td><code>\tau</code></td>
</tr>
<tr>
<td>Υ</td>
<td><code>\Upsilon</code></td>
<td>υ</td>
<td><code>\upsilon</code></td>
</tr>
<tr>
<td>Φ</td>
<td><code>\Phi</code></td>
<td>ϕ</td>
<td><code>\phi</code></td>
</tr>
<tr>
<td>X</td>
<td><code>X</code></td>
<td>χ</td>
<td><code>\chi</code></td>
</tr>
<tr>
<td>Ψ</td>
<td><code>\Psi</code></td>
<td>ψ</td>
<td><code>\psi</code></td>
</tr>
<tr>
<td>Ω</td>
<td><code>\v</code></td>
<td>ω</td>
<td><code>\omega</code></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/29/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" data-id="cli9a4dnk0000qku20drg4sk4" data-title="LaTeX Formula" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/06/19/hello-world/" class="article-date">
  <time class="dt-published" datetime="2019-06-18T16:00:00.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/06/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/06/19/hello-world/" data-id="cli7ie9l70000nku2bek71fa2" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Study/" style="font-size: 10px;">Study</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/">认知神经科学导论笔记</a>
          </li>
        
          <li>
            <a href="/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/">C++ Project Norm</a>
          </li>
        
          <li>
            <a href="/2023/05/30/OOP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">OOP Note</a>
          </li>
        
          <li>
            <a href="/2023/05/30/DB%E5%90%8E%E7%AF%87/">DB后篇</a>
          </li>
        
          <li>
            <a href="/2023/05/30/OOP%E8%A1%A5%E5%85%85/">oop补充</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 LesterYu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>