<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Moyuke&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Moyuke&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Moyuke&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="LesterYu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Moyuke's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Moyuke&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-LaTeX数学公式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/29/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-06-28T16:00:00.000Z" itemprop="datePublished">2023-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/29/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">LaTeX Formula</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol>
<li>上标符号，符号：<code>^</code>，如：<img src="https://math.jianshu.com/math?formula=x%5E4" alt="x^4"></li>
<li>下标符号，符号：<code>_</code>，如：<img src="https://math.jianshu.com/math?formula=x_1" alt="x_1"></li>
<li>组合符号，符号：<code>&#123;&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7B16%7D_%7B8%7DO%7B2+%7D_%7B2%7D" alt="{16}_{8}O{2+}_{2}"></li>
</ol>
<h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol>
<li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=V_%7B%5Cmbox%7B%E5%88%9D%E5%A7%8B%7D%7D" alt="V_{\mbox{初始}}"></li>
<li>字体控制，符号：<code>\displaystyle</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cfrac%7Bx+y%7D%7By+z%7D" alt="\displaystyle \frac{x+y}{y+z}"></li>
<li>下划线符号，符号：<code>\underline</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cunderline%7Bx+y%7D" alt="\underline{x+y}"></li>
<li>标签，符号<code>\tag&#123;数字&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Ctag%7B11%7D" alt="\tag{11}"></li>
<li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Coverbrace%7Ba+b+c+d%7D%5E%7B2.0%7D" alt="\overbrace{a+b+c+d}^{2.0}"></li>
<li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=a+%5Cunderbrace%7Bb+c%7D_%7B1.0%7D+d" alt="a+\underbrace{b+c}_{1.0}+d"></li>
<li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cvec%7Bx%7D%5Cstackrel%7B%5Cmathrm%7Bdef%7D%7D%7B=%7D%7Bx_1,%5Cdots,x_n%7D" alt="\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}"></li>
</ol>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol>
<li>两个quad空格，符号：<code>\qquad</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cqquad%20y" alt="x \qquad y"></li>
<li>quad空格，符号：<code>\quad</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cquad%20y" alt="x \quad y"></li>
<li>大空格，符号<code>\</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5C%20y" alt="x \ y"></li>
<li>中空格，符号<code>\:</code>，如：<img src="https://math.jianshu.com/math?formula=x%20:%20y" alt="x : y"></li>
<li>小空格，符号<code>\,</code>，如：<img src="https://math.jianshu.com/math?formula=x%20,%20y" alt="x , y"></li>
<li>没有空格，符号&#96;&#96;，如：<img src="https://math.jianshu.com/math?formula=xy" alt="xy"></li>
<li>紧贴，符号<code>\!</code>，如：<img src="https://math.jianshu.com/math?formula=x%20!%20y" alt="x ! y"></li>
</ol>
<h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol>
<li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：<img src="https://math.jianshu.com/math?formula=%EF%BC%88%EF%BC%89%5Cbig(%5Cbig)%20%5CBig(%5CBig)%20%5Cbigg(%5Cbigg)%20%5CBigg(%5CBigg)" alt="（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)"></li>
<li>中括号，符号：<code>[]</code>，如：<img src="https://math.jianshu.com/math?formula=%5Bx+y%5D" alt="[x+y]"></li>
<li>大括号，符号：<code>\&#123; \&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7Bx+y%7D" alt="{x+y}"></li>
<li>自适应括号，符号：<code>\left \right</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cleft(x%5Cright)" alt="\left(x\right)">，<img src="https://math.jianshu.com/math?formula=%5Cleft(x%7Byz%7D%5Cright)" alt="\left(x{yz}\right)"></li>
<li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7Bn+1%20%5Cchoose%20k%7D=%7Bn%20%5Cchoose%20k%7D+%7Bn%20%5Cchoose%20k-1%7D" alt="{n+1 \choose k}={n \choose k}+{n \choose k-1}"></li>
<li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csum_%7Bk_0,k_1,%5Cldots%3E0%20%5Catop%20k_0+k_1+%5Ccdots=n%7DA_%7Bk_0%7DA_%7Bk_1%7D%5Ccdots" alt="\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots"></li>
</ol>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol>
<li>加法运算，符号：<code>+</code>，如：<img src="https://math.jianshu.com/math?formula=x+y=z" alt="x+y=z"></li>
<li>减法运算，符号：<code>-</code>，如：<img src="https://math.jianshu.com/math?formula=x-y=z" alt="x-y=z"></li>
<li>加减运算，符号：<code>\pm</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cpm%20y=z" alt="x \pm y=z"></li>
<li>减甲运算，符号：<code>\mp</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cmp%20y=z" alt="x \mp y=z"></li>
<li>乘法运算，符号：<code>\times</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ctimes%20y=z" alt="x \times y=z"></li>
<li>点乘运算，符号：<code>\cdot</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ccdot%20y=z" alt="x \cdot y=z"></li>
<li>星乘运算，符号：<code>\ast</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cast%20y=z" alt="x \ast y=z"></li>
<li>除法运算，符号：<code>\div</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cdiv%20y=z" alt="x \div y=z"></li>
<li>斜法运算，符号：<code>/</code>，如：<img src="https://math.jianshu.com/math?formula=x/y=z" alt="x/y=z"></li>
<li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cfrac%7Bx+y%7D%7By+z%7D" alt="\frac{x+y}{y+z}"></li>
<li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%7Bx+y%7D%20%5Cover%20%7By+z%7D" alt="{x+y} \over {y+z}"></li>
<li>绝对值表示，符号：<code>||</code>，如：<img src="https://math.jianshu.com/math?formula=%7Cx+y%7C" alt="|x+y|"></li>
</ol>
<h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol>
<li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Coverline%7Bxyz%7D" alt="\overline{xyz}"></li>
<li>开二次方运算，符号：<code>\sqrt</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csqrt%20x" alt="\sqrt x"></li>
<li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csqrt%5B3%5D%7Bx+y%7D" alt="\sqrt[3]{x+y}"></li>
<li>对数运算，符号：<code>\log</code>，如：<img src="https://math.jianshu.com/math?formula=%5Clog(x)" alt="\log(x)"></li>
<li>极限运算，符号：<code>\lim</code>，如：<img src="https://math.jianshu.com/math?formula=%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>极限运算，符号：<code>\displaystyle \lim</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Clim%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>求和运算，符号：<code>\sum</code>，如：<img src="https://math.jianshu.com/math?formula=%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>求和运算，符号：<code>\displaystyle \sum</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Csum%5E%7Bx%20%5Cto%20%5Cinfty%7D_%7By%20%5Cto%200%7D%7B%5Cfrac%7Bx%7D%7By%7D%7D" alt="\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}"></li>
<li>积分运算，符号：<code>\int</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D" alt="\int^{\infty}_{0}{xdx}"></li>
<li>积分运算，符号：<code>\displaystyle \int</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdisplaystyle%20%5Cint%5E%7B%5Cinfty%7D_%7B0%7D%7Bxdx%7D" alt="\displaystyle \int^{\infty}_{0}{xdx}"></li>
<li>微分运算，符号：<code>\partial</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cfrac%7B%5Cpartial%20x%7D%7B%5Cpartial%20y%7D" alt="\frac{\partial x}{\partial y}"></li>
<li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Bmatrix%7D%201%20&2%20&%5Ccdots%20&4%5C5%20&6%20&%5Ccdots%20&8%5C%5Cvdots%20&%5Cvdots%20&%5Cddots%20&%5Cvdots%5C13%20&14%20&%5Ccdots%20&16%5Cend%7Bmatrix%7D%20%5Cright%5D" alt="\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]"></li>
</ol>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol>
<li>等于运算，符号：<code>=</code>，如：<img src="https://math.jianshu.com/math?formula=x+y=z" alt="x+y=z"></li>
<li>大于运算，符号：<code>&gt;</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%3Ez" alt="x+y&gt;z"></li>
<li>小于运算，符号：<code>&lt;</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%3Cz" alt="x+y&lt;z"></li>
<li>大于等于运算，符号：<code>\geq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cgeq%20z" alt="x+y \geq z"></li>
<li>小于等于运算，符号：<code>\leq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cleq%20z" alt="x+y \leq z"></li>
<li>不等于运算，符号：<code>\neq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cneq%20z" alt="x+y \neq z"></li>
<li>不大于等于运算，符号：<code>\ngeq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cngeq%20z" alt="x+y \ngeq z"></li>
<li>不大于等于运算，符号：<code>\not\geq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cgeq%20z" alt="x+y \not\geq z"></li>
<li>不小于等于运算，符号：<code>\nleq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cnleq%20z" alt="x+y \nleq z"></li>
<li>不小于等于运算，符号：<code>\not\leq</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cnot%5Cleq%20z" alt="x+y \not\leq z"></li>
<li>约等于运算，符号：<code>\approx</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Capprox%20z" alt="x+y \approx z"></li>
<li>恒定等于运算，符号：<code>\equiv</code>，如：<img src="https://math.jianshu.com/math?formula=x+y%20%5Cequiv%20z" alt="x+y \equiv z"></li>
</ol>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol>
<li>属于运算，符号：<code>\in</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cin%20y" alt="x \in y"></li>
<li>不属于运算，符号：<code>\notin</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnotin%20y" alt="x \notin y"></li>
<li>不属于运算，符号：<code>\not\in</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnot%5Cin%20y" alt="x \not\in y"></li>
<li>子集运算，符号：<code>\subset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csubset%20y" alt="x \subset y"></li>
<li>子集运算，符号：<code>\supset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csupset%20y" alt="x \supset y"></li>
<li>真子集运算，符号：<code>\subseteq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csubseteq%20y" alt="x \subseteq y"></li>
<li>非真子集运算，符号：<code>\subsetneq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csubsetneq%20y" alt="x \subsetneq y"></li>
<li>真子集运算，符号：<code>\supseteq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csupseteq%20y" alt="x \supseteq y"></li>
<li>非真子集运算，符号：<code>\supsetneq</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csupsetneq%20y" alt="x \supsetneq y"></li>
<li>非子集运算，符号：<code>\not\subset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnot%5Csubset%20y" alt="x \not\subset y"></li>
<li>非子集运算，符号：<code>\not\supset</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cnot%5Csupset%20y" alt="x \not\supset y"></li>
<li>并集运算，符号：<code>\cup</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ccup%20y" alt="x \cup y"></li>
<li>交集运算，符号：<code>\cap</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Ccap%20y" alt="x \cap y"></li>
<li>差集运算，符号：<code>\setminus</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Csetminus%20y" alt="x \setminus y"></li>
<li>同或运算，符号：<code>\bigodot</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cbigodot%20y" alt="x \bigodot y"></li>
<li>同与运算，符号：<code>\bigotimes</code>，如：<img src="https://math.jianshu.com/math?formula=x%20%5Cbigotimes%20y" alt="x \bigotimes y"></li>
<li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li>
<li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li>
<li>空集，符号：<code>\emptyset</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cemptyset" alt="\emptyset"></li>
</ol>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol>
<li>无穷，符号：<code>\infty</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cinfty" alt="\infty"></li>
<li>虚数，符号：<code>\imath</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cimath" alt="\imath"></li>
<li>虚数，符号：<code>\jmath</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cjmath" alt="\jmath"></li>
<li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Chat%7Ba%7D" alt="\hat{a}"></li>
<li>数学符号，符号<code>\check&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Ccheck%7Ba%7D" alt="\check{a}"></li>
<li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cbreve%7Ba%7D" alt="\breve{a}"></li>
<li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Ctilde%7Ba%7D" alt="\tilde{a}"></li>
<li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cbar%7Ba%7D" alt="\bar{a}"></li>
<li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cvec%7Ba%7D" alt="\vec{a}"></li>
<li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cacute%7Ba%7D" alt="\acute{a}"></li>
<li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cgrave%7Ba%7D" alt="\grave{a}"></li>
<li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cmathring%7Ba%7D" alt="\mathring{a}"></li>
<li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdot%7Ba%7D" alt="\dot{a}"></li>
<li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cddot%7Ba%7D" alt="\ddot{a}"></li>
<li>上箭头，符号：<code>\uparrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cuparrow" alt="\uparrow"></li>
<li>上箭头，符号：<code>\Uparrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CUparrow" alt="\Uparrow"></li>
<li>下箭头，符号：<code>\downarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cdownarrow" alt="\downarrow"></li>
<li>下箭头，符号：<code>\Downarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CDownarrow" alt="\Downarrow"></li>
<li>左箭头，符号：<code>\leftarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cleftarrow" alt="\leftarrow"></li>
<li>左箭头，符号：<code>\Leftarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CLeftarrow" alt="\Leftarrow"></li>
<li>右箭头，符号：<code>\rightarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5Crightarrow" alt="\rightarrow"></li>
<li>右箭头，符号：<code>\Rightarrow</code>，如：<img src="https://math.jianshu.com/math?formula=%5CRightarrow" alt="\Rightarrow"></li>
<li>底端对齐的省略号，符号：<code>\ldots</code>，如：<img src="https://math.jianshu.com/math?formula=1,2,%5Cldots,n" alt="1,2,\ldots,n"></li>
<li>中线对齐的省略号，符号：<code>\cdots</code>，如：<img src="https://math.jianshu.com/math?formula=x_1%5E2%20+%20x_2%5E2%20+%20%5Ccdots%20+%20x_n%5E2" alt="x_1^2 + x_2^2 + \cdots + x_n^2"></li>
<li>竖直对齐的省略号，符号：<code>\vdots</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cvdots" alt="\vdots"></li>
<li>斜对齐的省略号，符号：<code>\ddots</code>，如：<img src="https://math.jianshu.com/math?formula=%5Cddots" alt="\ddots"></li>
</ol>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td><code>A</code></td>
<td>α</td>
<td><code>\alhpa</code></td>
</tr>
<tr>
<td>B</td>
<td><code>B</code></td>
<td>β</td>
<td><code>\beta</code></td>
</tr>
<tr>
<td>Γ</td>
<td><code>\Gamma</code></td>
<td>γ</td>
<td><code>\gamma</code></td>
</tr>
<tr>
<td>Δ</td>
<td><code>\Delta</code></td>
<td>δ</td>
<td><code>\delta</code></td>
</tr>
<tr>
<td>E</td>
<td><code>E</code></td>
<td>ϵ</td>
<td><code>\epsilon</code></td>
</tr>
<tr>
<td>Z</td>
<td><code>Z</code></td>
<td>ζ</td>
<td><code>\zeta</code></td>
</tr>
<tr>
<td>H</td>
<td><code>H</code></td>
<td>η</td>
<td><code>\eta</code></td>
</tr>
<tr>
<td>Θ</td>
<td><code>\Theta</code></td>
<td>θ</td>
<td><code>\theta</code></td>
</tr>
<tr>
<td>I</td>
<td><code>I</code></td>
<td>ι</td>
<td><code>\iota</code></td>
</tr>
<tr>
<td>K</td>
<td><code>K</code></td>
<td>κ</td>
<td><code>\kappa</code></td>
</tr>
<tr>
<td>Λ</td>
<td><code>\Lambda</code></td>
<td>λ</td>
<td><code>\lambda</code></td>
</tr>
<tr>
<td>M</td>
<td><code>M</code></td>
<td>μ</td>
<td><code>\mu</code></td>
</tr>
<tr>
<td>N</td>
<td><code>N</code></td>
<td>ν</td>
<td><code>\nu</code></td>
</tr>
<tr>
<td>Ξ</td>
<td><code>\Xi</code></td>
<td>ξ</td>
<td><code>\xi</code></td>
</tr>
<tr>
<td>O</td>
<td><code>O</code></td>
<td>ο</td>
<td><code>\omicron</code></td>
</tr>
<tr>
<td>Π</td>
<td><code>\Pi</code></td>
<td>π</td>
<td><code>\pi</code></td>
</tr>
<tr>
<td>P</td>
<td><code>P</code></td>
<td>ρ</td>
<td><code>\rho</code></td>
</tr>
<tr>
<td>Σ</td>
<td><code>\Sigma</code></td>
<td>σ</td>
<td><code>\sigma</code></td>
</tr>
<tr>
<td>T</td>
<td><code>T</code></td>
<td>τ</td>
<td><code>\tau</code></td>
</tr>
<tr>
<td>Υ</td>
<td><code>\Upsilon</code></td>
<td>υ</td>
<td><code>\upsilon</code></td>
</tr>
<tr>
<td>Φ</td>
<td><code>\Phi</code></td>
<td>ϕ</td>
<td><code>\phi</code></td>
</tr>
<tr>
<td>X</td>
<td><code>X</code></td>
<td>χ</td>
<td><code>\chi</code></td>
</tr>
<tr>
<td>Ψ</td>
<td><code>\Psi</code></td>
<td>ψ</td>
<td><code>\psi</code></td>
</tr>
<tr>
<td>Ω</td>
<td><code>\v</code></td>
<td>ω</td>
<td><code>\omega</code></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/29/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" data-id="cli9a4dnk0000qku20drg4sk4" data-title="LaTeX Formula" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ADS后篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/22/ADS%E5%90%8E%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2023-06-21T16:00:00.000Z" itemprop="datePublished">2023-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/22/ADS%E5%90%8E%E7%AF%87/">ADS后篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="NP完全"><a href="#NP完全" class="headerlink" title="NP完全"></a>NP完全</h1><ul>
<li><p>NP完全问题：找不到多项式算法，也无法证明不存在多项式时间算法</p>
<ul>
<li>最短路径判定版本</li>
<li>哈密顿圈</li>
<li>3-CNF可满足性问题</li>
</ul>
</li>
<li><p>P: 能在多项式时间O($ n^k $) 内解决的问题</p>
</li>
<li><p>NP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证（检验一组解是否满足）的问题，P$\subseteq $NP</p>
</li>
<li><p>NPC: NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它 的NP问题，即解决了此NPC问题，所有NP问题也都得到解决。</p>
</li>
<li><p>NP hard: NP难问题，所有NP问题在多项式时间内都能约化(Reducibility)到它 的问题(不一定是NP问题)。</p>
<ul>
<li>先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</li>
<li>已知的NPC：SAT问题，Vertex cover，TSP判定版本（求最短回路的是NPhard但不是NPC，一般说TSP都指的是NPC的TSP）</li>
</ul>
</li>
<li><p><img src="https://img-blog.csdn.net/20151015164207766" alt="img"></p>
</li>
<li><p>reduction(规约)：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。</p>
</li>
<li><p>x在多项式时间规约到y （x $ \leq_p $y）</p>
</li>
<li><p>例子：</p>
<ul>
<li>停机问题</li>
<li>最短路问题<ul>
<li>(G,s,t,k)：s到t是否有＜&#x3D;k长的路径</li>
<li>decision问题 -&gt; 等价于一个集合<ul>
<li>instance:&lt;G,s,t,k&gt;  -&gt; String</li>
</ul>
</li>
</ul>
</li>
<li>3-CNF问题<ul>
<li>satisfability问题（SAT）</li>
<li>对一组赋值，证明可满足</li>
<li>3-SAT：有k个clause，the MAX-3SAT problem is to find a truth assignment that satisfies as many clauses as possible.<ul>
<li>每一个clause都是 a || b || c 的形式</li>
</ul>
</li>
<li>B() is an efficient verifier(验证器) for problem X if<ul>
<li>B为多项式时间算法</li>
<li>P() is a poly function且满足对任意s，s属于X当且仅当存在string t使得B(s,t) &#x3D; yes，其中|t|&lt;&#x3D;P(|s|)</li>
</ul>
</li>
<li>B(s,t)：在t下计算s，若s满足，返回yes</li>
<li>只要求存在性，yes-certificate</li>
</ul>
</li>
<li>哈密顿圈（HCP）<ul>
<li>hint：一组圈</li>
<li>B：按照hint走一遍，检查是否每个点都走了一次</li>
</ul>
</li>
<li>Travelling Salesman Problem（TSP）<ul>
<li>给一张完全图G和整数k，问是否存在简单环使得每个点走一次且cost&lt;&#x3D;k</li>
<li>HCP $ \leq_p $TSP<ul>
<li>补成完全图，原来的边设为1，补上的边设为2，若HCP成立，则TSP的k取为|v|即可</li>
<li>实例的转化为多项式时间</li>
</ul>
</li>
</ul>
</li>
<li>最大团问题（clique problem）<ul>
<li>给出G和k</li>
<li>问是否能选出至少k个点使得两两之间都有边相连（为团）</li>
</ul>
</li>
<li>顶点覆盖问题（vertex cover problem）<ul>
<li>给出G和k</li>
<li>是否有一个点集保证每条边至少有一个端点被选中</li>
<li>clique problem $ \leq_p $ vertex cover problem<ul>
<li>边集互补</li>
<li>点集C在G里是团当且仅当在V-C在G’里是顶点覆盖</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>题目：</p>
<ul>
<li><p>1.If L1 ≤p L2 and L2∈NP, then L1∈NP.<br>T<br>注意&lt;&#x3D;p等价于reduce to，复杂的如果是Np，那么简单的也是NP</p>
<p>2.All NP-complete problems are NP problems.<br>T</p>
<p>3.All the languages can be decided by a non-deterministic machine.<br>F<br>不确定图灵机可以用来验证NP问题的解是否是正确的，确定图灵机可以用来求解P问题。</p>
<p>NP hard问题无法通过不确定图灵机验证</p>
<p>4.All NP problems can be solved in polynomial time in a non-deterministic machine.<br>T</p>
<p>5.If a problem can be solved by dynamic programming, it must be solved in polynomial time.<br>F</p>
<p>0-1背包问题可以用DP解，但是复杂度不是多项式的, 原因是输入的数据不是多项式的。</p>
<p>6.Among the following problems, __ is NOT an NP-complete problem.</p>
<p>A.Vertex cover problem</p>
<p>B.Hamiltonian cycle problem</p>
<p>C.Halting problem</p>
<p>D.Satisfiability problem</p>
<p>D SAT问题是第一个被证明的NPC问题，A是NPC问题，B是汉密尔顿回路，NPC问题。C停机问题是不可解的，选C</p>
<p>7.Suppose Q is a problem in NP, but not necessarily NP-complete. Which of the following is FALSE?</p>
<p>A.A polynomial-time algorithm for SAT would sufficiently imply a polynomial-time algorithm for Q.</p>
<p>B.A polynomial-time algorithm for Q would sufficiently imply a polynomial-time algorithm for SAT.</p>
<p>C.If Q ∉P, then P≠NP.</p>
<p>D.If Q is NP-hard, then Q is NP-complete.</p>
<p>看上面的图，SAT是NPC问题，如果解决了，可以解决所有NP问题</p>
<p>B， Q不一定是NPC的，所以不对，C，如果Q不是P，那么说明NP没有被解决，D，NP-hard和NP交集是NPC</p>
<p>8.A language L belongs to NP iff there exist a two-input polynomial-time algorithm A that verifies language L in polynomial time.</p>
<p>T， 这是ppt上的</p>
<p>9.Given that problem A is NP-complete. If problem B is in NP and can be polynomially reduced to problem A, then problem B is NP-complete.</p>
<p>B&lt;&#x3D; A，但是A是NPC问题，A&lt;&#x3D;B才能说明B也是NPC问题。</p>
<p>10.All decidable problems are NP problems.</p>
<p>F，还有NP hard问题</p>
<p>11.All NP problems are decidable.</p>
<p>T, 可以通过不确定图灵机判断</p>
<p>12.To prove problem B is NP-complete, we can use a NP-complete problem A and use a polynomial-time reduction algorithm to transform an instance of problem B to an instance of problem A.</p>
<p>F, 应该不是一个实例，而是整个问题</p>
<p>13.If P &#x3D; NP then the Shortest-Path (finding the shortest path between a pair of given vertices in a given graph) problem is NP-complete.</p>
<p>T, P&#x3D;NP说明所有的NP问题均可解，所有的NPC问题可解，NP&#x3D;NPC</p>
</li>
</ul>
</li>
</ul>
<h1 id="近似"><a href="#近似" class="headerlink" title="近似"></a>近似</h1><ul>
<li><p>近似比：</p>
<ul>
<li>max(A(I)&#x2F;opt(I) , opt(I)&#x2F;A(I)) &lt;&#x3D; $ \rho $(|I|)，则称其为$\rho$(n)近似的算法</li>
</ul>
</li>
<li><p>A polynomial-time approximation scheme(PTAS)</p>
<ul>
<li>PTAS：关于n为多项式</li>
<li>FPTAS：关于1&#x2F;ϵ也为多项式</li>
</ul>
</li>
<li><p>例子：</p>
<ul>
<li><p>Binpack problem（NPhard）</p>
<ul>
<li>input：n items with sizes s1~sn</li>
<li>output：用尽可能少的箱子装（箱子容量固定）</li>
<li>Next fit：顺序装，装不下封箱下一个<ul>
<li>NF用的箱子数，opt最优解箱子数</li>
<li>NF&#x2F;opt &lt;&#x3D; 2：近似比</li>
<li>2-approximation算法</li>
</ul>
</li>
<li>Any fit：for一遍，当前打开的箱子可以装就装，不能就开一个新的<ul>
<li>First fit：找第一个</li>
<li>Best fit：找装的最满的</li>
<li>BF(I)&amp;FF(I) &lt;&#x3D; 1.7opt(I)，即近似比为1.7<ul>
<li>绝对近似比</li>
</ul>
</li>
</ul>
</li>
<li>First&#x2F;Best fit decreasing:<ul>
<li>先对item排序</li>
<li>BFD(I)&amp;FFD(I) &lt;&#x3D; 11&#x2F;9 opt(I) + 6&#x2F;9<ul>
<li>渐进近似比为11&#x2F;9</li>
<li>绝对近似比，在 opt(I) 取2时得，为1.5</li>
</ul>
</li>
</ul>
</li>
<li>NP复杂度最优近似比1.5，要求online则最优5&#x2F;3</li>
</ul>
</li>
<li><p>Knapsack problem(背包问题)</p>
<ul>
<li>Input：n items (v1,w1)~(vn,wn)，容量C</li>
<li>output：最大化总价值的背包装法<ul>
<li>O(nC)或O(nV_sum)，伪多项式</li>
</ul>
</li>
<li>分数版本：可以选零点几个物品<ul>
<li>按性价比贪心</li>
</ul>
</li>
<li>整数版本（NPhard）<ul>
<li>贪心算法<ul>
<li>on vi&#x2F;wi（性价比）<ul>
<li>被小物件卡，选不了高价值大物件</li>
<li>OPT&#x2F;A&gt;&#x3D;(C-1)&#x2F;2</li>
</ul>
</li>
<li>on vi（价值）<ul>
<li>被大物件卡，选不了高性价比小物件</li>
<li>OPT&#x2F;A&gt;&#x3D;C-1</li>
</ul>
</li>
<li>两种算法存在缺点，但互补</li>
</ul>
</li>
<li>A*：A1和A2各跑一遍选最优<ul>
<li>A1 &gt;&#x3D; OPT_分数版本 - Vmax</li>
<li>A2 &gt;&#x3D; Vmax</li>
<li>则2A* &gt;&#x3D; OPT_frac &gt;&#x3D; OPT</li>
<li>A* &gt;&#x3D; OPT&#x2F;2</li>
</ul>
</li>
<li>优化：所有v除以一个d<ul>
<li>原本O($n^2V_{sum}$)</li>
<li>d&#x3D;gcd(v1…vn)，则不影响结果</li>
<li>d&#x3D; $ \lceil nV_{sum}&#x2F;\delta\rceil$ ，则O($ n^3 &#x2F; \delta $)</li>
<li>求出近似比为$ 1&#x2F;1-\delta $</li>
</ul>
</li>
</ul>
</li>
<li>K-center problem<ul>
<li>Input：n site s1…sn，整数k</li>
<li>output：找到k个center，盖住所有sites并使得半径最小</li>
<li>dist(x,c)&#x3D;$min_{y\sub C}$ (dist(x,y))</li>
<li>k&#x3D;1：随便选一个site作为center，近似比为2</li>
<li>已知最优解：<ul>
<li>若存在未覆盖site，选为site，然后去掉覆盖的site</li>
<li>循环最多进行k次</li>
<li>所以假定一个解（二分）</li>
</ul>
</li>
<li>贪心<ul>
<li>选一个site作为center</li>
<li>一直选择距离center最远的site作为新的center</li>
<li>得到最终的center集合Ck</li>
<li>r(Ck)&lt;&#x3D;2r*</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>题目：</p>
<ul>
<li><p>1.Suppose ALG is an α-approximation algorithm for an optimization problem Π whose approximation ratio is tight. Then for every ϵ&gt;0 there is no (α−ϵ)-approximation algorithm for Π unless P &#x3D; NP.<br>F, 按照我的理解，可能会有近似比更小的算法。</p>
<p>2.As we know there is a 2-approximation algorithm for the Vertex Cover problem. Then we must be able to obtain a 2-approximation algorithm for the Clique problem, since the Clique problem can be polynomially reduced to the Vertex Cover problem.<br>T， reduce to 就算&lt;&#x3D;，如果CP&lt;&#x3D;VC, VC有近似比为2的算法，那么CP也有</p>
<p>3.For the bin-packing problem: let S&#x3D;∑Si. Which of the following statements is FALSE?</p>
<p>A.The number of bins used by the next-fit heuristic is never more than ⌈2S⌉</p>
<p>B.The number of bins used by the first-fit heuristic is never more than ⌈2S⌉</p>
<p>C.The next-fit heuristic leaves at most one bin less than half full</p>
<p>D.The first-fit heuristic leaves at most one bin less than half full</p>
<p>NF近似比是2，其他的近似比都比2小。Next fit可能有多个半空的bit，因为如果永远往前放，不会回头放之前的，所以是C，而FF会检查之前所有位，因此如果有两个半空的，它们会放在一起。</p>
<p>4.To approximate a maximum spanning tree T of an undirected graph G&#x3D;(V,E) with distinct edge weights w(u,v) on each edge (u,v)∈E, let’s denote the set of maximum-weight edges incident on each vertex by S. Also let w(E′)&#x3D;∑(u,v)∈E′， w(u,v) for any edge set E′. Which of the following statements is TRUE?</p>
<p>A.S&#x3D;T for any graph G</p>
<p>B.S≠T for any graph G</p>
<p>C.w(T)≥w(S)&#x2F;2 for any graph G</p>
<p>D.None of the above</p>
<p>C, 题目的意思是，如果把每个点最大权值的边加入一个集合，那么这个集合的权值和最大生成树权值之比是多少。注意，点的最大权值边集合意味着集合里相同的边最多出现一次。</p>
<p>很容易证明，S里面不存在环，因此T一定包含S.所以w(T)&gt;&#x3D;w(S)</p>
<p>假如存在环，设边为e1,e2,e3,…ej, 点为p1, …pj</p>
<p>由于e1在S中，因此w(e1)&gt;w(ej)，由于e2在S中，因此w(e2)&gt;w(e1),…，最后得到的是w(ej)&gt;w(e1)，矛盾。</p>
<p>5.Assume that you are a real world Chinese postman, which have learned an awesome course “Advanced Data Structures and Algorithm Analysis” (ADS). Given a 2-dimensional map indicating N positions pi(xi ,yi) of your post office and all the addresses you must visit, you’d like to find a shortest path starting and finishing both at your post office, and visit all the addresses at least once in the circuit. Fortunately, you have a magic item “Bamboo copter &amp; Hopter” from “Doraemon”, which makes sure that you can fly between two positions using the directed distance (or displacement).</p>
<p>Bamboo.jpg (“Bamboo copter &amp; Hopter”, japan12.com&#x2F;bamboo-copter-hopter)</p>
<p>However, reviewing the knowledge in the ADS course, it is an NPC problem! Wasting too much time in finding the shortest path is unwise, so you decide to design a 2−approximation algorithm as follows, to achieve an acceptable solution.</p>
<p>Compute a minimum spanning tree T connecting all the addresses.<br>Regard the post office as the root of T.<br>Start at the post office.<br>Visit the addresses in order of a _____ of T.<br>Finish at the post office.<br>There are several methods of traversal which can be filled in the blank of the above algorithm. Assume that P≠NP, how many methods of traversal listed below can fulfill the requirement?</p>
<p>Level-Order Traversal<br>Pre-Order Traversal<br>Post-Order Traversal</p>
<p>A.0</p>
<p>B.1</p>
<p>C.2</p>
<p>D.3</p>
<p>C，不知道题目再说什么</p>
<p>6.An approximation scheme that runs in <em>O</em>(<em>n</em>^2&#x2F;<em>ϵ</em>) for any fixed <em>ϵ</em>&gt;0 is a fully polynomial-time approximation scheme.</p>
<p>T, 如果1&#x2F;ϵ也是多项式级别的，那么就算是full</p>
<p>7.An approximation scheme that runs in <em>O</em>(<em>n</em>^2 3^<em>ϵ</em>) for any fixed <em>ϵ</em>&gt;0 is a polynomial-time approximation scheme.</p>
<p>T, 只要是n是多项式级别的就可以。</p>
<p>8.In the bin packing problem, we are asked to pack a list of items L to the minimum number of bins of capacity 1. For the instance L, let FF(L) denote the number of bins used by the algorithm First Fit. The instance L′ is derived from L by deleting one item from L. Then FF(L′) is at most of FF(L).</p>
<p>F, 如果是NF则是F, yds说的。</p>
<p>9.For the 0-1 version of the Knapsack problem, if we are greedy on taking the maximum profit or profit density, then the resulting profit must be bounded below by the optimal solution minus the maximum profit.</p>
<p>Popt&lt;Pfrac&lt;Pgre+pmax，最优解一定小于物体可分情况下的解。而物体可分情况下的解，可以看成greedy的解+一部分不完整的物体。不完整的物体权值一定小于最大权值。</p>
<p>(感觉证明有问题)</p>
<p>10.An (1+ϵ)-approximation scheme of time complexity (n+1&#x2F;ϵ)^3 is a PTAS but not an FPTAS.</p>
<p>F</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><p>1.Suppose we have the internal memory that can handle 12 numbers at a time, and the following two runs on the tapes:</p>
<p>Run 1: 1, 3, 5, 7, 8, 9, 10, 12</p>
<p>Run 2: 2, 4, 6, 15, 20, 25, 30, 32</p>
<p>Use 2-way merge with 4 input buffers and 2 output buffers for parallel operations. Which of the following three operations are NOT done in parallel?</p>
<p>(3分)</p>
<p>A.1 and 2 are written onto the third tape; 3 and 4 are merged into an output buffer; 6 and 15 are read into an input buffer</p>
<p>B.3 and 4 are written onto the third tape; 5 and 6 are merged into an output buffer; 8 and 9 are read into an input buffer</p>
<p>C.5 and 6 are written onto the third tape; 7 and 8 are merged into an output buffer; 20 and 25 are read into an input buffer</p>
<p>D.7 and 8 are written onto the third tape; 9 and 15 are merged into an output buffer; 10 and 12 are read into an input buffer</p>
<p>工作原理：buffer 一个一个按顺序被写。两个run轮流对buffer进行写。</p>
<p>需要注意的是：如果之前有没有merge完成的，比较复杂，需要等待。</p>
<p>一共4+2个buffer, 内存有12个数，因此每个buffer2个数。六个buffer,后两个是输出的</p>
<p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230625194217783.png" alt="image-20230625194217783"></p>
<p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230625194259189.png" alt="image-20230625194259189"></p>
<p>这题A描述的是3-&gt;4, B描述的是4-&gt;5，C描述的是5-&gt;6, D错在不是9和15 merge, 9和10 merge</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/22/ADS%E5%90%8E%E7%AF%87/" data-id="cljmaqts10000vku2giv2g9ew" data-title="ADS后篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/class/" rel="tag">class</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-认知神经科学导论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2023-06-04T16:00:00.000Z" itemprop="datePublished">2023-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/">认知神经科学导论笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Lec-1-绪论"><a href="#Lec-1-绪论" class="headerlink" title="Lec 1-绪论"></a>Lec 1-绪论</h2><ul>
<li>课程简介<ul>
<li>本课程注重计算机科学、 计算神经科学、脑科学和⼈⼯智能等多<br>学科的交叉和融合。</li>
<li>⾸先介绍脑启发⼈⼯智能的基本概念和进展，进⼀步讲解基于⼤<br>脑结构和信息处理机制的神经元、突触以及由神经元和突触构成<br>的⽹络， 并着重介绍相关的计算模型和算法。</li>
<li>课程将从⽣物神经元模型和信息处理机制、⼤脑的结构和功能、<br>感知原理及模型、学习机制及学习算法、脉冲神经⽹络等⽅⾯进<br>⾏展开。</li>
<li>通过这门课程的学习，学⽣可以掌握神经科学关于神经元、神经<br>系统的基本机制和模型，以及感知、学习、记忆等功能，启发同<br>学们对脑科学、神经科学、信息技术交叉领域的研究思路，培养<br>掌握新⼀代信息技术的专业⼈才。</li>
<li>掌握大脑神经信息处理和计算的基本机制；<br>掌握神经元的基本计算模型及算法；<br>掌握不同输入对神经活动的影响；<br>掌握主要神经可塑性模型；<br>掌握代表性学习算法；<br>理解基本的大脑感知和认知机制。</li>
</ul>
</li>
<li>认知神经科学三个层次：<ul>
<li>神经元（ Neurons）</li>
<li>神经环路（ Neuron Circuits）</li>
<li>脑的⾼级功能和⾏为（ Behavior）</li>
</ul>
</li>
</ul>
<h2 id="Lec2-神经生理学基础"><a href="#Lec2-神经生理学基础" class="headerlink" title="Lec2-神经生理学基础"></a>Lec2-神经生理学基础</h2><ul>
<li><p>神经计算系统的基本特征 (Characteristics of Neural Computation Systems)</p>
<ul>
<li>基本计算单元：Neurons</li>
<li>信号传递：Signaling is organized in the same way in all neurons</li>
<li>神经元的多样性：Neurons differ most at the molecular level</li>
<li>神经可塑性：<ul>
<li>Neuron carefully selects to connect each other;</li>
<li>Neural connections can be modified by experience</li>
</ul>
</li>
</ul>
</li>
<li><p>神经元形态 (Neural Morphology)</p>
<ul>
<li>形态分类： Morphology<ul>
<li>多极（multipolar） 神经元：有多个树突和一个轴突的神经元，如大多数的神经元。</li>
<li>双极（bipolar） 神经元：只有一个树突和一个轴突的神经元，如视网膜的感光神经元。</li>
<li>单极（unipolar） 神经元： 只有一个突起，从细胞体分离出来后会分为两个末端，一个连接到感觉器官，另一个连接到中枢神经系统，主要负责传递感觉信号。</li>
</ul>
</li>
<li>功能分类： Function<ul>
<li>感觉（sensory） 神经元：传递感觉信息。</li>
<li>运动（motor） 神经元：控制肌肉运动。</li>
<li>中间神经元（interneurons）：在感觉神经元和运动神经元之间传递信息。</li>
</ul>
</li>
<li>突触分类： Synapses<ul>
<li>兴奋性神经元（excitatory neurons）</li>
<li>抑制性神经元（inhibitory neurons）</li>
</ul>
</li>
</ul>
</li>
<li><p>神经元结构 (Neural Structure)</p>
<ul>
<li>Dendrites (树突) Input component</li>
<li>Soma (胞体) Generate an Action Potential</li>
<li>Axon (轴突) Conductive component propagates AP</li>
<li>Axon-end (轴突终端) Output component interact with other neurons</li>
</ul>
</li>
<li><p>信息传递：输入-&gt;整合-&gt;传导-&gt;输出</p>
<ul>
<li>方向性（Direction）：沿着轴突向下游传递， 不能反向传播。</li>
<li>全或无法则（all or nothing principle）： 神经元反应的强弱不随外界刺激的强弱而改变， 信息在传递途中不会变得越来越微弱。</li>
<li>一致性（Non-Degrading）：沿轴突传递的活动强度一致</li>
</ul>
</li>
<li><p>离子通道 (Ion channels)</p>
<ul>
<li>Rapid signaling in the neuron depends on ion channels </li>
<li>Currents through single ion channels can be recorded </li>
<li>神经元的细胞膜具有双层膜结构，由绝缘良好的磷脂构成，是水溶性分子的屏障。</li>
<li>离子通道按门控方式可以分为四类：<br>电压门控离子通道（Voltage-gated ion channels）<br>配合基门控离子通道（Ligand-gated ion channels）<br>磷酸化门控离子通道（Phosphorylation-gated ion channels）<br>机械门控离子通道（Mechanically-gated ion channels）<br>常见的电压门控离子通道有钠离子通道和钾离子通道。</li>
</ul>
</li>
<li><p>神经元的电学特性及膜电位 (Electrical properties and Membrane Potential)</p>
<ul>
<li>膜电位：$ V_m &#x3D; V_{in} - V_{out} $</li>
<li>静膜电位(Resting membrane potential)：$ V_r &#x3D; V_{in} $</li>
</ul>
</li>
<li><p>神经递质 （Neurotransmitter）</p>
</li>
</ul>
<h2 id="Lec3-神经信号与突触"><a href="#Lec3-神经信号与突触" class="headerlink" title="Lec3-神经信号与突触"></a>Lec3-神经信号与突触</h2><ul>
<li><p>AP动作电位（Action Potential）：离子快速跨膜时引起的细胞内和细胞外的电势差，是神经元信息处理能力的基础。 </p>
</li>
<li><p>静息电位——极化<br>当神经细胞处于静息状态时， K+通道开放（Na+通道关闭），这时K+会从浓度高的膜内向浓度低的膜外运动，使膜外带正电，膜内带负电。膜外正电的产生阻止了膜内K+离子的继续外流，使膜电位不再发生变化，此时膜电位称为静息电位。</p>
</li>
<li><p>动作电位（脉冲）——去极化</p>
<p>当神经细胞受到刺激后， Na+通道开放，这样， Na+在很短的时间内会大量涌入细胞内，从而使细胞处于膜内带正电，膜外相对带负电的兴奋状态。此时膜电位称为动作电位，是细胞兴奋的主要表现。</p>
</li>
<li><p>未受刺激的时候，电势外正内负，假设膜电位为-45，这叫“静息电位”，也<br>叫“极化”状态；受刺激后电压上升一段，这叫“去极化”；当突触后电位叠加<br>达到阈值电位时，突触后神经元产生动作电位（即发放脉冲），之后电压会<br>下降一段，这叫“复极化”；复极化超过静息电位的部分叫“超极化”，之后恢<br>复静息电位。</p>
</li>
</ul>
<img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230606103903660.png" alt="image-20230606103903660" style="zoom: 67%;" />

<ul>
<li>突触传递（ Synaptic Transmission）  <ul>
<li>突触前神经元的轴突，与突触后神经元的树突或胞体接触的部位被称为突触；</li>
<li>最普遍的突触类型是化学突触（ Chemical Synapse） ,通过一系列生化反应传递信号：突触前神经元发放神经递质，接触缝隙（ cleft）后端的突触后神经元的接收器与神经递质结合并打开离子通道（ Ion Channel），从而导致突触后神经元膜电位的变化，化学信号转变为电信号；突触后神经元对突触前AP的响应被定义为突触后电位（ postsynaptic potential），简称PSP(postsynaptic potential)。  </li>
<li>电突触（ Electrical Synapse） :神经元之间通过特定膜蛋白直接进行电连接，电突触可能和神经元间的的同步（ synchronization）相关。</li>
</ul>
</li>
</ul>
<h2 id="Lec4-神经元模型"><a href="#Lec4-神经元模型" class="headerlink" title="Lec4-神经元模型"></a>Lec4-神经元模型</h2><ul>
<li><p>脉冲（Spike）：同AP，神经元信息传递的基本单位</p>
</li>
<li><p>脉冲序列（ Spike Train） :一个神经元发放的一系列脉冲。</p>
</li>
<li><p>脉冲序列中的任意脉冲之间都有一定的时间间隔，两个脉冲之间的最短间隔定义了神经元的<strong>不应期（ Refractory Period）</strong>；不应期内接收到信号也很难或不能发放新的脉冲。  </p>
</li>
<li><p>LIF神经元模型：(Leaky Integrate-and-Fire Model)  </p>
<ul>
<li><p>一个神经元被一个很好的绝缘体—细胞膜包围。如果一个短的电流脉冲I(t)注入到神经元中，它将会给细胞膜充电，细胞膜因此像电容C。</p>
</li>
<li><p>因为这个绝缘体并不完美，随着时间的推移，电荷会慢慢通过细胞膜渗漏出来。因此，细胞膜可以被看做有限的泄露电阻R。  </p>
</li>
<li><p>利用电流守恒定律，将驱动电流<code>I(t)</code>分为两个部分：</p>
<ul>
<li><p>$ I(t) &#x3D; I_R + I_C $</p>
</li>
<li><p>其中：<br>$ I_R&#x3D;u_R &#x2F; R &#x3D; (u(t) - u_{rest}) &#x2F; R $<br>$ I_C &#x3D; dq &#x2F; dt &#x3D; Cdu &#x2F; dt $</p>
</li>
<li><p>Leaky Integrate and Fire (LIF) 膜电压变化满足:</p>
</li>
</ul>
<p>  $ \tau_m \frac{du(t)}{dt} &#x3D; -[u(t) - u_{rest}] + R_mI(t) $ : 膜电压动力学方程</p>
<ul>
<li><p>$ \tau_m $: Membrane time constant</p>
</li>
<li><p>$ u(t) $：Membrane potential</p>
</li>
<li><p>$ u_{rest} $： Resting potential</p>
</li>
<li><p>$ R_m $: Membrane resistance</p>
</li>
<li><p>$ I(t) $: Total input current </p>
</li>
<li><p>恒定电流时：$  \frac{du(t)}{dt} + \frac{1}{\tau_m}u(t) &#x3D;  \frac{1}{\tau_m}u_{rest} + \frac{1}{\tau_m}R_mI $ </p>
</li>
<li><p>假设$ u(0) &#x3D; u_{rest} &#x3D; 0 $，最终得到：$ u(t) &#x3D; RI(1 - e^{-\frac{t}{\tau_m}}) $</p>
</li>
<li><p>脉冲发放周期：$ T &#x3D; \tau_mln\frac{RI}{RI - V_{th}} $</p>
</li>
</ul>
</li>
<li><p>定义神经元𝑖的膜电压为𝑢(𝑡)，其静息态膜电压为$𝑢_{rest} $；</p>
</li>
<li><p>𝑡 &#x3D; 0,突触前神经元𝑗发放一个脉冲， 𝑡 &gt; 0 突触后电位(PSP)<br>$ 𝜀_{ij}(𝑡) &#x3D; 𝑢<em>i(𝑡) - 𝑢</em>{rest} $</p>
</li>
<li><p>如果PSP是正的，定义为兴奋型（ Excitatory PSP），简称EPSP；反之定义为抑制型（ Inhibitory PSP），简称IPSP。 </p>
</li>
<li><p>膜电压计算公式：$ 𝑢<em>i(𝑡) &#x3D; \sum</em>{j}\sum_{f}𝜀_{ij}(𝑡 - t_j^{(f)}) + 𝑢_{rest} $</p>
</li>
</ul>
</li>
</ul>
<h2 id="Lec5-神经信息编码"><a href="#Lec5-神经信息编码" class="headerlink" title="Lec5-神经信息编码"></a>Lec5-神经信息编码</h2><ul>
<li>Rate Coding<ul>
<li>It is the firing rate of neurons, not the precise firing time which carries information  </li>
<li>Set an encoding time window T and count the number of spikes within it.  </li>
<li>The temporal average of spike times is defined as the mean firing rate by the following equation:  $ r &#x3D; \frac{n_{sp}}{T} &#x3D; \frac1{T} \int_0^Ts(t)dt$</li>
<li>r：发放率，T：时间窗口长度，n(T)：时间窗口内脉冲数</li>
</ul>
</li>
<li>Temporal Coding<ul>
<li>The precise firing time of neurons carries information</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/" data-id="clj2mxxkt0000wgu2eqnf2rid" data-title="认知神经科学导论笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/class/" rel="tag">class</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C++工程规范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/">C++ Project Norm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="File-design："><a href="#File-design：" class="headerlink" title="File design："></a>File design：</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── main.cpp</span><br><span class="line">├── database.h // declaration</span><br><span class="line">├── database.cpp // defination</span><br><span class="line">├── tuple.h // type</span><br><span class="line">├── tuple.cpp</span><br><span class="line">├── writer.h // superclass</span><br><span class="line">├── writer.cpp</span><br><span class="line">├── adiwriter.h // subclass</span><br><span class="line">├── adiwriter.cpp</span><br><span class="line">├── Makefile</span><br><span class="line">├── test.bat // the batch file</span><br><span class="line">├── READNE.md</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Declaration-h"><a href="#Declaration-h" class="headerlink" title="Declaration (.h)"></a>Declaration (.h)</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DATABASE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DATABASE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tuple.h&quot;</span> <span class="comment">// 只需调用声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adiwriter.h&quot;</span> <span class="comment">// 只需调用实际用到的子类</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::set&lt;tuple&gt; records;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Database</span>();</span><br><span class="line">    <span class="built_in">Database</span>(std::string filename);</span><br><span class="line">    ~<span class="built_in">Database</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>ifndef：防止嵌套调用时出现反复调用的情况。</li>
</ul>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string primaryKey;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; keytypes;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; values;</span><br><span class="line">    <span class="built_in">tuple</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrimaryKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> tuple &amp;a, <span class="type">const</span> tuple &amp;b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>重载运算符：用于排序与比较。</li>
<li>类型定义后使用同struct（不如说就是一个东西）</li>
</ul>
<h2 id="继承类应用"><a href="#继承类应用" class="headerlink" title="继承类应用"></a>继承类应用</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Writer</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Writer</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">adiWriter</span> : <span class="keyword">public</span> Writer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="namespace使用"><a href="#namespace使用" class="headerlink" title="namespace使用"></a>namespace使用</h2><ul>
<li>namespace命名空间，包含多种关键字，std为常用的命名空间，cin，cout即为其中的关键字</li>
<li>若只想使用其中一个：<code>using std::sort;</code></li>
<li>在一个代码块内如果有和命名空间相同的变量名，那么使用<code>using namespace</code>是无效的。</li>
<li>自定义namespace：</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> NM1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> NM1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; zero;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>跨文件使用：同class，不过用<code>using namespace</code>调用</li>
</ul>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><ul>
<li><code>argc</code> 和 <code>argv</code>：命令行参数<ul>
<li>第一个参数<code>argc</code>，用于参数计数，其值等于命令行中参数的个数；第二个参数<code>argv</code>，用于参数向量，是一个指向字符串数组的指针。</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：./main.o 123 456</span><br><span class="line">&gt;argc = 3</span><br><span class="line">&gt;argv[0] = &quot;./main.o&quot;</span><br><span class="line">&gt;argv[1] = &quot;123&quot;</span><br><span class="line">&gt;argv[2] = &quot;456&quot;</span><br><span class="line">&gt;// 直接运行程序则argc = 1(运行程序而传入的命令)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​		下面的代码用于读入输入的命令（因为要用batch，所以这样读）</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    std::string command;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123; <span class="comment">// 单条完整命令</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(std::cin, command))</span><br><span class="line">            db.<span class="built_in">processCommand</span>(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 命令被空格分开</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">            command = command + argv[i] + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        db.<span class="built_in">processCommand</span>(command);</span><br><span class="line">    &#125;</span><br><span class="line">    db.<span class="built_in">exportDatabase</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>iostream</code>：标准读写流</p>
<ul>
<li><code>cin</code>，<code>cout</code>分别是<code>istream</code>，<code>ostream</code>的对象，我们可以自己创造其他<code>istream</code>，<code>ostream</code>的对象。</li>
<li><code>freopen(&quot;test.txt&quot;,&quot;w&quot;,stdout)</code>将标准输出重定向到<code>test.txt</code>。</li>
</ul>
</li>
<li><p><code>fstream</code>：文件读写流</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ofstream fout;</span><br><span class="line">fout.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">fout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Makefile使用"><a href="#Makefile使用" class="headerlink" title="Makefile使用"></a>Makefile使用</h2><blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare compiler variable</span></span><br><span class="line">CXX=g++</span><br><span class="line"><span class="comment"># Declare compilation options</span></span><br><span class="line">CXXFLAGS=-Wall -g --std=c++11</span><br><span class="line"><span class="comment"># Declare linking options</span></span><br><span class="line">LDFLAGS=</span><br><span class="line"><span class="comment"># Declare source code files</span></span><br><span class="line">SRCS=main.cpp tuple.cpp writer.cpp adiwriter.cpp database.cpp</span><br><span class="line"><span class="comment"># Convert source code files to a list of object files</span></span><br><span class="line">OBJS=$(SRCS:.cpp=.o)</span><br><span class="line"><span class="comment"># Declare executable name</span></span><br><span class="line">TARGET=adif</span><br><span class="line"><span class="comment"># Default target</span></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"><span class="comment"># Dependencies</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="comment"># Automatically generate dependencies</span></span><br><span class="line"><span class="section">.depend: <span class="variable">$(SRCS)</span></span></span><br><span class="line">	rm -f ./.depend</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -MM <span class="variable">$^</span> &gt; ./.depend</span><br><span class="line"><span class="comment"># Include dependencies</span></span><br><span class="line"><span class="keyword">-include</span> .depend</span><br><span class="line"><span class="comment"># Clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span> .depend</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="batch文件"><a href="#batch文件" class="headerlink" title="batch文件"></a>batch文件</h2><ul>
<li><p><code>make.bat</code></p>
<ul>
<li>窗口交互型</li>
<li>没有Makefile，用于编译与生成可执行文件Main</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ -c main.cpp -std=c++11 -o main.o</span><br><span class="line">g++ -c database.cpp -std=c++11 -o database.o</span><br><span class="line">...</span><br><span class="line">g++ -o Main main.o Maze.o Player.o</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>test.bat</code></p>
<ul>
<li>指令测试型</li>
<li>有Makefile，用于调用Makefile编译以及输入命令测试。</li>
<li>echo为回显在屏幕上的内容</li>
<li>没有echo的为输入的指令，<code>mingw32-make</code>调用Makefile</li>
<li>pause后，需按任意键才会输入下一条指令</li>
</ul>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo The version of C++ is C++11</span><br><span class="line">mingw32-make</span><br><span class="line">echo Compile successfully.</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">echo ./adif -i a.adi</span><br><span class="line">adif -i a.adi</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">echo ./adif -s BD8GK</span><br><span class="line">adif -s BD8GK</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line">echo ./adif -o test.adi</span><br><span class="line">adif -o test.adi</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/" data-id="cli9awcwm0000l0u29dzj0mdf" data-title="C++ Project Norm" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DB后篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/DB%E5%90%8E%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/DB%E5%90%8E%E7%AF%87/">DB后篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><ul>
<li><p>分类：</p>
<ul>
<li><p>易失存储 volatile storage </p>
</li>
<li><p>非易失存储 non-volatile storage </p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607021440123.png" alt="image-20230607021440123"></p>
</li>
<li><p>NVM（non-volatile memory）: 掉电不丢</p>
</li>
<li><p><strong>primary storage</strong>: Fastest media but volatile (cache, main memory).</p>
</li>
<li><p><strong>secondary storage</strong>: next level in hierarchy, non-volatile, moderately fast access time</p>
<p>also called <strong>on-line storage</strong> </p>
<p>E.g. flash memory, magnetic disks</p>
</li>
<li><p><strong>tertiary storage:</strong> lowest level in hierarchy, non-volatile, slow access time</p>
<p>also called <strong>off-line storage</strong> </p>
<p>E.g. magnetic tape, optical storage</p>
</li>
</ul>
</li>
<li><p>磁盘 magnetic disks</p>
<ul>
<li><p>tracks(磁道)  sectors(扇区)</p>
</li>
<li><p>Access Time 访问时间，毫秒级</p>
<ul>
<li>Seek Time 寻道时间：找到对应磁道</li>
<li>Rotational latency 旋转延迟：转到对应扇区</li>
</ul>
</li>
<li><p>Data-transfer rate 数据传输率</p>
</li>
<li><p><em>数据库传输以block为单位</em> </p>
</li>
<li><p>访问模式：</p>
<ul>
<li><p>Sequential access pattern(顺序访问模式)<br>Successive requests are for successive disk blocks<br>Disk seek required only for first block</p>
</li>
<li><p>Random access pattern（随机访问模式）<br>Each access requires a seek<br><em>Transfer rates are low since a lot of time is wasted in seeks</em> </p>
<p><em>尽量转化为顺序访问模式</em> </p>
</li>
<li><p>I&#x2F;O operations per second (IOPS ，每秒I&#x2F;O操作数)</p>
<ul>
<li>衡量磁盘访问速度</li>
<li>Number of random block reads that a disk can support per second<br>50 to 200 IOPS on current generation magnetic disks</li>
</ul>
</li>
</ul>
</li>
<li><p>Mean time to failure (MTTF，平均故障时间)</p>
<ul>
<li>衡量磁盘可靠性</li>
<li>the average time the disk is expected to run continuously without any failure</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘块访问的优化</p>
<ul>
<li><p>Buffering 缓存: in-memory buffer to cache disk blocks</p>
</li>
<li><p>Read-ahead(Prefetch): Read extra blocks from a track in anticipation that they will be requested soon</p>
</li>
<li><p><strong>Disk-arm-scheduling</strong> algorithms re-order block requests so that disk arm movement is minimized </p>
</li>
<li><p>File organization：将碎片化的文件重新整理<br>Allocate blocks of a file in as contiguous a manner as possible<br>Allocation in units of extents(盘区）</p>
</li>
<li><p>Nonvolatile write buffers （非易失性写缓存）</p>
<p>speed up disk writes by writing blocks to a non-volatile RAM buffer immediately</p>
</li>
<li><p>Log disk（日志磁盘）</p>
<p>a disk devoted to writing a sequential log of block updates<br>Used exactly like nonvolatile RAM</p>
</li>
</ul>
</li>
<li><p>Flash Storage</p>
<ul>
<li>NAND flash<ul>
<li>Page can only be written once<br>Must be erased to allow rewrite</li>
</ul>
</li>
<li>SSD(Solid State Disks) <ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607024602936.png" alt="image-20230607024602936"></li>
<li>SSD比磁盘快百倍，磁盘能耗高（机械运动）更新为即席写入</li>
</ul>
</li>
<li>Flash storage 中的地址映射漂移，已达成磨损均衡（wear leveling)</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607024919201.png" alt="image-20230607024919201"></li>
<li>对于大数据，热数据（常访问）放在SSD，冷数据放在磁盘里</li>
</ul>
</li>
<li><p>NVM，又称Storage Class Memory</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607025337181.png" alt="image-20230607025337181"></li>
<li>Persistence可以看出是否易失</li>
<li>NVM和SSD与硬盘不同，用字节寻址</li>
</ul>
</li>
<li><p>随堂测试：</p>
<ul>
<li><p>Which physical storage media is non-volatile?</p>
<p>多选题 (1 分) </p>
<p> A.cache</p>
<p> B.main memory</p>
<p> C.flash memory</p>
<p> D.magnetic disk</p>
<p> E.SSD(State Solid Disk)</p>
<p> F.magnetic tapes</p>
<p> G.optical disk</p>
<p>正确答案: C D E F G</p>
</li>
<li><p>Which physical storage medias belong to the secondary storage? </p>
<p>多选题 (1 分)</p>
<p> A.cache</p>
<p> B.main memory </p>
<p> C.flash memory</p>
<p> D.SSD(Solid State Disk)</p>
<p> E.magnetic disk</p>
<p> F.magnetic tapes</p>
<p> G.optical disk</p>
<p>正确答案: C D E</p>
</li>
<li><p>Which term represents the time that the disk controller takes to reposition the disk arm over the correct track.</p>
<p>单选题 (1 分)</p>
<p> A.access time</p>
<p> B.seek time</p>
<p> C.rotational latency</p>
<p> D.data-transfer rate </p>
<p>正确答案: B</p>
</li>
<li><p>What is the right approach to  optimizing  data access of disks?</p>
<p>多选题 (1 分)</p>
<p> A.Buffering</p>
<p> B.Read-ahead</p>
<p> C.defragment the file system</p>
<p> D.Non-volatile write buffers</p>
<p> E.Log disk</p>
<p>正确答案: A B C D E</p>
</li>
<li><p>MTTF means    1   (注意：每个单词首字母大写).</p>
<p>填空题 (1 分) (请按题目中的空缺顺序依次填写答案)</p>
<p>正确答案: Mean Time To Failure</p>
</li>
<li><p>IOPS  means     1   (注意：每个单词首字母大写).</p>
<p>填空题 (1 分) (请按题目中的空缺顺序依次填写答案)</p>
<p>正确答案: I&#x2F;O Operations Per Second</p>
</li>
</ul>
</li>
</ul>
<h2 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h2><ul>
<li><p>数据库文件存在磁盘里，文件由记录(record)组成，record由各个字段(field)组成</p>
</li>
<li><p>定长记录(Fixed-Length Record)，可以计算每个block可以放多少记录</p>
<ul>
<li>存record i：若长n byte，从n*(i-1) byte开始</li>
<li>删除：不移动 record，记为空记录<ul>
<li>空记录设指针指下一个空的record</li>
<li>头部加上header指向第一条空记录</li>
</ul>
</li>
</ul>
</li>
<li><p>不定长记录(Variable-Length Record)</p>
<ul>
<li>原因：有不定长字符串，有空字段</li>
<li>方法：不定长的全放后面，用(offset,length)记录位置和长度</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607031402403.png" alt="image-20230607031402403"></li>
<li>Null bitmap：有几个属性就有几位，0表示非空，1表示空</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607032222398.png" alt="image-20230607032222398"></li>
<li>插入：指针+长度存记录位置，在free space从后往前插入</li>
<li>删除：相对地址，block_num + index</li>
</ul>
</li>
<li><p>Record组织规则：</p>
<ul>
<li>堆：<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607033306769.png" alt="image-20230607033306769"></li>
<li>维护空闲块的map，记录空闲程度：7即7&#x2F;8的空闲</li>
</ul>
</li>
<li>顺序 Sequential<ul>
<li>插入：插到中间会导致后面的记录全体后移，因此直接放在最后，通过指针串联<ul>
<li>每个一段时间按顺序重整（克服碎片化）</li>
</ul>
</li>
</ul>
</li>
<li>B+树</li>
<li>哈希</li>
</ul>
</li>
<li><p>存放方式：</p>
<ul>
<li>按行存放</li>
<li>按列存放：cache命中率高</li>
</ul>
</li>
<li><p>缓存管理 Buffer manager</p>
<ul>
<li>缓存替换：<ul>
<li>LRU策略（Least Recently Used）最近最少用到</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230607035017615.png" alt="image-20230607035017615"></li>
<li>在for循环等场景，LRU可能是一种坏策略</li>
</ul>
</li>
<li>若访问的block不在缓存，读出到缓冲区</li>
<li>访问请求时，钉在(pin)缓冲区，请求为读时加共享锁，写时加exclusive lock</li>
</ul>
</li>
<li><p>随堂测试：</p>
<ul>
<li><p>What is contained in the header of slotted page? </p>
<p>多选题 (1 分)</p>
<p> A.number of record entries</p>
<p> B.end location of free space in the block</p>
<p> C.location of each record</p>
<p> D.size of each record</p>
<p> E.primary key of each record</p>
<p>正确答案: A B C D</p>
</li>
<li><p>What kind file organization is suitable for applications that require sequential processing of the entire file? </p>
<p>单选题 (1 分)</p>
<p> A.heap file organization</p>
<p> B.sequential file organization</p>
<p> C.multitable clustering file organization</p>
<p> D.hash file organization</p>
<p>正确答案: B</p>
</li>
<li><p>Which statement is incorrect?</p>
<p>多选题 (1 分)</p>
<p> A.For heap file organization, records can be placed anywhere in the file where there is free space.</p>
<p> B.Database system seeks to minimize the number of block transfers between the disk and memory. </p>
<p> C.If the needed block is not in the buffer, the buffer manager will replace some other block, if required, to make space for the new block.</p>
<p> D.LRU is the most suitable replacement strategy for buffer manager in any cases.</p>
<p>正确答案: D</p>
</li>
<li><p>For the buffer manager, there are following assumptions:</p>
<p>• There are 4 buffer pages.</p>
<p>• Initially the buffer is empty occupied.</p>
<p>• The data access sequence is 1,2,3,4,5,4,3,2,1,3,5</p>
<p>According to the LRU replacement strategy, there are    1    times replacements occurred,  and the data item    2    is the least recently used after completing the above data access sequence.</p>
<p>填空题 (1 分) (请按题目中的空缺顺序依次填写答案)</p>
<p>正确答案:</p>
<p>1：3</p>
<p>2：2</p>
</li>
</ul>
</li>
</ul>
<h2 id="索引Indexing"><a href="#索引Indexing" class="headerlink" title="索引Indexing"></a>索引Indexing</h2><ul>
<li><p>Form：search key - pointer</p>
</li>
<li><p>Query type</p>
<ul>
<li><p>Point query: records with a specified value in the attribute</p>
</li>
<li><p>Range query: records with an attribute value falling in a specified range of values.</p>
</li>
</ul>
</li>
<li><p>Primary index 主索引</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160436673.png" alt="image-20230610160436673"></li>
<li>candidate key唯一情况下用起来方便</li>
</ul>
</li>
<li><p>Secondary Indices</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160508100.png" alt="image-20230610160508100"></li>
<li>不唯一，中间的指针指向多个目标</li>
<li></li>
</ul>
</li>
<li><p>Dense index：Index record appears for every search-key value in the file. </p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160725335.png" alt="image-20230610160725335"></li>
</ul>
</li>
<li><p>Sparse index：contains index records for only some search-key values.</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160742907.png" alt="image-20230610160742907"></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610160938171.png" alt="image-20230610160938171"></li>
</ul>
</li>
<li><p>Multilevel Index（多级索引）</p>
<ul>
<li>索引的索引</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610161015946.png" alt="image-20230610161015946"></li>
</ul>
</li>
<li><p>B+ Tree Index</p>
<ul>
<li>每个节点都和block大小一样</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610161325306.png" alt="image-20230610161325306"></li>
<li>叶子结点就是末级索引，之间用指针相连，使连续</li>
<li>高度：$ log_{n}(k)&lt;&#x3D; height &lt;&#x3D;log_{n&#x2F;2}(k&#x2F;2)+1 $，向上取整（根节点最小两叉）</li>
<li>大小：最大：半满，最小：全满</li>
<li>和ADS不同：每个节点容量相等，非叶子和叶子一样（ADS里非叶子最多阶数-1）<ul>
<li>也就是说中间结点的分叉数比叶子结点值数多1</li>
</ul>
</li>
<li>作用：叉数多，层数少，减少seek&amp;block transfer次数</li>
</ul>
</li>
<li><p>估计 height &amp; size</p>
<ul>
<li><p>person( pid char(18) primary key,  </p>
<p>​			name char(8), </p>
<p>​			age smallint,<br>​             address char(40)); </p>
<p>Block size : 4K<br>1000000 persons</p>
</li>
<li><p>Records per block &#x3D;  4096&#x2F;(18+8+2+40) &#x3D;60.235&#x3D;60</p>
<ul>
<li>record 大小根据各个属性类型算</li>
</ul>
</li>
<li><p>blocks for storing 1M persons&#x3D; 1000000&#x2F;60 &#x3D;16667</p>
<ul>
<li>计算block数</li>
</ul>
</li>
<li><p>B+ tree n(fan-out)  &#x3D; (4096-4)&#x2F;(18+4) +1 &#x3D; 187</p>
<ul>
<li><p>B+树一个节点就是一个block，存放M个值和M+1个指针</p>
<p>即使是叶子结点，也多出一个指向下一个叶子的指针</p>
<p>指针比值多一个，所以先-4，后+1</p>
</li>
<li><p>一个索引项&#x3D;索引值+指针(假设4byte)&#x3D;18+4</p>
</li>
<li><p>最大187叉，最少 n&#x2F;2 &#x3D; 94叉</p>
</li>
<li><p>能索引多少值</p>
<ul>
<li><p>2 levels:  min&#x3D;2<code>*</code>93 &#x3D; 186            max&#x3D; 187’<code>*</code>186 &#x3D; 34,782</p>
</li>
<li><p>3 levels:  min&#x3D;2<code>*</code>94<code>*</code>93 &#x3D; 17484        max&#x3D;187<code>*</code>187<code>*</code>186 &#x3D; 6,504,234</p>
</li>
<li><p>4 levels:  min&#x3D;2<code>*</code>94<code>*</code>94<code>*</code>93 &#x3D; 1,643,496</p>
<p>​			   max&#x3D;187<code>*</code>187<code>*</code>187<code>*</code>186 &#x3D; 1,216,291,758</p>
</li>
</ul>
</li>
<li><p>易得这个B+树为3层</p>
</li>
</ul>
</li>
<li><p>size：</p>
<ul>
<li>最小（全满）100000&#x2F;186+100000&#x2F;186&#x2F;187+1</li>
<li>最大（半满）100000&#x2F;93+100000&#x2F;93&#x2F;94+1</li>
</ul>
</li>
</ul>
</li>
<li><p>Bottom-up B+ Tree Build</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610171021418.png" alt="image-20230610171021418"></li>
<li>fanout &#x3D; 4，则阶数为3</li>
<li>先排序，按序分块，然后向上构建</li>
<li>构建上图B+树 cost：1 seek + 9 block transfer</li>
<li>插入大量值&#x2F;合并树可以直接把叶子merge并排序，然后重建</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610171558671.png" alt="image-20230610171558671"></li>
<li>原树的叶子读取：1 seek+6 block transfer</li>
</ul>
</li>
<li><p>Indexing in Main Memory</p>
<ul>
<li>Random access in memory <ul>
<li>Much cheaper than on disk&#x2F;flash, but still expensive compared to cache read</li>
<li>Binary search for a key value within a large B+-tree node results in many <strong>cache misses</strong></li>
<li>Data structures that make best use of cache preferable – <strong>cache conscious</strong></li>
</ul>
</li>
<li>Cache miss<ul>
<li>HD以block为单位读到buffer，buffer以64byte(例)为单位读到cache，大节点就会读不全，查找索引值过程中读取的cache只有小部分有用，没找到-&gt;产生miss</li>
<li>降低miss：<ul>
<li>小节点：B+ trees with small nodes that fit in cache line are preferable to reduce cache misses</li>
<li>指针和search key分开排</li>
<li>建立一个“路标”（一棵小树）</li>
</ul>
</li>
</ul>
</li>
<li>Key idea:  <ul>
<li>use large node size to optimize disk access, </li>
<li>but structure data within a node using a tree with small node size, instead of using an array, to optimize cache access.</li>
</ul>
</li>
</ul>
</li>
<li><p>LSM tree(Log Structured Merge) 写优化的树结构</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610175401820.png" alt="image-20230610175401820"></li>
<li>Benefits of LSM approach<br>Inserts are done using only sequential I&#x2F;O operations 随机写-&gt;顺序写<br>Leaves are full, avoiding space wastage<br>Reduced number of I&#x2F;O operations per record inserted as compared to normal B+-tree (up to some size)</li>
<li>Drawback of LSM approach<br>Queries have to search multiple trees<br>Entire content of each level copied multiple times</li>
</ul>
</li>
<li><p>LSM-Stepped Merge Index</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230610175540871.png" alt="image-20230610175540871"></li>
<li>内存满了直接写到下一层来，disk中这一层满了再merge写到下一层</li>
<li>删除：插入删除标记</li>
<li>更新：删除+插入</li>
</ul>
</li>
<li><p>Buffer Tree</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230619143817724.png" alt="image-20230619143817724"></li>
</ul>
</li>
<li><p>随堂测试</p>
<ul>
<li><p>1.Indexing mechanisms are used to speed up access  to desired data.</p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>2.Range query returns records with an attribute value falling in a specified range of values.</p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>3.Secondary index is an index whose search key specifies an order same as the sequential order of the file. </p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.NO</p>
<p>正确答案: B</p>
</li>
<li><p>4.In an dense index, index record appears for every search-key value in the file. </p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>5.In a B+-tree , all paths from root to leaf are of the same length.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>6.If the root of a B+-tree is not a leaf, it has at least 2 children.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes </p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>7.In databases, a node of a B+-tree is generally the same size as a disk block.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>8.The leaf nodes of a B+-tree file organization store records, instead of pointers to records.</p>
<p> 判断题 (1 分)</p>
<p> A.Yes</p>
<p> B.No</p>
<p>正确答案: A</p>
</li>
<li><p>9.Benefits of LSM approach:</p>
<p> 多选题 (1 分)</p>
<p> A.Inserts are done using only sequential I&#x2F;O operations</p>
<p> B.Leave nodes are full, avoiding space wastage</p>
<p> C.Reduced number of I&#x2F;O operations per record inserted as compared to normal B+-tree.</p>
<p> D.Queries have to search multiple trees</p>
<p> E.Entire content of each level copied multiple times</p>
<p>正确答案: A B C</p>
</li>
<li><p>10.Bitmap indices are useful for queries on multiple attributes,not particularly useful for single attribute queries.</p>
<p>判断题 (1 分)</p>
<p> A.Yes</p>
<p> B. No</p>
<p>正确答案: A</p>
</li>
</ul>
</li>
</ul>
<h2 id="查询处理Query-Processing"><a href="#查询处理Query-Processing" class="headerlink" title="查询处理Query Processing"></a>查询处理Query Processing</h2><ul>
<li><p>Basic Steps in Query Processing</p>
<ul>
<li>Parsing and translation<br>translate the query into its internal form.  This is then translated into relational algebra.<br>Parser checks syntax, verifies relations</li>
<li>Optimization<br>Amongst all equivalent evaluation plans choose the one with lowest cost. </li>
<li>Evaluation<br>The query-execution engine takes a query-evaluation plan, executes that plan, and returns the answers to the query.</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612001751736.png" alt="image-20230612001751736" style="zoom:33%;" /></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612003553870.png" alt="image-20230612003553870"></li>
<li>选择运算尽量先做（往下推）</li>
</ul>
</li>
<li><p>衡量Query</p>
<ul>
<li><p>$ t_s $：number of seek</p>
</li>
<li><p>$ t_t $：number of block transfer(read &amp; write)</p>
</li>
<li><p>Cost for b block transfers plus S seeks</p>
<p>b *  $ t_t $ + S * $ t_s $</p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612004605830.png" alt="image-20230612004605830"></p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612004618669.png" alt="image-20230612004618669"></p>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230612004920316.png" alt="image-20230612004920316"></p>
</li>
</ul>
</li>
<li><p>对select的条件进行排序：外部排序</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618161811420.png" alt="image-20230618161811420"></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618161824886.png" alt="image-20230618161824886"></li>
<li>性能：</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618161847075.png" alt="image-20230618161847075"></li>
<li>$ (b_r&#x2F;M) $ 为归并段数，$ log_{M-1}(b_r&#x2F;M) $ 为轮次，2br为每次的传输消耗，最后一次+br，如果要写回磁盘就+2br。</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618163335699.png" alt="image-20230618163335699"></li>
<li>外部排序（External Merge Sort） 中，给一个段run分配bb 块（而不是1块）作为缓冲，可以减少每轮合并（merge）的seek次数，但也可能增加merge的轮数。对于确定的关系大小br 和确定的内存块数M，理论上应该有一个最佳的bb取值，使得算法代价最小。</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618163544585.png" alt="image-20230618163544585"></li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618164207925.png" alt="image-20230618164207925"></li>
</ul>
</li>
<li><p>Join Operation</p>
<ul>
<li><p>Nested-loop join</p>
<ul>
<li>两重循环</li>
<li>代价：<ul>
<li>nr * bs + br   block transfers</li>
<li>nr + br  seeks</li>
<li>nr是记录数，block中含有多个记录</li>
</ul>
</li>
</ul>
</li>
<li><p>Block nested-loop join</p>
<ul>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618164914151.png" alt="image-20230618164914151"></p>
</li>
<li><p>代价：</p>
<ul>
<li>Worst case estimate:  br * bs + br  block transfers + 2 * br  seeks<br>Each block in the inner relation s is read once for each block in the outer relation</li>
<li>Best case: br + bs block transfers + 2 seeks.（内存足够大，每个表只要进入内存一次）</li>
<li>小关系作为外关系更好</li>
</ul>
</li>
<li><p><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618165335108.png" alt="image-20230618165335108"></p>
</li>
<li><p>内存有M块的情况：留1块作为output的缓存，外关系给M-2块，内关系反正每次要seek，只给1块。</p>
</li>
</ul>
</li>
<li><p>Indexed nested-loop join</p>
<ul>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618170934436.png" alt="image-20230618170934436"></li>
<li>多块就是br&#x2F;(M-2)</li>
<li>外关系小(nr小)的时候选这种方法</li>
</ul>
</li>
<li><p>Merge-join</p>
<ul>
<li>两个关系已经有序</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230618205150053.png" alt="image-20230618205150053"></li>
</ul>
</li>
<li><p>Hash-join</p>
</li>
<li><img src="C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20230619142752872.png" alt="image-20230619142752872" style="zoom: 67%;" /></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/DB%E5%90%8E%E7%AF%87/" data-id="clj2mxxkw0001wgu2feom1phh" data-title="DB后篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/class/" rel="tag">class</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OOP作业题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/OOP%E4%BD%9C%E4%B8%9A%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/OOP%E4%BD%9C%E4%B8%9A%E9%A2%98/">OOP Homework</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h2><p>（ ）不是面向对象程序设计的主要特征。</p>
<p>A.封装</p>
<p>B.继承</p>
<p>C.多态</p>
<p><strong>D.结构</strong></p>
<p>关于C++与C 语言关系的描述中，（ ）是错误的。</p>
<p>A.C 语言是C++语言的一个子集</p>
<p>B.C 语言与C++语言是兼容的</p>
<p>C.C++语言对C 语言进行了一些改进</p>
<p><strong>D.C++语言和C 语言都是面向对象的</strong></p>
<p>下列关于cin和cout的说法中，错误的是____。</p>
<p>A.cin用于读入用户输入的数据</p>
<p>B.cout用于输出数据</p>
<p><strong>C.cin比C语言中的scanf()函数更有优势，它可以读取空格</strong></p>
<p>D.cout通常与&lt;&lt;运算符结合</p>
<p>关于delete运算符的下列描述中，（）是错误的。</p>
<p>A.它必须用于new返回的指针；</p>
<p>B.使用它删除对象时要调用析构函数；</p>
<p><strong>C.对一个指针可以使用多次该运算符；</strong></p>
<p>D.指针名前只有一对方括号符号，不管所删除数组的维数。</p>
<p>以下程序中，new语句干了什么。</p>
<p>int** num;</p>
<p>num &#x3D; new int* [20];</p>
<p>A.分配了长度为20的整数数组空间，并将首元素的指针返回。</p>
<p>B.分配了一个整数变量的空间，并将其初始化为20。</p>
<p><strong>C.分配了长度为20的整数指针数组空间，并将num[0]的指针返回。</strong></p>
<p>D.存在错误，编译不能通过。</p>
<p>以下程序存在的问题是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> *num1, *num2;</span><br><span class="line"> num1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"> num2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];</span><br><span class="line"> num1[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"> num2[<span class="number">0</span>] = <span class="number">300</span>;</span><br><span class="line"> num1 = num2;</span><br><span class="line"> <span class="keyword">delete</span> [] num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A.num2不能给num1赋值</p>
<p>B.num2最初指向的空间没有释放</p>
<p><strong>C.num1最初指向的空间没有释放</strong></p>
<p>D.程序没有问题</p>
<p>关于new 和 delete 关键字功能的叙述，不正确的是（ ）</p>
<p>A.C++程序的内存空间，可以分为代码区(text segment）、静态存储区(Data Segment)、栈区(Stack)、堆区(Heap)。new关键字用于从堆区中动态申请创建对象所需的内存空间。</p>
<p>B.new动态申请内存空间成功后，返回该内存区域的首地址；同时，也会自动调用相关类的构造函数。</p>
<p>C.delete用于删除new建立的对象，并释放指针所指向的内存空间，同时，也会自动调用对象的析构函数。</p>
<p><strong>D.B * ptr&#x3D;new B(5)；delete ptr; 假设上述语句中，new申请的内存空间首地址为Addr,存放ptr指针变量值的内存空间首地址为 PAddr，则执行delete ptr 语句后，Addr、PAddr指向的内存区域均会被系统收回。</strong></p>
<p>用new关键字动态申请一个三维数组，则下列语句正确的是（ ）</p>
<p>A.<code>float *fp; fp= new float[10][25][10];</code></p>
<p><strong>B.<code>float (* fp)[25][10]; fp=new float[10][25][10];</code></strong></p>
<p>C.<code>float (* fp)[10]; fp=new float[10][25][10];</code></p>
<p>D.<code>float *fp [25][10]; fp= new float[10][25][10];</code></p>
<p>下列语句中，不能连续输出3个值的是。</p>
<p>A.cout&lt;&lt;x&lt;&lt;y&lt;&lt;z;</p>
<p><strong>B.cout&lt;&lt;x,y,z;</strong></p>
<p>C.cout&lt;&lt;x; cout&lt;&lt;y; cout&lt;&lt;z;</p>
<p>D.cout&lt;&lt;(x,y,z)&lt;&lt;(x,y,z)&lt;&lt;(x,y,z);</p>
<p>在C++中，cin是（）。</p>
<p>A.预定义的类</p>
<p>B.预定义的函数</p>
<p>C.一个标准的语句</p>
<p><strong>D.预定义的对象</strong></p>
<hr>
<h2 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h2><p>假定AA为一个类，a()为该类公有的函数成员，x为该类的一个对象，则访问x对象中函数成员a()的格式为（）</p>
<p>A.x.a</p>
<p><strong>B.x.a()</strong></p>
<p>C.x-&gt;a()</p>
<p>D.(*x).a()</p>
<p>下列关于类定义的说法中，正确的是</p>
<p><strong>A.类定义中包括数据成员和函数成员的声明</strong></p>
<p>B.类成员的缺省访问权限是保护的</p>
<p>C.数据成员必须被声明为私有的</p>
<p>D.成员函数只能在类体外进行定义</p>
<p>下列关于类和对象的叙述中，错误的是</p>
<p><strong>A.一个类只能有一个对象</strong></p>
<p>B.对象是类的具体实例</p>
<p>C.类是对某一类对象的抽象</p>
<p>D.类和对象的关系是一种数据类型与变量的关系</p>
<p>Resolver <code>::</code> is used to:</p>
<p>A.Define a member function outside class declaration</p>
<p>B.Access a member of a namespace</p>
<p>C.Access a static member of a class</p>
<p><strong>D.All of the others</strong></p>
<p>类的实例化是指（ ）。</p>
<p>A.定义类</p>
<p><strong>B.定义对象</strong></p>
<p>C.调用类的成员函数</p>
<p>D.访问对象的数据成员</p>
<p>C＋＋函数的声明和定义可以分开。函数声明不需要( )。</p>
<p>A.返回类型</p>
<p>B.函数名</p>
<p>C.参数表</p>
<p><strong>D.函数体</strong></p>
<p>首先需要在问题域中识别出若干个（ ）</p>
<p>A.函数</p>
<p><strong>B.类</strong></p>
<p>C.文件</p>
<p>D.过程</p>
<hr>
<h2 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h2><hr>
<h2 id="W4"><a href="#W4" class="headerlink" title="W4"></a>W4</h2><p>若有下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>则执行后程序的输出结果是</p>
<p>A.1</p>
<p>B.2</p>
<p>C.3</p>
<p><strong>D.4</strong></p>
<p>设有定义 <code>vector&lt;string&gt; v(10);</code><br>执行下列哪条语句时会调用构造函数?</p>
<p>A.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[0] += &quot;abc&quot;;</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v[0] = &quot;2018&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>C.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.push_back(&quot;ZUCC&quot;);</span><br></pre></td></tr></table></figure>

<p>D.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (v[1] == &quot;def&quot;);</span><br></pre></td></tr></table></figure>



<p>设有如下代码段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;char *, int&gt; m;</span><br><span class="line">const int MAX_SIZE = 100;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char str[MAX_SIZE];</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; str;</span><br><span class="line">        m[str] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; m.size() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读入10个字符串，则输出的 <code>m.size()</code> 为</p>
<p>A.0</p>
<p><strong>B.1</strong></p>
<p>C.10</p>
<p>下列关于STL的描述中，错误的是。</p>
<p>A.STL的内容从广义上讲分为容器、迭代器、算法三个主要部分</p>
<p>B.STL的一个基本理念就是将数据和操作分离</p>
<p>C.STL中的所有组件都由模板构成，其元素可以是任意类型</p>
<p><strong>D.STL的容器、迭代器、算法是三个完全独立的部分，彼此也无任何联系</strong></p>
<p>下列创建vector容器对象的方法中，错误的是。</p>
<p>A.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v(10);</span><br></pre></td></tr></table></figure>

<p>B.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v(10, 1);</span><br></pre></td></tr></table></figure>

<p>C.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v&#123;10, 1&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>D.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v = (10, 1);</span><br></pre></td></tr></table></figure>



<p>下列选项中，哪一项不是迭代器。</p>
<p>A.输入迭代器</p>
<p>B.前向迭代器</p>
<p>C.双向迭代器</p>
<p><strong>D.删除迭代器</strong></p>
<p>设void f1(int * m，long &amp; n)；int a；long b；则以下调用合法的是（）。</p>
<p>A.f1(a，b)；</p>
<p><strong>B.f1(&amp;a，b)；</strong></p>
<p>C.f1(a，&amp;b)；</p>
<p>D.f1(&amp;a，&amp;b)；</p>
<p>下面程序片段,哪一个是正确的?</p>
<p>A.int n&#x3D;4; int &amp;r&#x3D;n*3;</p>
<p>B.int m&#x3D;5; const int &amp;r&#x3D;m; r&#x3D;6;</p>
<p>C.int n&#x3D;8; const int &amp;p&#x3D;n; int &amp;q&#x3D;p ;</p>
<p><strong>D.int n&#x3D;8; int &amp;p&#x3D;n; const int q&#x3D;p ;</strong></p>
<p>下面程序段 int a&#x3D;1,b&#x3D;2; int &amp;r&#x3D;a; r&#x3D;b; r&#x3D;7; cout&lt;&lt;a&lt;&lt;endl; 的输出结果是?</p>
<p>A.1</p>
<p>B.2</p>
<p><strong>C.7</strong></p>
<p>D.无法确定</p>
<p>已知：float b &#x3D; 34.5； ，则下列表示引用的方法中，正确的是（ ）。</p>
<p><strong>A.float &amp;x &#x3D; b；</strong></p>
<p>B.float &amp;y &#x3D; 34.5；</p>
<p>C.float &amp;z；</p>
<p>D.int &amp;t &#x3D; &amp;b;</p>
<hr>
<h2 id="W5"><a href="#W5" class="headerlink" title="W5"></a>W5</h2><p>在C++语言中引入内联函数（inline function）的主要目的是降低空间复杂度，即缩短目标代码长度。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>主程序调用内联函数（inline）时，不发生控制转移，无需保存和恢复环境变量等，因此，节省了系统开销。内联函数的声明以及最终的生效，是由程序员决定的。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>int Sum (int a,int b&#x3D;5,int c); 这个函数原型的声明没有什么不合适的地方。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>两个以上的函数，具有相同的函数名，且形参的个数或形参的类型不同，或返回的数据类型不同，则称之为函数的重载。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>带有默认值的函数F的函数原型为F(int x&#x3D;5, int x&#x3D;9, int y, float m&#x3D;10.0)，则该函数在编译时会报错。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>如果默认参数的函数声明为“ void fun(int a,int b&#x3D;1,char c&#x3D;’a’,float d&#x3D;3.2);”，<br>则下面调用写法正确的是（ ）。</p>
<p>A.fun();</p>
<p><strong>B.fun(2,3);</strong></p>
<p>C.fun(2, ,’c’,3.14)</p>
<p>D.fun(int a&#x3D;1);</p>
<p>重载函数在调用时选择的依据中，错误的是（）。</p>
<p><strong>A.函数的参数</strong></p>
<p>B.参数的类型</p>
<p>C.函数的名字</p>
<p>D.函数的类型</p>
<p>在（ ）情况下适宜采用inline定义内联函数。</p>
<p>A.函数体含有循环语句</p>
<p>B.函数体含有递归语句</p>
<p><strong>C.函数代码少、频繁调用</strong></p>
<p>D.函数代码多、不常调用</p>
<p>在C++中，关于下列设置缺省参数值的描述中，（）是正确的。</p>
<p>A.不允许设置缺省参数值；</p>
<p><strong>B.在指定了缺省值的参数右边，不能出现没有指定缺省值的参数；</strong></p>
<p>C.只能在函数的定义性声明中指定参数的缺省值；</p>
<p>D.设置缺省参数值时，必须全部都设置；</p>
<p>下面说法正确的是（）。</p>
<p>A.内联函数在运行时是将该函数的目标代码插入每个调用该函数的地方</p>
<p><strong>B.内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方</strong></p>
<p>C.类的内联函数必须在类体内定义</p>
<p>D.类的内联函数必须在类体外通过加关键字inline定义</p>
<p>对定义重载函数的下列要求中，（ ）是错误的。</p>
<p>A.要求参数的个数不同</p>
<p>B.要求参数中至少有一个类型不同</p>
<p><strong>C.要求函数的返回值不同</strong></p>
<p>D.要求参数个数相同时，参数类型不同</p>
<p>当一个函数功能不太复杂，但要求被频繁调用时，选用____。</p>
<p>A.重载函数</p>
<p><strong>B.内联函数</strong></p>
<p>C.递归函数</p>
<p>D.嵌套函数</p>
<p>如有函数定义：void func(int x &#x3D; 0, int y &#x3D; 0){ …. }，则下列函数调用中会出现问题的是____。</p>
<p><strong>A.func(1,2, 3);</strong></p>
<p>B.func(1,2);</p>
<p>C.func(1);</p>
<p>D.func();</p>
<p>以下有关函数的叙述中正确的是（ ）。</p>
<p>A.函数必须返回一个值</p>
<p>B.函数体中必须有return语句</p>
<p><strong>C.两个同名函数，参数表相同而返回值不同不算重载</strong></p>
<p>D.函数执行中形参的改变会改变实参</p>
<p>以下选项中，是正确的函数默认形参设置的是。</p>
<p>A.int fun(int a,int b,int c);</p>
<p><strong>B.int fun(int a,int b,int c&#x3D;1);</strong></p>
<p>C.int fun(int a,int b&#x3D;1,int c);</p>
<p>D.int fun(int a&#x3D;1,int b,int c);</p>
<hr>
<h2 id="W6"><a href="#W6" class="headerlink" title="W6"></a>W6</h2><p>Order of initialization in the initial list is the order of their declaration in the list.</p>
<p>T</p>
<p><strong>F</strong></p>
<p>类的组合关系可以用“Has-A”描述；类间的继承与派生关系可以用“Is-A”描述。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>一个类的友元函数是这个类的成员。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>在C++语言中引入内联函数（inline function）的主要目的是降低空间复杂度，即缩短目标代码长度。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>主程序调用内联函数（inline）时，不发生控制转移，无需保存和恢复环境变量等，因此，节省了系统开销。内联函数的声明以及最终的生效，是由程序员决定的。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>一个函数功能不太复杂，但要求被频繁调用，可选用（ ）。</p>
<p><strong>A.内联函数</strong></p>
<p>B.重载函数</p>
<p>C.递归函数</p>
<p>D.嵌套函数</p>
<p>在（ ）情况下适宜采用inline定义内联函数。</p>
<p>A.函数体含有循环语句</p>
<p>B.函数体含有递归语句</p>
<p><strong>C.函数代码少、频繁调用</strong></p>
<p>D.函数代码多、不常调用</p>
<p>下面说法正确的是（）。</p>
<p>A.内联函数在运行时是将该函数的目标代码插入每个调用该函数的地方</p>
<p><strong>B.内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方</strong></p>
<p>C.类的内联函数必须在类体内定义</p>
<p>D.类的内联函数必须在类体外通过加关键字inline定义</p>
<p>如果默认参数的函数声明为“ void fun(int a,int b&#x3D;1,char c&#x3D;’a’,float d&#x3D;3.2);”，<br>则下面调用写法正确的是（ ）。</p>
<p>A.fun();</p>
<p><strong>B.fun(2,3);</strong></p>
<p>C.fun(2, ,’c’,3.14)</p>
<p>D.fun(int a&#x3D;1);</p>
<p>在C++中，关于下列设置缺省参数值的描述中，（）是正确的。</p>
<p>A.不允许设置缺省参数值；</p>
<p><strong>B.在指定了缺省值的参数右边，不能出现没有指定缺省值的参数；</strong></p>
<p>C.只能在函数的定义性声明中指定参数的缺省值；</p>
<p>D.设置缺省参数值时，必须全部都设置；</p>
<p>决定C++语言中函数的返回值类型的是（）</p>
<p>A.return语句中的表达式类型</p>
<p>B.调用该函数时系统随机产生的类型</p>
<p>C.调用该函数时的主调用函数类型</p>
<p><strong>D.在定义该函数时所指定的数据类型</strong></p>
<p>如有函数定义：void func(int x &#x3D; 0, int y &#x3D; 0){ …. }，则下列函数调用中会出现问题的是____。</p>
<p><strong>A.func(1,2, 3);</strong></p>
<p>B.func(1,2);</p>
<p>C.func(1);</p>
<p>D.func();</p>
<p>以下选项中，是正确的函数默认形参设置的是。</p>
<p>A.int fun(int a,int b,int c);</p>
<p><strong>B.int fun(int a,int b,int c&#x3D;1);</strong></p>
<p>C.int fun(int a,int b&#x3D;1,int c);</p>
<p>D.int fun(int a&#x3D;1,int b,int c);</p>
<p>对于以下关于友元的说法</p>
<p>A.如果函数fun被声明为类A的友元函数，则该函数成为A的成员函数</p>
<p>B.如果函数fun被声明为类A的友元函数，则该函数能访问A的保护成员，但不能访问私有成员</p>
<p>C.如果函数fun被声明为类A的友元函数，则fun的形参类型不能是A。</p>
<p><strong>D.以上答案都不对</strong></p>
<p>对于类之间的友元关系：</p>
<p>A.如果类A是类B的友元，则B的成员函数可以访问A的私有成员</p>
<p>B.如果类A是类B的友元，则B也是A的友元。</p>
<p>C.如果类A是类B的友元，并且类B是类C的友元，则类A也是类C的友元。</p>
<p><strong>D.以上答案都不对。</strong></p>
<p>友元的作用是</p>
<p><strong>A.提高程序的运用效率</strong></p>
<p>B.加强类的封装性</p>
<p>C.实现数据的隐藏性</p>
<p>D.增加成员函数的种类</p>
<p>下面关于友元的描述中，错误的是：</p>
<p>A.友元函数可以访问该类的私有数据成员</p>
<p>B.一个类的友元类中的成员函数都是这个类的友元函数</p>
<p>C.友元可以提高程序的运行效率</p>
<p><strong>D.类与类之间的友元关系可以继承</strong></p>
<p>已知类A是类B的友元，类B是类C的友元，则：</p>
<p>A.类A一定是类C的友元</p>
<p>B.类C一定是类A的友元</p>
<p>C.类C的成员函数可以访问类B的对象的任何成员</p>
<p><strong>D.类A的成员函数可以访问类B的对象的任何成员</strong></p>
<p>不属于类的成员函数的是（ ） 。</p>
<p>A.构造函数</p>
<p>B.析构函数</p>
<p><strong>C.友元函数</strong></p>
<p>D.复制构造函数</p>
<p>若类A被说明成类B的友元，则（ ） 。</p>
<p>A.类A的成员即类B的成员</p>
<p>B.类B的成员即类A的成员</p>
<p>C.类A的成员函数不能访问类B的成员</p>
<p><strong>D.类B不一定是类A的友元</strong></p>
<p>在下列关键字中,用以说明类中公有成员的是（ ）。</p>
<p><strong>A.public</strong></p>
<p>B.private</p>
<p>C.protected</p>
<p>D.friend</p>
<p>Suppose a class is defined without any keywords such as public, private and protected，all members default to</p>
<p>A.public</p>
<p>B.protected</p>
<p><strong>C.private</strong></p>
<p>D.static</p>
<p>Who can access a private member of a class?</p>
<p>A.Only member functions of that class.</p>
<p><strong>B.Only member functions of that class and friend functions or member functions of friend classes</strong></p>
<p>C.Only member functions of that class and derived classes</p>
<p>D.None of the others</p>
<p>静态成员函数没有：</p>
<p>A.返回值</p>
<p><strong>B.this指针</strong></p>
<p>C.指针参数</p>
<p>D.返回类型</p>
<p>For the code below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  static int i;</span><br><span class="line">  //...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Which statement is NOT true?</p>
<p><strong>A.All objects of class A reserve a space for i</strong></p>
<p>B.All objects of class A share the space of i</p>
<p>C.i is a member variable of class A</p>
<p>D.i is allocated in global data space</p>
<hr>
<h2 id="W7"><a href="#W7" class="headerlink" title="W7"></a>W7</h2><p>In C++, inheritance allows a derived class to directly access all of the functions and data of its base class.</p>
<p>T</p>
<p><strong>F</strong></p>
<p>One class can have more than one super classes.</p>
<p><strong>T</strong></p>
<p>F</p>
<p>write the output of the code below.</p>
<p>1.the output at &#x2F;&#x2F;1 is <code>1</code></p>
<p>2.the output at &#x2F;&#x2F;2 is <code>2</code></p>
<p>3.the output at &#x2F;&#x2F;3 is <code>7</code></p>
<p>4.the output at &#x2F;&#x2F;4 is <code>0</code></p>
<p>5.the output at &#x2F;&#x2F;5 is <code>0</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Testing</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string words; </span><br><span class="line">    <span class="type">int</span> number ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Testing</span>(<span class="type">const</span> string &amp; s = <span class="string">&quot;Testing&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        words = s ;</span><br><span class="line">        number = words.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">compare</span>(<span class="string">&quot;Testing&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (words.<span class="built_in">compare</span>(<span class="string">&quot;Heap1&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Testing</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Testing *pc1 , *pc2;</span><br><span class="line">    pc1 = <span class="keyword">new</span> Testing ;          <span class="comment">//1</span></span><br><span class="line">    pc2 = <span class="keyword">new</span> <span class="built_in">Testing</span>(<span class="string">&quot;Heap1&quot;</span>);  <span class="comment">//2</span></span><br><span class="line">    pc1-&gt;<span class="built_in">show</span>();   <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">delete</span> pc1 ;   <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">delete</span> pc2 ;   <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>For the code segment below, in the main(),</p>
<ol>
<li>the output at &#x2F;&#x2F;1 is <code>114</code></li>
<li>the output at &#x2F;&#x2F;2 is <code>303062</code></li>
<li>the output at &#x2F;&#x2F;3 is <code>115</code></li>
<li>the output at &#x2F;&#x2F;4 is <code>303062</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> ii=<span class="number">0</span>):<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        i = a.i;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="number">3</span> &lt;&lt; i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    A a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> ii = <span class="number">0</span>) : <span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp; b) &#123;</span><br><span class="line">        i = b.i;</span><br><span class="line">        cout &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        A::<span class="built_in">print</span>();</span><br><span class="line">        a.<span class="built_in">print</span>();</span><br><span class="line">        cout &lt;&lt; <span class="number">6</span> &lt;&lt; i;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;        <span class="comment">//1</span></span><br><span class="line">    b.<span class="built_in">print</span>();    <span class="comment">//2</span></span><br><span class="line">    <span class="function">B <span class="title">c</span><span class="params">(b)</span></span>;        <span class="comment">//3</span></span><br><span class="line">    c.<span class="built_in">print</span>();    <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="W8"><a href="#W8" class="headerlink" title="W8"></a>W8</h2><p>虚函数是用virtual 关键字说明的成员函数。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>将构造函数说明为纯虚函数是没有意义的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>抽象类是指一些没有说明对象的类。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>动态绑定是在运行时选定调用的成员函数的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>因为静态成员函数不能是虚函数，所以它们不能实现多态。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>类的组合关系可以用“Has-A”描述；类间的继承与派生关系可以用“Is-A”描述。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>虚函数具有继承性。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>静态成员函数可以声明为虚函数。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针），只能通过派生类继承实现。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>Which one is the characteristic of abstract class?</p>
<p>A.May have virtual functions</p>
<p>B.May have constructors overloaded</p>
<p>C.May have friend function</p>
<p><strong>D.Can not make instance of this class</strong></p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    A() &#123;&#125;;</span><br><span class="line">    virtual f() &#123;&#125;;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>which statement is NOT true:</p>
<p>A.i is private</p>
<p>B.f() is an inline function</p>
<p>C.i is a member of class A</p>
<p><strong>D.sizeof(A) &#x3D;&#x3D; sizeof(int)</strong></p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    A() &#123;&#125;</span><br><span class="line">    virtual f() = 0;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>which statement below is <strong>NOT</strong> true:</p>
<p>A.i is private</p>
<p>B.Objects of class A can not be created</p>
<p>C.i is a member of class A</p>
<p><strong>D.sizeof(A) &#x3D;&#x3D; sizeof(int)</strong></p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line">    int i;</span><br><span class="line">    virtual void f() &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If sizeof(int *) &#x3D;&#x3D; sizeof(int) &#x3D;&#x3D; 4, then sizeof(X)&#x3D;&#x3D;?</p>
<p>A.4</p>
<p>B.6</p>
<p><strong>C.8</strong></p>
<p>D.Undetermined</p>
<p>如果一个类至少有一个纯虚函数，那么就称该类为（）。</p>
<p><strong>A.抽象类</strong></p>
<p>B.虚函数</p>
<p>C.派生类</p>
<p>D.具体类</p>
<p>假设A为抽象类，下列声明（）是正确的。</p>
<p>A.A fun(int);</p>
<p>*<em>B.A <em>p;</em></em></p>
<p>C.int fun(A);</p>
<p>D.A Obj;</p>
<p>在创建派生类对象时，构造函数的执行顺序是( )。</p>
<p>A.对象成员构造函数、基类构造函数、派生类本身的构造函数</p>
<p><strong>B.基类构造函数、对象成员构造函数、派生类本身的构造函数</strong></p>
<p>C.基类构造函数、派生类本身的构造函数、对象成员构造函数</p>
<p>D.派生类本身的构造函数、基类构造函数、对象成员构造函数</p>
<p>派生类中的私有成员</p>
<p>若采用私有继承方式，则派生类对象中的私有成员不可能为 ▁▁▁▁▁。</p>
<p><strong>A.基类中定义的私有成员</strong></p>
<p>B.基类中定义的保护成员</p>
<p>C.基类中定义的公有成员</p>
<p>D.派生类中新增的私有成员</p>
<p>以下说法正确的是？</p>
<p>A.在虚函数中不能使用this指针</p>
<p><strong>B.在构造函数中调用虚函数，不是动态联编</strong></p>
<p>C.抽象类的成员函数都是纯虚函数</p>
<p>D.构造函数和析构函数都不能是虚函数</p>
<hr>
<h2 id="W9"><a href="#W9" class="headerlink" title="W9"></a>W9</h2><p>当用一个对象去初始化同类的另一个对象时,要调用拷贝构造函数。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>对象间赋值将调用拷贝构造函数。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>下列各类函数中，不是类的成员函数的是</p>
<p>A.构造函数</p>
<p>B.析构函数</p>
<p><strong>C.友元函数</strong></p>
<p>D.拷贝构造函数</p>
<p>设类AA已定义，假设以下语句全部合法，哪些语句会触发调用拷贝构造函数（ ）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AA a, b; //1</span><br><span class="line">AA c(10, 20); //2</span><br><span class="line">AA d(c); //3</span><br><span class="line">AA e = d; //4</span><br></pre></td></tr></table></figure>

<p>A.2</p>
<p>B.3</p>
<p>C.4</p>
<p><strong>D.3 和 4</strong></p>
<p>假设MyClass是一个类，则该类的拷贝初始化构造函数的声明语句为（ ）</p>
<p>A.MyClass&amp;(MyClass x);</p>
<p>B.MyClass(MyClass x);</p>
<p><strong>C.MyClass(MyClass &amp;x);</strong></p>
<p>D.MyClass(MyClass *x);</p>
<p>下列关于异常类的说法中，错误的是。</p>
<p><strong>A.异常类由标准库提供，不可以自定义</strong></p>
<p>B.C++的异常处理机制具有为抛出异常前构造的所有局部对象自动调用析构函数的能力</p>
<p>C.若catch块采用异常类对象接收异常信息，则在抛出异常时将通过拷贝构造函数进行对象复制，异常处理完后才将两个异常对象进行析构，释放资源</p>
<p>D.异常类对象抛出后，catch块会用类对象引用接收它以便执行相应的处理动作</p>
<p>下列哪一个说法是错误的?</p>
<p>A.当用一个对象去初始化同类的另一个对象时,要调用拷贝构造函数</p>
<p>B.如果某函数有一个参数是类A的对象,那么该函数被调用时,类A的拷贝构造函数将被调用</p>
<p>C.如果函数的返回值是类A的对象时，则函数返回时，类A的拷贝构造函数将被调用</p>
<p><strong>D.拷贝构造函数必须自己编写</strong></p>
<p>假设A是一个类的名字,下面哪段程序不会用到A的拷贝构造函数？</p>
<p><strong>A.A a1,a2; a1&#x3D;a2;</strong></p>
<p>B.void func( A a) { cout&lt;&lt;”good”&lt;&lt; endl; }</p>
<p>C.A func() { A tmp; return tmp;}</p>
<p>D.A a1; A a2(a1);</p>
<p>如果某函数的返回值是个对象 ，则该函数被调用时，返回的对象？</p>
<p><strong>A.是通过拷贝构造函数初始化的</strong></p>
<p>B.是通过无参数的构造函数初始化的</p>
<p>C.用哪个构造函数初始化，取决于函数中return 语句是怎么写的</p>
<p>D.不需要初始化</p>
<hr>
<h2 id="W11"><a href="#W11" class="headerlink" title="W11"></a>W11</h2><p>多数运算符可以重载，个别运算符不能重载，运算符重载是通过函数定义实现的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>对每个可重载的运算符来讲，它既可以重载为友元函数，又可以重载为成员函数，还可以重载为非成员函数。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>对单目运算符重载为友元函数时，可以说明一个形参。而重载为成员函数时，不能显式说明形参。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>重载运算符可以保持原运算符的优先级和结合性不变。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>预定义的提取符和插入符是可以重载的。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>重载operator+时，返回值的类型应当与形参类型一致。<br>比如以下程序中，operator+的返回值类型有错：</p>
<p>class A {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br></pre></td></tr></table></figure>

<p>public:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A(int t=0):x(t)&#123;     &#125;</span><br><span class="line"></span><br><span class="line">   int operator+(const A&amp; a1)&#123; return x+a1.x;  &#125;</span><br></pre></td></tr></table></figure>

<p>};</p>
<p>T</p>
<p><strong>F</strong></p>
<p>重载关系运算符一般都返回true或false值。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>The operator <code>::</code> can not be overloaded.</p>
<p><strong>T</strong></p>
<p>F</p>
<p>若重载为友元函数，函数定义格式如下：</p>
<p>&lt;类型&gt;operator&lt;运算符&gt;（&lt;参数列表&gt;）</p>
<p>{</p>
<p>&lt;函数体&gt;</p>
<p>}</p>
<p>T</p>
<p><strong>F</strong></p>
<p>下列运算符中，（ ）运算符不能重载。</p>
<p>A.＆＆</p>
<p>B.[ ]</p>
<p><strong>C.::</strong></p>
<p>D.&lt;&lt;</p>
<p>下列关于运算符重载的描述中，（ ）是正确的。</p>
<p>A.运算符重载可以改变操作数的个数</p>
<p>B.运算符重载可以改变优先级</p>
<p>C.运算符重载可以改变结合性</p>
<p><strong>D.运算符重载不可以改变语法结构</strong></p>
<p>为了能出现在赋值表达式的左右两边，重载的”[]”运算符应定义为：</p>
<p>A.A operator [ ] (int);</p>
<p><strong>B.A&amp; operator [ ] (int);</strong></p>
<p>C.const A operator [ ] (int);</p>
<p>D.以上答案都不对</p>
<p>在C++中不能重载的运算符是</p>
<p><strong>A.?:</strong></p>
<p>B.+</p>
<p>C.-</p>
<p>D.&lt;&#x3D;</p>
<p>下列关于运算符重载的表述中，正确的是（）。</p>
<p>A.C++已有的任何运算符都可以重载</p>
<p>B.运算符函数的返回类型不能声明为基本数据类型</p>
<p><strong>C.在类型转换符函数的定义中不需要声明返回类型</strong></p>
<p>D.可以通过运算符重载来创建C++中原来没有的运算符</p>
<p>能用友元函数重载的运算符是（）。</p>
<p><strong>A.+</strong></p>
<p>B.&#x3D;</p>
<p>C.[]</p>
<p>D.-&gt;</p>
<p>下列哪一项说法是不正确的?</p>
<p>A.运算符重载的实质是函数重载</p>
<p>B.运算符重载可以重载为普通函数,也成员可以重载为成员函数</p>
<p>C.运算符被多次重载时,根据实参的类型决定调用哪个运算符重载函数</p>
<p><strong>D.运算符被多次重载时,根据函数类型决定调用哪个重载函数</strong></p>
<p>如何区分自增运算符重载的前置形式和后置形式？</p>
<p>A.重载时，前置形式的函数名是++operator，后置形式的函数名是operator ++</p>
<p><strong>B.后置形式比前置形式多一个 int 类型的参数</strong></p>
<p>C.无法区分，使用时不管前置形式还是后置形式，都调用相同的重载函数</p>
<p>D.前置形式比后置形式多一个 int 类型的参数</p>
<p>下列关于运算符重载的描述正确的是（ ）。</p>
<p>A.运算符重载可以改变操作数的个数</p>
<p>B.可以创造新的运算符</p>
<p><strong>C.运算符可以重载为友元函数</strong></p>
<p>D.任意运算符都可以重载</p>
<p>在重载一个运算符时，如果其参数表中有一个参数，则说明该运算符是( )。</p>
<p>A.一元成员运算符</p>
<p>B.二元成员运算符</p>
<p>C.一元友元运算符</p>
<p><strong>D.二元成员运算符或一元友元运算符</strong></p>
<p>下列关于运算符重载的描述中，错误的是（）。</p>
<p>A.运算符重载不改变优先级</p>
<p><strong>B.运算符重载后，原来运算符操作不可再用</strong></p>
<p>C.运算符重载不改变结合性</p>
<p>D.运算符重载函数的参数个数与重载方式有关</p>
<p>若需要为xv类重载乘法运算符,运算结果为xv类型,在将其声明为类的成员函数时,下列原型声明正确的是_________。</p>
<p>A.xv*(xv);</p>
<p>B.operator*(xv);</p>
<p><em><em>C.xv operator</em>(xv);</em>*</p>
<p>D.xv operator*(xv,xv);</p>
<p>下列运算符中，不可以重载的是（ ）。</p>
<p>A.new</p>
<p>B.++</p>
<p><strong>C..</strong>*</p>
<p>D.[]</p>
<hr>
<h2 id="W13"><a href="#W13" class="headerlink" title="W13"></a>W13</h2><p>pair类模板的作用是将两个数据组成一个数据，用来表示一个二元组或一个元素对，两个数据可以是同一个类型也可以是不同的类型。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>现有声明：</p>
<p>template</p>
<p>class Test{…};</p>
<p>则以下哪一个声明不可能正确。</p>
<p><strong>A.Test a;</strong></p>
<p>B.Test &lt; int&gt; a;</p>
<p>C.Test &lt; float&gt; a;</p>
<p>D.Test&lt; Test &lt; int&gt; &gt; a;</p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt; class T &gt;</span><br><span class="line">void swap( T&amp; x, T&amp; y ) &#123;</span><br><span class="line">   T temp = x;</span><br><span class="line">   x = y;</span><br><span class="line">   y = temp;</span><br><span class="line">&#125;</span><br><span class="line">int i,j;</span><br><span class="line">float f,m;</span><br></pre></td></tr></table></figure>

<p>Which statement is incorrect?</p>
<p>A.swap(i,j);</p>
<p>B.swap(j,i);</p>
<p>C.swap(f,m)</p>
<p><strong>D.swap(i,f);</strong></p>
<p>Given:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void f(int i) &#123; cout &lt;&lt; &quot;Func1&quot; &lt;&lt; endl; &#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T t) &#123; cout &lt;&lt; &quot;Func2&quot; &lt;&lt; endl; &#125;</span><br><span class="line">main() &#123;</span><br><span class="line">    f(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The result is :</p>
<p><strong>A.Func1</strong></p>
<p>B.Func2</p>
<p>C.<code>*nothing*</code></p>
<p>D.undetermined</p>
<p>下列的模板说明中，正确的是。</p>
<p>A.template &lt; typename T1, T2 &gt;</p>
<p>B.template &lt; class T1, T2 &gt;</p>
<p><strong>C.template &lt; typename T1, typename T2 &gt;</strong></p>
<p>D.template ( typedef T1, typedef T2 )</p>
<p>关于类模板，描述错误的是。</p>
<p><strong>A.一个普通基类不能派生类模板</strong></p>
<p>B.类模板可以从普通类派生，也可以从类模板派生</p>
<p>C.根据建立对象时的实际数据类型，编译器把类模板实例化为模板类</p>
<p>D.函数的类模板参数需生成模板类并通过构造函数实例化</p>
<p>建立类模板对象的实例化过程为。</p>
<p>A.基类-派生类</p>
<p>B.构造函数-对象</p>
<p><strong>C.模板类-对象</strong></p>
<p>D.模板类-模板函数</p>
<p>下列有关模板的描述，错误的是____。</p>
<p>A.模板把数据类型作为一个设计参数，称为参数化程序设计</p>
<p>B.使用时，模板参数与函数参数相同，是按位置而不是名称对应的</p>
<p>C.模板参数表中可以有类型参数和非类型参数</p>
<p><strong>D.类模板与模板类是同一个概念</strong></p>
<p>模板函数的真正代码是在哪个时期产生的____。</p>
<p>A.源程序中声明函数时</p>
<p>B.源程序中定义函数时</p>
<p><strong>C.源程序中调用函数时</strong></p>
<p>D.运行执行函数时</p>
<p>类模板的使用实际上是将类模板实例化成一个____。</p>
<p>A.函数</p>
<p>B.对象</p>
<p><strong>C.类</strong></p>
<p>D.抽象类</p>
<p>声明模板的关键字为____。</p>
<p>A.static</p>
<p><strong>B.template</strong></p>
<p>C.typename</p>
<p>D.class</p>
<p>下列对模板的声明，正确的是____。</p>
<p>A.template<T></p>
<p>B.template&lt;class T1, T2&gt;</p>
<p><strong>C.template&lt;class T1, class T2&gt;</strong></p>
<p>D.template&lt;class T1, class T1&gt;</p>
<p>下列选项中，哪一项是类模板实例化的时期____。</p>
<p><strong>A.在编绎时期进行</strong></p>
<p>B.属于动态联编</p>
<p>C.在运行时进行</p>
<p>D.在连接时进行</p>
<p>下列选项中，哪一个函数可以定义为对许多数据类型完成同一任务____。</p>
<p><strong>A.函数模板</strong></p>
<p>B.递归函数</p>
<p>C.模板函数</p>
<p>D.重载函数</p>
<p>一个____允许用户为类定义一种模式，使得类中的某些数据成员及某些成员函数的返回值能取任意类型。</p>
<p>A.函数模板</p>
<p>B.模板函数</p>
<p><strong>C.类模板</strong></p>
<p>D.模板类</p>
<p>下列关于pair&lt;&gt;类模板的描述中，错误的是。</p>
<p>A.pair&lt;&gt;类模板定义头文件utility中</p>
<p>B.pair&lt;&gt;类模板作用是将两个数据组成一个数据，两个数据可以是同一个类型也可以是不同的类型</p>
<p><strong>C.创建pair&lt;&gt;对象只能调用其构造函数</strong></p>
<p>D.pair&lt;&gt;类模拟提供了两个成员函数first与second来访问这的两个数据</p>
<p>模板的使用是为了（）。</p>
<p><strong>A.提高代码的可重用性</strong></p>
<p>B.提高代码的运行效率</p>
<p>C.加强类的封装性</p>
<p>D.实现多态性</p>
<p>假设声明了一下的函数模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">T max(T x, T y)</span><br><span class="line">&#123;</span><br><span class="line">    return  (x&gt;y)?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并定义了int i; char c;<br>错误的调用语句是（）。</p>
<p>A.max(i,i);</p>
<p>B.max(c,c);</p>
<p>C.max((int)c,i);</p>
<p><strong>D.max(i,c);</strong></p>
<hr>
<h2 id="W14"><a href="#W14" class="headerlink" title="W14"></a>W14</h2><p>If you are not interested in the contents of an exception object, the catch block parameter may be omitted.。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>catch (type p) acts very much like a parameter in a function. Once the exception is caught, you can access the thrown value from this parameter in the body of a catch block.。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>异常处理的catch{ }语句块必须紧跟try{ }语句块之后，这两个语句之间不能插入另外语句。</p>
<p><strong>T</strong></p>
<p>F</p>
<p>有如下语句序列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第1行：    int a=1;</span><br><span class="line">第2行：    try&#123;</span><br><span class="line">第3行：       if(a==1) throw(a);</span><br><span class="line">第4行：       a++;</span><br><span class="line">第5行：    &#125;</span><br><span class="line">第6行：    catch(int b)&#123;</span><br><span class="line">第7行：       cout &lt;&lt; “error! a = ” &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">第8行：    &#125;</span><br></pre></td></tr></table></figure>

<p>以上语句的第6行有编译错误，只能写成catch(int)。</p>
<p>T</p>
<p><strong>F</strong></p>
<p>One of the major features in C++ is （ ） handling,which is a better way of handling errors.</p>
<p>A.data</p>
<p>B.pointer</p>
<p>C.test</p>
<p><strong>D.exception</strong></p>
<p>What is wrong in the following code?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v[0] = 2.5;</span><br></pre></td></tr></table></figure>

<p>A.The program has a compile error because there are no elements in the vector.</p>
<p>B.The program has a compile error because you cannot assign a double value to v[0].</p>
<p><strong>C.The program has a runtime error because there are no elements in the vector.</strong></p>
<p>D.The program has a runtime error because you cannot assign a double value to v[0].</p>
<p>If you enter 1 0, what is the output of the following code?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Read two integers</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter two integers: &quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> number1, number2;</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; number1 &gt;&gt; number2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (number2 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> number1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; number1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; number2 &lt;&lt; <span class="string">&quot; is &quot;</span></span><br><span class="line">      &lt;&lt; (number1 / number2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (<span class="type">int</span> e)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A&quot;</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A.A</p>
<p>B.B</p>
<p>C.C</p>
<p><strong>D.AB</strong></p>
<p>The function what() is defined in ______________.</p>
<p><strong>A.exception</strong></p>
<p>B.runtime_error</p>
<p>C.overflow_error</p>
<p>D.bad_exception</p>
<p>Which of the following statements are true?</p>
<p><strong>A.A custom exception class is just like a regular class.</strong></p>
<p>B.A custom exception class must always be derived from class exception.</p>
<p>C.A custom exception class must always be derived from a derived class of class exception.</p>
<p>D.A custom exception class must always be derived from class runtime_error.</p>
<p>Suppose Exception2 is derived from Exception1. Analyze the following code.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">statement1;</span><br><span class="line"></span><br><span class="line">statement2;</span><br><span class="line"></span><br><span class="line">statement3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception1 ex1)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception2 ex2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>A.If an exception of the Exeception2 type occurs, this exception is caught by the first catch block.</strong></p>
<p>B.If an exception of the Exeception2 type occurs, this exception is caught by the second catch block.</p>
<p>C.The program has a compile error because these two catch blocks are in wrong order.</p>
<p>D.The program has a runtime error because these two catch blocks are in wrong order.</p>
<p>Suppose that statement2 throws an exception of type Exception2 in the following statement:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">statement1;</span><br><span class="line">statement2;</span><br><span class="line">statement3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception1 ex1)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception2 ex2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception3 ex3)</span><br><span class="line">&#123;</span><br><span class="line">statement4;</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line">statement5;</span><br></pre></td></tr></table></figure>

<p>A.statement2</p>
<p>B.statement3</p>
<p>C.statement4</p>
<p><strong>D.statement5</strong></p>
<p>Suppose that statement3 throws an exception of type Exception3 in the following statement:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">statement1;</span><br><span class="line">statement2;</span><br><span class="line">statement3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception1 ex1)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception2 ex2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (Exception3 ex3)</span><br><span class="line">&#123;</span><br><span class="line">statement4;</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statement5;</span><br></pre></td></tr></table></figure>

<p>Which statements are executed after statement3 is executed?</p>
<p>A.statement2</p>
<p>B.statement3</p>
<p><strong>C.statement4</strong></p>
<p>D.statement5</p>
<p>下列关于异常处理的说法不正确的是（ ）。</p>
<p>A.异常处理的throw与catch通常不在同一个函数中，实现异常检测与异常处理的分离。</p>
<p>B.catch语句块必须跟在try语句块的后面，一个try语句块后可以有多个catch语句块。</p>
<p><strong>C.在对函数进行异常规范声明时，若形参表后没有任何表示抛出异常类型的说明，它表示该函数不能抛出任何异常。</strong></p>
<p>D.catch语句块中，catch(…)表示该catch可以捕捉任意类型的异常，必须将catch(…)放在catch结构的最后。</p>
<p>以下关于异常处理的描述错误的是（）。</p>
<p>A.C++程序中出现异常时，编译器不会进行提示</p>
<p>B.将可能产生异常的代码放在try语句块内</p>
<p>C.使用catch关键字接收并处理异常</p>
<p><strong>D.重抛异常可以在try语句块或者catch语句块中调用throw实现</strong></p>
<p>下列关于异常的描述中，错误的是（）。</p>
<p><strong>A.编译错属于异常，可以抛出</strong></p>
<p>B.运行错属于异常</p>
<p>C.硬件故障也可当异常抛出</p>
<p>D.只要是编程者认为是异常的都可当异常抛出</p>
<p>下列关于异常类的说法中，错误的是。</p>
<p><strong>A.异常类由标准库提供，不可以自定义</strong></p>
<p>B.C++的异常处理机制具有为抛出异常前构造的所有局部对象自动调用析构函数的能力</p>
<p>C.若catch块采用异常类对象接收异常信息，则在抛出异常时将通过拷贝构造函数进行对象复制，异常处理完后才将两个异常对象进行析构，释放资源</p>
<p>D.异常类对象抛出后，catch块会用类对象引用接收它以便执行相应的处理动作</p>
<p>下列关于重抛异常的描述中，错误的是。</p>
<p>A.处理不了的异常，可以通过在catch结构中调用throw重新抛出异常，将当前异常传递到外部的try-catch结构中</p>
<p>B.重抛异常时只能从catch语句块或从catch块中的调用函数中完成</p>
<p><strong>C.重抛的异常可以被同一个catch语句捕捉</strong></p>
<p>D.可以单独使用throw关键字完成异常重抛</p>
<p>下列关于断言的描述中，错误的是。</p>
<p>A.断言是调试程序的一种手段</p>
<p>B.若断言情况发生，一般会终止程序</p>
<p>C.在C++中，宏assert()用来在调试阶段实现断言</p>
<p><strong>D.断言在程序调试与发布版本中都可以使用断言</strong></p>
<p>C++处理异常的机制是由（）3部分组成。</p>
<p>A.编辑、编译和运行</p>
<p><strong>B.检查、抛出和捕获</strong></p>
<p>C.编辑、编译和捕获</p>
<p>D.检查、抛出和运行</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/OOP%E4%BD%9C%E4%B8%9A%E9%A2%98/" data-id="cljmaqts60001vku29en8913r" data-title="OOP Homework" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/class/" rel="tag">class</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-OOP后篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/30/OOP%E5%90%8E%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2023-05-29T16:00:00.000Z" itemprop="datePublished">2023-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/30/OOP%E5%90%8E%E7%AF%87/">oop后篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C-文件和流"><a href="#C-文件和流" class="headerlink" title="C++ 文件和流"></a>C++ 文件和流</h1><p>到目前为止，我们已经使用了 <strong>iostream</strong> 标准库，它提供了 <strong>cin</strong> 和 <strong>cout</strong> 方法分别用于从标准输入读取流和向标准输出写入流。</p>
<p>本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 <strong>fstream</strong>，它定义了三个新的数据类型：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ofstream</td>
<td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td>
</tr>
<tr>
<td align="left">ifstream</td>
<td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td>
</tr>
<tr>
<td align="left">fstream</td>
<td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td>
</tr>
</tbody></table>
<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <iostream> 和 <fstream>。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。<strong>ofstream</strong> 和 <strong>fstream</strong> 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 <strong>ifstream</strong> 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void open(const char *filename, ios::openmode mode);</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>open()</strong> 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>
<table>
<thead>
<tr>
<th align="left">模式标志</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ios::app</td>
<td align="left">追加模式。所有写入都追加到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::ate</td>
<td align="left">文件打开后定位到文件末尾。</td>
</tr>
<tr>
<td align="left">ios::in</td>
<td align="left">打开文件用于读取。</td>
</tr>
<tr>
<td align="left">ios::out</td>
<td align="left">打开文件用于写入。</td>
</tr>
<tr>
<td align="left">ios::trunc</td>
<td align="left">如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</td>
</tr>
</tbody></table>
<p>您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );</span><br></pre></td></tr></table></figure>

<p>类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifstream  afile;</span><br><span class="line">afile.open(&quot;file.dat&quot;, ios::out | ios::in );</span><br></pre></td></tr></table></figure>

<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void close();</span><br></pre></td></tr></table></figure>

<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 <strong>ofstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cout</strong> 对象。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 <strong>ifstream</strong> 或 <strong>fstream</strong> 对象，而不是 <strong>cin</strong> 对象。</p>
<h2 id="读取-amp-写入实例"><a href="#读取-amp-写入实例" class="headerlink" title="读取 &amp; 写入实例"></a>读取 &amp; 写入实例</h2><p>下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 以写模式打开文件</span></span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Writing to the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your name: &quot;</span>; </span><br><span class="line">   cin.<span class="built_in">getline</span>(data, <span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Enter your age: &quot;</span>; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.<span class="built_in">ignore</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 再次向文件写入用户输入的数据</span></span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   outfile.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 以读模式打开文件</span></span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.<span class="built_in">open</span>(<span class="string">&quot;afile.dat&quot;</span>); </span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Reading from the file&quot;</span> &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 在屏幕上写入数据</span></span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 再次从文件读取数据，并显示它</span></span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 关闭打开的文件</span></span><br><span class="line">   infile.<span class="built_in">close</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列输入和输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Writing to the file</span><br><span class="line">Enter your name: Zara</span><br><span class="line">Enter your age: 9</span><br><span class="line">Reading from the file</span><br><span class="line">Zara</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>
<h2 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::cur );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::end );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定位到 fileObject 的末尾</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( <span class="number">0</span>, ios::end );</span><br></pre></td></tr></table></figure>

<h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++ 异常处理"></a>C++ 异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<p>以下是尝试除以零时抛出异常的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Division by zero condition!</span><br></pre></td></tr></table></figure>

<h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/05/exceptions_in_cpp.png" alt="C++ 异常的层次结构"></p>
<p>下表是对上面层次结构中出现的每个异常的说明：</p>
<table>
<thead>
<tr>
<th align="left">异常</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>std::exception</strong></td>
<td align="left">该异常是所有标准 C++ 异常的父类。</td>
</tr>
<tr>
<td align="left">std::bad_alloc</td>
<td align="left">该异常可以通过 <strong>new</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_cast</td>
<td align="left">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_typeid</td>
<td align="left">该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td align="left">std::bad_exception</td>
<td align="left">这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td align="left"><strong>std::logic_error</strong></td>
<td align="left">理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td align="left">std::domain_error</td>
<td align="left">当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::invalid_argument</td>
<td align="left">当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::length_error</td>
<td align="left">当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::out_of_range</td>
<td align="left">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td>
</tr>
<tr>
<td align="left"><strong>std::runtime_error</strong></td>
<td align="left">理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td align="left">std::overflow_error</td>
<td align="left">当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::range_error</td>
<td align="left">当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td align="left">std::underflow_error</td>
<td align="left">当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody></table>
<h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将产生以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyException caught</span><br><span class="line">C++ Exception</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p>
<p>异常规范声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ERROR</span>&#123;UnderFlow,OverFlow&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h1><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<p>每个容器都有一个单一的定义，比如 <strong>向量</strong>，我们可以定义许多不同类型的向量，比如 <strong>vector <int></strong> 或 **vector <string>**。</p>
<p>您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板函数定义的一般形式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; ret-type func-<span class="built_in">name</span>(parameter list) </span><br><span class="line">&#123;   </span><br><span class="line">	<span class="comment">// 函数的主体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p>
<p>下面是函数模板的实例，返回两个数中的最大值：</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">Max</span> <span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> i = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(i, j): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(i, j) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    <span class="type">double</span> f1 = <span class="number">13.5</span>; </span><br><span class="line">    <span class="type">double</span> f2 = <span class="number">20.7</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(f1, f2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(f1, f2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    string s1 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">    string s2 = <span class="string">&quot;World&quot;</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Max(s1, s2): &quot;</span> &lt;&lt; <span class="built_in">Max</span>(s1, s2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class type&gt; class class-name &#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p>
<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</p>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123; </span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    vector&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;       <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个元素的副本 </span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">hello</span><br><span class="line">Exception: Stack&lt;&gt;::pop(): empty stack</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/30/OOP%E5%90%8E%E7%AF%87/" data-id="cljmaukri00016cu2ca88ap7y" data-title="oop后篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/class/" rel="tag">class</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-makedown学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/29/makedown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-05-28T16:00:00.000Z" itemprop="datePublished">2023-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/29/makedown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Makedown Node</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h1><h2 id="Subtitle"><a href="#Subtitle" class="headerlink" title="Subtitle"></a>Subtitle</h2><ul>
<li><p>字体：</p>
<ul>
<li><p><em>斜体</em>，<strong>粗体</strong>，<em><strong>粗斜体</strong></em></p>
</li>
<li><p><code>高光</code>，<del>删除线</del>，<u>下划线</u></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>插入：</p>
<ul>
<li><p>代码：</p>
<ul>
<li><p>段落插入：<code>print()</code></p>
</li>
<li><p>代码块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>公式：</p>
<ul>
<li><p>段落插入：$\mathbf{F}<em>n &#x3D; \mathbf{F}</em>{n-1}^2$</p>
</li>
<li><p>公式块：<br>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 &#x3D;  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p>
</li>
</ul>
</li>
<li><p>图片：</p>
</li>
</ul>
<blockquote>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/tz9gnswb.png" alt="洛谷图床" style="zoom: 50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网络：</span><br><span class="line">![洛谷图床](https://cdn.luogu.com.cn/upload/image_hosting/tz9gnswb.png)</span><br><span class="line">本地：</span><br><span class="line">![一果流汗](C:\Users\86133\Desktop\SMILE\一果流汗.jpg)</span><br><span class="line">缩放：</span><br><span class="line">&lt;img src=&quot;C:\Users\86133\Desktop\SMILE\一果流汗.jpg&quot; alt=&quot;一果流汗&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>链接：<ul>
<li><a target="_blank" rel="noopener" href="https://www.baidu.com/">Baidu</a></li>
</ul>
</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/29/makedown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cli983vbq0000pgu2b98e0q9x" data-title="Makedown Node" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Study/" rel="tag">Study</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/06/19/hello-world/" class="article-date">
  <time class="dt-published" datetime="2019-06-18T16:00:00.000Z" itemprop="datePublished">2019-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/06/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/06/19/hello-world/" data-id="cli7ie9l70000nku2bek71fa2" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Study/" rel="tag">Study</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/class/" rel="tag">class</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Study/" style="font-size: 10px;">Study</a> <a href="/tags/class/" style="font-size: 20px;">class</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/29/LaTeX%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">LaTeX Formula</a>
          </li>
        
          <li>
            <a href="/2023/06/22/ADS%E5%90%8E%E7%AF%87/">ADS后篇</a>
          </li>
        
          <li>
            <a href="/2023/06/05/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/">认知神经科学导论笔记</a>
          </li>
        
          <li>
            <a href="/2023/05/30/C++%E5%B7%A5%E7%A8%8B%E8%A7%84%E8%8C%83/">C++ Project Norm</a>
          </li>
        
          <li>
            <a href="/2023/05/30/DB%E5%90%8E%E7%AF%87/">DB后篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 LesterYu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>